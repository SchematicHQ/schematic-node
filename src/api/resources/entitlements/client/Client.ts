// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions, BaseRequestOptions } from "../../../../BaseClient.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers.js";
import * as core from "../../../../core/index.js";
import { toJson } from "../../../../core/json.js";
import * as environments from "../../../../environments.js";
import * as errors from "../../../../errors/index.js";
import * as Schematic from "../../../index.js";

export declare namespace Entitlements {
    export interface Options extends BaseClientOptions {}

    export interface RequestOptions extends BaseRequestOptions {}
}

export class Entitlements {
    protected readonly _options: Entitlements.Options;

    constructor(_options: Entitlements.Options = {}) {
        this._options = _options;
    }

    /**
     * @param {Schematic.ListCompanyOverridesRequest} request
     * @param {Entitlements.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.BadRequestError}
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.entitlements.listCompanyOverrides({
     *         company_id: "company_id",
     *         feature_id: "feature_id",
     *         without_expired: true,
     *         q: "q",
     *         limit: 1,
     *         offset: 1
     *     })
     */
    public listCompanyOverrides(
        request: Schematic.ListCompanyOverridesRequest = {},
        requestOptions?: Entitlements.RequestOptions,
    ): core.HttpResponsePromise<Schematic.ListCompanyOverridesResponse> {
        return core.HttpResponsePromise.fromPromise(this.__listCompanyOverrides(request, requestOptions));
    }

    private async __listCompanyOverrides(
        request: Schematic.ListCompanyOverridesRequest = {},
        requestOptions?: Entitlements.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.ListCompanyOverridesResponse>> {
        const {
            company_id: companyId,
            company_ids: companyIds,
            feature_id: featureId,
            feature_ids: featureIds,
            ids,
            without_expired: withoutExpired,
            q,
            limit,
            offset,
        } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (companyId != null) {
            _queryParams.company_id = companyId;
        }

        if (companyIds != null) {
            if (Array.isArray(companyIds)) {
                _queryParams.company_ids = companyIds.map((item) => item);
            } else {
                _queryParams.company_ids = companyIds;
            }
        }

        if (featureId != null) {
            _queryParams.feature_id = featureId;
        }

        if (featureIds != null) {
            if (Array.isArray(featureIds)) {
                _queryParams.feature_ids = featureIds.map((item) => item);
            } else {
                _queryParams.feature_ids = featureIds;
            }
        }

        if (ids != null) {
            if (Array.isArray(ids)) {
                _queryParams.ids = ids.map((item) => item);
            } else {
                _queryParams.ids = ids;
            }
        }

        if (withoutExpired != null) {
            _queryParams.without_expired = withoutExpired.toString();
        }

        if (q != null) {
            _queryParams.q = q;
        }

        if (limit != null) {
            _queryParams.limit = limit.toString();
        }

        if (offset != null) {
            _queryParams.offset = offset.toString();
        }

        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                "company-overrides",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Schematic.ListCompanyOverridesResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Schematic.BadRequestError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SchematicError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SchematicTimeoutError("Timeout exceeded when calling GET /company-overrides.");
            case "unknown":
                throw new errors.SchematicError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Schematic.CreateCompanyOverrideRequestBody} request
     * @param {Entitlements.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.BadRequestError}
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.entitlements.createCompanyOverride({
     *         company_id: "company_id",
     *         feature_id: "feature_id",
     *         value_type: "boolean"
     *     })
     */
    public createCompanyOverride(
        request: Schematic.CreateCompanyOverrideRequestBody,
        requestOptions?: Entitlements.RequestOptions,
    ): core.HttpResponsePromise<Schematic.CreateCompanyOverrideResponse> {
        return core.HttpResponsePromise.fromPromise(this.__createCompanyOverride(request, requestOptions));
    }

    private async __createCompanyOverride(
        request: Schematic.CreateCompanyOverrideRequestBody,
        requestOptions?: Entitlements.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.CreateCompanyOverrideResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                "company-overrides",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Schematic.CreateCompanyOverrideResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Schematic.BadRequestError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SchematicError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SchematicTimeoutError("Timeout exceeded when calling POST /company-overrides.");
            case "unknown":
                throw new errors.SchematicError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} companyOverrideId - company_override_id
     * @param {Entitlements.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.entitlements.getCompanyOverride("company_override_id")
     */
    public getCompanyOverride(
        companyOverrideId: string,
        requestOptions?: Entitlements.RequestOptions,
    ): core.HttpResponsePromise<Schematic.GetCompanyOverrideResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getCompanyOverride(companyOverrideId, requestOptions));
    }

    private async __getCompanyOverride(
        companyOverrideId: string,
        requestOptions?: Entitlements.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.GetCompanyOverrideResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                `company-overrides/${core.url.encodePathParam(companyOverrideId)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Schematic.GetCompanyOverrideResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SchematicError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SchematicTimeoutError(
                    "Timeout exceeded when calling GET /company-overrides/{company_override_id}.",
                );
            case "unknown":
                throw new errors.SchematicError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} companyOverrideId - company_override_id
     * @param {Schematic.UpdateCompanyOverrideRequestBody} request
     * @param {Entitlements.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.BadRequestError}
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.entitlements.updateCompanyOverride("company_override_id", {
     *         value_type: "boolean"
     *     })
     */
    public updateCompanyOverride(
        companyOverrideId: string,
        request: Schematic.UpdateCompanyOverrideRequestBody,
        requestOptions?: Entitlements.RequestOptions,
    ): core.HttpResponsePromise<Schematic.UpdateCompanyOverrideResponse> {
        return core.HttpResponsePromise.fromPromise(
            this.__updateCompanyOverride(companyOverrideId, request, requestOptions),
        );
    }

    private async __updateCompanyOverride(
        companyOverrideId: string,
        request: Schematic.UpdateCompanyOverrideRequestBody,
        requestOptions?: Entitlements.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.UpdateCompanyOverrideResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                `company-overrides/${core.url.encodePathParam(companyOverrideId)}`,
            ),
            method: "PUT",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Schematic.UpdateCompanyOverrideResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Schematic.BadRequestError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SchematicError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SchematicTimeoutError(
                    "Timeout exceeded when calling PUT /company-overrides/{company_override_id}.",
                );
            case "unknown":
                throw new errors.SchematicError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} companyOverrideId - company_override_id
     * @param {Entitlements.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.BadRequestError}
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.entitlements.deleteCompanyOverride("company_override_id")
     */
    public deleteCompanyOverride(
        companyOverrideId: string,
        requestOptions?: Entitlements.RequestOptions,
    ): core.HttpResponsePromise<Schematic.DeleteCompanyOverrideResponse> {
        return core.HttpResponsePromise.fromPromise(this.__deleteCompanyOverride(companyOverrideId, requestOptions));
    }

    private async __deleteCompanyOverride(
        companyOverrideId: string,
        requestOptions?: Entitlements.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.DeleteCompanyOverrideResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                `company-overrides/${core.url.encodePathParam(companyOverrideId)}`,
            ),
            method: "DELETE",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Schematic.DeleteCompanyOverrideResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Schematic.BadRequestError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SchematicError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SchematicTimeoutError(
                    "Timeout exceeded when calling DELETE /company-overrides/{company_override_id}.",
                );
            case "unknown":
                throw new errors.SchematicError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Schematic.CountCompanyOverridesRequest} request
     * @param {Entitlements.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.BadRequestError}
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.entitlements.countCompanyOverrides({
     *         company_id: "company_id",
     *         feature_id: "feature_id",
     *         without_expired: true,
     *         q: "q",
     *         limit: 1,
     *         offset: 1
     *     })
     */
    public countCompanyOverrides(
        request: Schematic.CountCompanyOverridesRequest = {},
        requestOptions?: Entitlements.RequestOptions,
    ): core.HttpResponsePromise<Schematic.CountCompanyOverridesResponse> {
        return core.HttpResponsePromise.fromPromise(this.__countCompanyOverrides(request, requestOptions));
    }

    private async __countCompanyOverrides(
        request: Schematic.CountCompanyOverridesRequest = {},
        requestOptions?: Entitlements.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.CountCompanyOverridesResponse>> {
        const {
            company_id: companyId,
            company_ids: companyIds,
            feature_id: featureId,
            feature_ids: featureIds,
            ids,
            without_expired: withoutExpired,
            q,
            limit,
            offset,
        } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (companyId != null) {
            _queryParams.company_id = companyId;
        }

        if (companyIds != null) {
            if (Array.isArray(companyIds)) {
                _queryParams.company_ids = companyIds.map((item) => item);
            } else {
                _queryParams.company_ids = companyIds;
            }
        }

        if (featureId != null) {
            _queryParams.feature_id = featureId;
        }

        if (featureIds != null) {
            if (Array.isArray(featureIds)) {
                _queryParams.feature_ids = featureIds.map((item) => item);
            } else {
                _queryParams.feature_ids = featureIds;
            }
        }

        if (ids != null) {
            if (Array.isArray(ids)) {
                _queryParams.ids = ids.map((item) => item);
            } else {
                _queryParams.ids = ids;
            }
        }

        if (withoutExpired != null) {
            _queryParams.without_expired = withoutExpired.toString();
        }

        if (q != null) {
            _queryParams.q = q;
        }

        if (limit != null) {
            _queryParams.limit = limit.toString();
        }

        if (offset != null) {
            _queryParams.offset = offset.toString();
        }

        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                "company-overrides/count",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Schematic.CountCompanyOverridesResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Schematic.BadRequestError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SchematicError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SchematicTimeoutError("Timeout exceeded when calling GET /company-overrides/count.");
            case "unknown":
                throw new errors.SchematicError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Schematic.ListFeatureCompaniesRequest} request
     * @param {Entitlements.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.BadRequestError}
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.entitlements.listFeatureCompanies({
     *         feature_id: "feature_id",
     *         q: "q",
     *         limit: 1,
     *         offset: 1
     *     })
     */
    public listFeatureCompanies(
        request: Schematic.ListFeatureCompaniesRequest,
        requestOptions?: Entitlements.RequestOptions,
    ): core.HttpResponsePromise<Schematic.ListFeatureCompaniesResponse> {
        return core.HttpResponsePromise.fromPromise(this.__listFeatureCompanies(request, requestOptions));
    }

    private async __listFeatureCompanies(
        request: Schematic.ListFeatureCompaniesRequest,
        requestOptions?: Entitlements.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.ListFeatureCompaniesResponse>> {
        const { feature_id: featureId, q, limit, offset } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams.feature_id = featureId;
        if (q != null) {
            _queryParams.q = q;
        }

        if (limit != null) {
            _queryParams.limit = limit.toString();
        }

        if (offset != null) {
            _queryParams.offset = offset.toString();
        }

        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                "feature-companies",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Schematic.ListFeatureCompaniesResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Schematic.BadRequestError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SchematicError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SchematicTimeoutError("Timeout exceeded when calling GET /feature-companies.");
            case "unknown":
                throw new errors.SchematicError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Schematic.CountFeatureCompaniesRequest} request
     * @param {Entitlements.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.BadRequestError}
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.entitlements.countFeatureCompanies({
     *         feature_id: "feature_id",
     *         q: "q",
     *         limit: 1,
     *         offset: 1
     *     })
     */
    public countFeatureCompanies(
        request: Schematic.CountFeatureCompaniesRequest,
        requestOptions?: Entitlements.RequestOptions,
    ): core.HttpResponsePromise<Schematic.CountFeatureCompaniesResponse> {
        return core.HttpResponsePromise.fromPromise(this.__countFeatureCompanies(request, requestOptions));
    }

    private async __countFeatureCompanies(
        request: Schematic.CountFeatureCompaniesRequest,
        requestOptions?: Entitlements.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.CountFeatureCompaniesResponse>> {
        const { feature_id: featureId, q, limit, offset } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams.feature_id = featureId;
        if (q != null) {
            _queryParams.q = q;
        }

        if (limit != null) {
            _queryParams.limit = limit.toString();
        }

        if (offset != null) {
            _queryParams.offset = offset.toString();
        }

        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                "feature-companies/count",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Schematic.CountFeatureCompaniesResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Schematic.BadRequestError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SchematicError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SchematicTimeoutError("Timeout exceeded when calling GET /feature-companies/count.");
            case "unknown":
                throw new errors.SchematicError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Schematic.ListFeatureUsageRequest} request
     * @param {Entitlements.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.BadRequestError}
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.entitlements.listFeatureUsage({
     *         company_id: "company_id",
     *         q: "q",
     *         without_negative_entitlements: true,
     *         limit: 1,
     *         offset: 1
     *     })
     */
    public listFeatureUsage(
        request: Schematic.ListFeatureUsageRequest = {},
        requestOptions?: Entitlements.RequestOptions,
    ): core.HttpResponsePromise<Schematic.ListFeatureUsageResponse> {
        return core.HttpResponsePromise.fromPromise(this.__listFeatureUsage(request, requestOptions));
    }

    private async __listFeatureUsage(
        request: Schematic.ListFeatureUsageRequest = {},
        requestOptions?: Entitlements.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.ListFeatureUsageResponse>> {
        const {
            company_id: companyId,
            company_keys: companyKeys,
            feature_ids: featureIds,
            q,
            without_negative_entitlements: withoutNegativeEntitlements,
            limit,
            offset,
        } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (companyId != null) {
            _queryParams.company_id = companyId;
        }

        if (companyKeys != null) {
            _queryParams.company_keys = toJson(companyKeys);
        }

        if (featureIds != null) {
            if (Array.isArray(featureIds)) {
                _queryParams.feature_ids = featureIds.map((item) => item);
            } else {
                _queryParams.feature_ids = featureIds;
            }
        }

        if (q != null) {
            _queryParams.q = q;
        }

        if (withoutNegativeEntitlements != null) {
            _queryParams.without_negative_entitlements = withoutNegativeEntitlements.toString();
        }

        if (limit != null) {
            _queryParams.limit = limit.toString();
        }

        if (offset != null) {
            _queryParams.offset = offset.toString();
        }

        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                "feature-usage",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Schematic.ListFeatureUsageResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Schematic.BadRequestError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SchematicError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SchematicTimeoutError("Timeout exceeded when calling GET /feature-usage.");
            case "unknown":
                throw new errors.SchematicError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Schematic.CountFeatureUsageRequest} request
     * @param {Entitlements.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.BadRequestError}
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.entitlements.countFeatureUsage({
     *         company_id: "company_id",
     *         q: "q",
     *         without_negative_entitlements: true,
     *         limit: 1,
     *         offset: 1
     *     })
     */
    public countFeatureUsage(
        request: Schematic.CountFeatureUsageRequest = {},
        requestOptions?: Entitlements.RequestOptions,
    ): core.HttpResponsePromise<Schematic.CountFeatureUsageResponse> {
        return core.HttpResponsePromise.fromPromise(this.__countFeatureUsage(request, requestOptions));
    }

    private async __countFeatureUsage(
        request: Schematic.CountFeatureUsageRequest = {},
        requestOptions?: Entitlements.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.CountFeatureUsageResponse>> {
        const {
            company_id: companyId,
            company_keys: companyKeys,
            feature_ids: featureIds,
            q,
            without_negative_entitlements: withoutNegativeEntitlements,
            limit,
            offset,
        } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (companyId != null) {
            _queryParams.company_id = companyId;
        }

        if (companyKeys != null) {
            _queryParams.company_keys = toJson(companyKeys);
        }

        if (featureIds != null) {
            if (Array.isArray(featureIds)) {
                _queryParams.feature_ids = featureIds.map((item) => item);
            } else {
                _queryParams.feature_ids = featureIds;
            }
        }

        if (q != null) {
            _queryParams.q = q;
        }

        if (withoutNegativeEntitlements != null) {
            _queryParams.without_negative_entitlements = withoutNegativeEntitlements.toString();
        }

        if (limit != null) {
            _queryParams.limit = limit.toString();
        }

        if (offset != null) {
            _queryParams.offset = offset.toString();
        }

        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                "feature-usage/count",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Schematic.CountFeatureUsageResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Schematic.BadRequestError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SchematicError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SchematicTimeoutError("Timeout exceeded when calling GET /feature-usage/count.");
            case "unknown":
                throw new errors.SchematicError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Schematic.ListFeatureUsersRequest} request
     * @param {Entitlements.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.BadRequestError}
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.entitlements.listFeatureUsers({
     *         feature_id: "feature_id",
     *         q: "q",
     *         limit: 1,
     *         offset: 1
     *     })
     */
    public listFeatureUsers(
        request: Schematic.ListFeatureUsersRequest,
        requestOptions?: Entitlements.RequestOptions,
    ): core.HttpResponsePromise<Schematic.ListFeatureUsersResponse> {
        return core.HttpResponsePromise.fromPromise(this.__listFeatureUsers(request, requestOptions));
    }

    private async __listFeatureUsers(
        request: Schematic.ListFeatureUsersRequest,
        requestOptions?: Entitlements.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.ListFeatureUsersResponse>> {
        const { feature_id: featureId, q, limit, offset } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams.feature_id = featureId;
        if (q != null) {
            _queryParams.q = q;
        }

        if (limit != null) {
            _queryParams.limit = limit.toString();
        }

        if (offset != null) {
            _queryParams.offset = offset.toString();
        }

        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                "feature-users",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Schematic.ListFeatureUsersResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Schematic.BadRequestError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SchematicError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SchematicTimeoutError("Timeout exceeded when calling GET /feature-users.");
            case "unknown":
                throw new errors.SchematicError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Schematic.CountFeatureUsersRequest} request
     * @param {Entitlements.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.BadRequestError}
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.entitlements.countFeatureUsers({
     *         feature_id: "feature_id",
     *         q: "q",
     *         limit: 1,
     *         offset: 1
     *     })
     */
    public countFeatureUsers(
        request: Schematic.CountFeatureUsersRequest,
        requestOptions?: Entitlements.RequestOptions,
    ): core.HttpResponsePromise<Schematic.CountFeatureUsersResponse> {
        return core.HttpResponsePromise.fromPromise(this.__countFeatureUsers(request, requestOptions));
    }

    private async __countFeatureUsers(
        request: Schematic.CountFeatureUsersRequest,
        requestOptions?: Entitlements.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.CountFeatureUsersResponse>> {
        const { feature_id: featureId, q, limit, offset } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams.feature_id = featureId;
        if (q != null) {
            _queryParams.q = q;
        }

        if (limit != null) {
            _queryParams.limit = limit.toString();
        }

        if (offset != null) {
            _queryParams.offset = offset.toString();
        }

        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                "feature-users/count",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Schematic.CountFeatureUsersResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Schematic.BadRequestError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SchematicError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SchematicTimeoutError("Timeout exceeded when calling GET /feature-users/count.");
            case "unknown":
                throw new errors.SchematicError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Schematic.ListPlanEntitlementsRequest} request
     * @param {Entitlements.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.BadRequestError}
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.entitlements.listPlanEntitlements({
     *         feature_id: "feature_id",
     *         plan_id: "plan_id",
     *         q: "q",
     *         with_metered_products: true,
     *         limit: 1,
     *         offset: 1
     *     })
     */
    public listPlanEntitlements(
        request: Schematic.ListPlanEntitlementsRequest = {},
        requestOptions?: Entitlements.RequestOptions,
    ): core.HttpResponsePromise<Schematic.ListPlanEntitlementsResponse> {
        return core.HttpResponsePromise.fromPromise(this.__listPlanEntitlements(request, requestOptions));
    }

    private async __listPlanEntitlements(
        request: Schematic.ListPlanEntitlementsRequest = {},
        requestOptions?: Entitlements.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.ListPlanEntitlementsResponse>> {
        const {
            feature_id: featureId,
            feature_ids: featureIds,
            ids,
            plan_id: planId,
            plan_ids: planIds,
            q,
            with_metered_products: withMeteredProducts,
            limit,
            offset,
        } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (featureId != null) {
            _queryParams.feature_id = featureId;
        }

        if (featureIds != null) {
            if (Array.isArray(featureIds)) {
                _queryParams.feature_ids = featureIds.map((item) => item);
            } else {
                _queryParams.feature_ids = featureIds;
            }
        }

        if (ids != null) {
            if (Array.isArray(ids)) {
                _queryParams.ids = ids.map((item) => item);
            } else {
                _queryParams.ids = ids;
            }
        }

        if (planId != null) {
            _queryParams.plan_id = planId;
        }

        if (planIds != null) {
            if (Array.isArray(planIds)) {
                _queryParams.plan_ids = planIds.map((item) => item);
            } else {
                _queryParams.plan_ids = planIds;
            }
        }

        if (q != null) {
            _queryParams.q = q;
        }

        if (withMeteredProducts != null) {
            _queryParams.with_metered_products = withMeteredProducts.toString();
        }

        if (limit != null) {
            _queryParams.limit = limit.toString();
        }

        if (offset != null) {
            _queryParams.offset = offset.toString();
        }

        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                "plan-entitlements",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Schematic.ListPlanEntitlementsResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Schematic.BadRequestError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SchematicError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SchematicTimeoutError("Timeout exceeded when calling GET /plan-entitlements.");
            case "unknown":
                throw new errors.SchematicError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Schematic.CreatePlanEntitlementRequestBody} request
     * @param {Entitlements.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.BadRequestError}
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.entitlements.createPlanEntitlement({
     *         feature_id: "feature_id",
     *         plan_id: "plan_id",
     *         value_type: "boolean"
     *     })
     */
    public createPlanEntitlement(
        request: Schematic.CreatePlanEntitlementRequestBody,
        requestOptions?: Entitlements.RequestOptions,
    ): core.HttpResponsePromise<Schematic.CreatePlanEntitlementResponse> {
        return core.HttpResponsePromise.fromPromise(this.__createPlanEntitlement(request, requestOptions));
    }

    private async __createPlanEntitlement(
        request: Schematic.CreatePlanEntitlementRequestBody,
        requestOptions?: Entitlements.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.CreatePlanEntitlementResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                "plan-entitlements",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Schematic.CreatePlanEntitlementResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Schematic.BadRequestError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SchematicError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SchematicTimeoutError("Timeout exceeded when calling POST /plan-entitlements.");
            case "unknown":
                throw new errors.SchematicError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} planEntitlementId - plan_entitlement_id
     * @param {Entitlements.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.entitlements.getPlanEntitlement("plan_entitlement_id")
     */
    public getPlanEntitlement(
        planEntitlementId: string,
        requestOptions?: Entitlements.RequestOptions,
    ): core.HttpResponsePromise<Schematic.GetPlanEntitlementResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getPlanEntitlement(planEntitlementId, requestOptions));
    }

    private async __getPlanEntitlement(
        planEntitlementId: string,
        requestOptions?: Entitlements.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.GetPlanEntitlementResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                `plan-entitlements/${core.url.encodePathParam(planEntitlementId)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Schematic.GetPlanEntitlementResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SchematicError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SchematicTimeoutError(
                    "Timeout exceeded when calling GET /plan-entitlements/{plan_entitlement_id}.",
                );
            case "unknown":
                throw new errors.SchematicError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} planEntitlementId - plan_entitlement_id
     * @param {Schematic.UpdatePlanEntitlementRequestBody} request
     * @param {Entitlements.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.BadRequestError}
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.entitlements.updatePlanEntitlement("plan_entitlement_id", {
     *         value_type: "boolean"
     *     })
     */
    public updatePlanEntitlement(
        planEntitlementId: string,
        request: Schematic.UpdatePlanEntitlementRequestBody,
        requestOptions?: Entitlements.RequestOptions,
    ): core.HttpResponsePromise<Schematic.UpdatePlanEntitlementResponse> {
        return core.HttpResponsePromise.fromPromise(
            this.__updatePlanEntitlement(planEntitlementId, request, requestOptions),
        );
    }

    private async __updatePlanEntitlement(
        planEntitlementId: string,
        request: Schematic.UpdatePlanEntitlementRequestBody,
        requestOptions?: Entitlements.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.UpdatePlanEntitlementResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                `plan-entitlements/${core.url.encodePathParam(planEntitlementId)}`,
            ),
            method: "PUT",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Schematic.UpdatePlanEntitlementResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Schematic.BadRequestError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SchematicError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SchematicTimeoutError(
                    "Timeout exceeded when calling PUT /plan-entitlements/{plan_entitlement_id}.",
                );
            case "unknown":
                throw new errors.SchematicError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} planEntitlementId - plan_entitlement_id
     * @param {Entitlements.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.BadRequestError}
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.entitlements.deletePlanEntitlement("plan_entitlement_id")
     */
    public deletePlanEntitlement(
        planEntitlementId: string,
        requestOptions?: Entitlements.RequestOptions,
    ): core.HttpResponsePromise<Schematic.DeletePlanEntitlementResponse> {
        return core.HttpResponsePromise.fromPromise(this.__deletePlanEntitlement(planEntitlementId, requestOptions));
    }

    private async __deletePlanEntitlement(
        planEntitlementId: string,
        requestOptions?: Entitlements.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.DeletePlanEntitlementResponse>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                `plan-entitlements/${core.url.encodePathParam(planEntitlementId)}`,
            ),
            method: "DELETE",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Schematic.DeletePlanEntitlementResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Schematic.BadRequestError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SchematicError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SchematicTimeoutError(
                    "Timeout exceeded when calling DELETE /plan-entitlements/{plan_entitlement_id}.",
                );
            case "unknown":
                throw new errors.SchematicError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Schematic.CountPlanEntitlementsRequest} request
     * @param {Entitlements.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.BadRequestError}
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.entitlements.countPlanEntitlements({
     *         feature_id: "feature_id",
     *         plan_id: "plan_id",
     *         q: "q",
     *         with_metered_products: true,
     *         limit: 1,
     *         offset: 1
     *     })
     */
    public countPlanEntitlements(
        request: Schematic.CountPlanEntitlementsRequest = {},
        requestOptions?: Entitlements.RequestOptions,
    ): core.HttpResponsePromise<Schematic.CountPlanEntitlementsResponse> {
        return core.HttpResponsePromise.fromPromise(this.__countPlanEntitlements(request, requestOptions));
    }

    private async __countPlanEntitlements(
        request: Schematic.CountPlanEntitlementsRequest = {},
        requestOptions?: Entitlements.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.CountPlanEntitlementsResponse>> {
        const {
            feature_id: featureId,
            feature_ids: featureIds,
            ids,
            plan_id: planId,
            plan_ids: planIds,
            q,
            with_metered_products: withMeteredProducts,
            limit,
            offset,
        } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (featureId != null) {
            _queryParams.feature_id = featureId;
        }

        if (featureIds != null) {
            if (Array.isArray(featureIds)) {
                _queryParams.feature_ids = featureIds.map((item) => item);
            } else {
                _queryParams.feature_ids = featureIds;
            }
        }

        if (ids != null) {
            if (Array.isArray(ids)) {
                _queryParams.ids = ids.map((item) => item);
            } else {
                _queryParams.ids = ids;
            }
        }

        if (planId != null) {
            _queryParams.plan_id = planId;
        }

        if (planIds != null) {
            if (Array.isArray(planIds)) {
                _queryParams.plan_ids = planIds.map((item) => item);
            } else {
                _queryParams.plan_ids = planIds;
            }
        }

        if (q != null) {
            _queryParams.q = q;
        }

        if (withMeteredProducts != null) {
            _queryParams.with_metered_products = withMeteredProducts.toString();
        }

        if (limit != null) {
            _queryParams.limit = limit.toString();
        }

        if (offset != null) {
            _queryParams.offset = offset.toString();
        }

        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                "plan-entitlements/count",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Schematic.CountPlanEntitlementsResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Schematic.BadRequestError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SchematicError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SchematicTimeoutError("Timeout exceeded when calling GET /plan-entitlements/count.");
            case "unknown":
                throw new errors.SchematicError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Schematic.GetFeatureUsageByCompanyRequest} request
     * @param {Entitlements.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.entitlements.getFeatureUsageByCompany({
     *         keys: {
     *             "keys": "keys"
     *         }
     *     })
     */
    public getFeatureUsageByCompany(
        request: Schematic.GetFeatureUsageByCompanyRequest,
        requestOptions?: Entitlements.RequestOptions,
    ): core.HttpResponsePromise<Schematic.GetFeatureUsageByCompanyResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getFeatureUsageByCompany(request, requestOptions));
    }

    private async __getFeatureUsageByCompany(
        request: Schematic.GetFeatureUsageByCompanyRequest,
        requestOptions?: Entitlements.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.GetFeatureUsageByCompanyResponse>> {
        const { keys } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams.keys = toJson(keys);
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                "usage-by-company",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Schematic.GetFeatureUsageByCompanyResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SchematicError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SchematicTimeoutError("Timeout exceeded when calling GET /usage-by-company.");
            case "unknown":
                throw new errors.SchematicError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getCustomAuthorizationHeaders(): Promise<Record<string, string | undefined>> {
        const apiKeyValue = await core.Supplier.get(this._options.apiKey);
        return { "X-Schematic-Api-Key": apiKeyValue };
    }
}
