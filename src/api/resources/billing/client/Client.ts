/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments.js";
import * as core from "../../../../core/index.js";
import * as Schematic from "../../../index.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers.js";
import * as errors from "../../../../errors/index.js";

export declare namespace Billing {
    export interface Options {
        environment?: core.Supplier<environments.SchematicEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier<string>;
        apiKey: core.Supplier<string>;
        /** Additional headers to include in requests. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
        fetcher?: core.FetchFunction;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Additional query string parameters to include in the request. */
        queryParams?: Record<string, unknown>;
        /** Additional headers to include in the request. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
    }
}

export class Billing {
    protected readonly _options: Billing.Options;

    constructor(_options: Billing.Options) {
        this._options = _options;
    }

    /**
     * @param {Schematic.ListCouponsRequest} request
     * @param {Billing.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.BadRequestError}
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.billing.listCoupons()
     */
    public listCoupons(
        request: Schematic.ListCouponsRequest = {},
        requestOptions?: Billing.RequestOptions,
    ): core.HttpResponsePromise<Schematic.ListCouponsResponse> {
        return core.HttpResponsePromise.fromPromise(this.__listCoupons(request, requestOptions));
    }

    private async __listCoupons(
        request: Schematic.ListCouponsRequest = {},
        requestOptions?: Billing.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.ListCouponsResponse>> {
        const { is_active: isActive, q, limit, offset } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (isActive != null) {
            _queryParams["is_active"] = isActive.toString();
        }

        if (q != null) {
            _queryParams["q"] = q;
        }

        if (limit != null) {
            _queryParams["limit"] = limit.toString();
        }

        if (offset != null) {
            _queryParams["offset"] = offset.toString();
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                "billing/coupons",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
                requestOptions?.headers,
            ),
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Schematic.ListCouponsResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Schematic.BadRequestError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SchematicError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SchematicTimeoutError("Timeout exceeded when calling GET /billing/coupons.");
            case "unknown":
                throw new errors.SchematicError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Schematic.CreateCouponRequestBody} request
     * @param {Billing.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.BadRequestError}
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.billing.upsertBillingCoupon({
     *         amount_off: 1,
     *         duration: "duration",
     *         duration_in_months: 1,
     *         external_id: "external_id",
     *         max_redemptions: 1,
     *         name: "name",
     *         percent_off: 1.1,
     *         times_redeemed: 1
     *     })
     */
    public upsertBillingCoupon(
        request: Schematic.CreateCouponRequestBody,
        requestOptions?: Billing.RequestOptions,
    ): core.HttpResponsePromise<Schematic.UpsertBillingCouponResponse> {
        return core.HttpResponsePromise.fromPromise(this.__upsertBillingCoupon(request, requestOptions));
    }

    private async __upsertBillingCoupon(
        request: Schematic.CreateCouponRequestBody,
        requestOptions?: Billing.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.UpsertBillingCouponResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                "billing/coupons",
            ),
            method: "POST",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Schematic.UpsertBillingCouponResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Schematic.BadRequestError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SchematicError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SchematicTimeoutError("Timeout exceeded when calling POST /billing/coupons.");
            case "unknown":
                throw new errors.SchematicError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Schematic.CreateBillingCustomerRequestBody} request
     * @param {Billing.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.BadRequestError}
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.billing.upsertBillingCustomer({
     *         email: "email",
     *         external_id: "external_id",
     *         failed_to_import: true,
     *         meta: {
     *             "key": "value"
     *         },
     *         name: "name"
     *     })
     */
    public upsertBillingCustomer(
        request: Schematic.CreateBillingCustomerRequestBody,
        requestOptions?: Billing.RequestOptions,
    ): core.HttpResponsePromise<Schematic.UpsertBillingCustomerResponse> {
        return core.HttpResponsePromise.fromPromise(this.__upsertBillingCustomer(request, requestOptions));
    }

    private async __upsertBillingCustomer(
        request: Schematic.CreateBillingCustomerRequestBody,
        requestOptions?: Billing.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.UpsertBillingCustomerResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                "billing/customer/upsert",
            ),
            method: "POST",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Schematic.UpsertBillingCustomerResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Schematic.BadRequestError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SchematicError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SchematicTimeoutError("Timeout exceeded when calling POST /billing/customer/upsert.");
            case "unknown":
                throw new errors.SchematicError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Schematic.ListCustomersWithSubscriptionsRequest} request
     * @param {Billing.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.BadRequestError}
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.billing.listCustomersWithSubscriptions()
     */
    public listCustomersWithSubscriptions(
        request: Schematic.ListCustomersWithSubscriptionsRequest = {},
        requestOptions?: Billing.RequestOptions,
    ): core.HttpResponsePromise<Schematic.ListCustomersWithSubscriptionsResponse> {
        return core.HttpResponsePromise.fromPromise(this.__listCustomersWithSubscriptions(request, requestOptions));
    }

    private async __listCustomersWithSubscriptions(
        request: Schematic.ListCustomersWithSubscriptionsRequest = {},
        requestOptions?: Billing.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.ListCustomersWithSubscriptionsResponse>> {
        const { company_ids: companyIds, name, failed_to_import: failedToImport, q, limit, offset } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (companyIds != null) {
            if (Array.isArray(companyIds)) {
                _queryParams["company_ids"] = companyIds.map((item) => item);
            } else {
                _queryParams["company_ids"] = companyIds;
            }
        }

        if (name != null) {
            _queryParams["name"] = name;
        }

        if (failedToImport != null) {
            _queryParams["failed_to_import"] = failedToImport.toString();
        }

        if (q != null) {
            _queryParams["q"] = q;
        }

        if (limit != null) {
            _queryParams["limit"] = limit.toString();
        }

        if (offset != null) {
            _queryParams["offset"] = offset.toString();
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                "billing/customers",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
                requestOptions?.headers,
            ),
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Schematic.ListCustomersWithSubscriptionsResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Schematic.BadRequestError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SchematicError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SchematicTimeoutError("Timeout exceeded when calling GET /billing/customers.");
            case "unknown":
                throw new errors.SchematicError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Schematic.CountCustomersRequest} request
     * @param {Billing.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.BadRequestError}
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.billing.countCustomers()
     */
    public countCustomers(
        request: Schematic.CountCustomersRequest = {},
        requestOptions?: Billing.RequestOptions,
    ): core.HttpResponsePromise<Schematic.CountCustomersResponse> {
        return core.HttpResponsePromise.fromPromise(this.__countCustomers(request, requestOptions));
    }

    private async __countCustomers(
        request: Schematic.CountCustomersRequest = {},
        requestOptions?: Billing.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.CountCustomersResponse>> {
        const { company_ids: companyIds, name, failed_to_import: failedToImport, q, limit, offset } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (companyIds != null) {
            if (Array.isArray(companyIds)) {
                _queryParams["company_ids"] = companyIds.map((item) => item);
            } else {
                _queryParams["company_ids"] = companyIds;
            }
        }

        if (name != null) {
            _queryParams["name"] = name;
        }

        if (failedToImport != null) {
            _queryParams["failed_to_import"] = failedToImport.toString();
        }

        if (q != null) {
            _queryParams["q"] = q;
        }

        if (limit != null) {
            _queryParams["limit"] = limit.toString();
        }

        if (offset != null) {
            _queryParams["offset"] = offset.toString();
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                "billing/customers/count",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
                requestOptions?.headers,
            ),
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Schematic.CountCustomersResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Schematic.BadRequestError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SchematicError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SchematicTimeoutError("Timeout exceeded when calling GET /billing/customers/count.");
            case "unknown":
                throw new errors.SchematicError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Schematic.ListInvoicesRequest} request
     * @param {Billing.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.BadRequestError}
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.billing.listInvoices({
     *         customer_external_id: "customer_external_id",
     *         subscription_external_id: "subscription_external_id"
     *     })
     */
    public listInvoices(
        request: Schematic.ListInvoicesRequest,
        requestOptions?: Billing.RequestOptions,
    ): core.HttpResponsePromise<Schematic.ListInvoicesResponse> {
        return core.HttpResponsePromise.fromPromise(this.__listInvoices(request, requestOptions));
    }

    private async __listInvoices(
        request: Schematic.ListInvoicesRequest,
        requestOptions?: Billing.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.ListInvoicesResponse>> {
        const {
            company_id: companyId,
            customer_external_id: customerExternalId,
            subscription_external_id: subscriptionExternalId,
            limit,
            offset,
        } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (companyId != null) {
            _queryParams["company_id"] = companyId;
        }

        _queryParams["customer_external_id"] = customerExternalId;
        _queryParams["subscription_external_id"] = subscriptionExternalId;
        if (limit != null) {
            _queryParams["limit"] = limit.toString();
        }

        if (offset != null) {
            _queryParams["offset"] = offset.toString();
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                "billing/invoices",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
                requestOptions?.headers,
            ),
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Schematic.ListInvoicesResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Schematic.BadRequestError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SchematicError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SchematicTimeoutError("Timeout exceeded when calling GET /billing/invoices.");
            case "unknown":
                throw new errors.SchematicError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Schematic.CreateInvoiceRequestBody} request
     * @param {Billing.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.BadRequestError}
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.billing.upsertInvoice({
     *         amount_due: 1,
     *         amount_paid: 1,
     *         amount_remaining: 1,
     *         collection_method: "collection_method",
     *         currency: "currency",
     *         customer_external_id: "customer_external_id",
     *         subtotal: 1
     *     })
     */
    public upsertInvoice(
        request: Schematic.CreateInvoiceRequestBody,
        requestOptions?: Billing.RequestOptions,
    ): core.HttpResponsePromise<Schematic.UpsertInvoiceResponse> {
        return core.HttpResponsePromise.fromPromise(this.__upsertInvoice(request, requestOptions));
    }

    private async __upsertInvoice(
        request: Schematic.CreateInvoiceRequestBody,
        requestOptions?: Billing.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.UpsertInvoiceResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                "billing/invoices",
            ),
            method: "POST",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Schematic.UpsertInvoiceResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Schematic.BadRequestError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SchematicError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SchematicTimeoutError("Timeout exceeded when calling POST /billing/invoices.");
            case "unknown":
                throw new errors.SchematicError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Schematic.ListMetersRequest} request
     * @param {Billing.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.BadRequestError}
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.billing.listMeters()
     */
    public listMeters(
        request: Schematic.ListMetersRequest = {},
        requestOptions?: Billing.RequestOptions,
    ): core.HttpResponsePromise<Schematic.ListMetersResponse> {
        return core.HttpResponsePromise.fromPromise(this.__listMeters(request, requestOptions));
    }

    private async __listMeters(
        request: Schematic.ListMetersRequest = {},
        requestOptions?: Billing.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.ListMetersResponse>> {
        const { display_name: displayName, limit, offset } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (displayName != null) {
            _queryParams["display_name"] = displayName;
        }

        if (limit != null) {
            _queryParams["limit"] = limit.toString();
        }

        if (offset != null) {
            _queryParams["offset"] = offset.toString();
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                "billing/meter",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
                requestOptions?.headers,
            ),
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Schematic.ListMetersResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Schematic.BadRequestError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SchematicError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SchematicTimeoutError("Timeout exceeded when calling GET /billing/meter.");
            case "unknown":
                throw new errors.SchematicError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Schematic.CreateMeterRequestBody} request
     * @param {Billing.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.BadRequestError}
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.billing.upsertBillingMeter({
     *         display_name: "display_name",
     *         event_name: "event_name",
     *         event_payload_key: "event_payload_key",
     *         external_id: "external_id"
     *     })
     */
    public upsertBillingMeter(
        request: Schematic.CreateMeterRequestBody,
        requestOptions?: Billing.RequestOptions,
    ): core.HttpResponsePromise<Schematic.UpsertBillingMeterResponse> {
        return core.HttpResponsePromise.fromPromise(this.__upsertBillingMeter(request, requestOptions));
    }

    private async __upsertBillingMeter(
        request: Schematic.CreateMeterRequestBody,
        requestOptions?: Billing.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.UpsertBillingMeterResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                "billing/meter/upsert",
            ),
            method: "POST",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Schematic.UpsertBillingMeterResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Schematic.BadRequestError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SchematicError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SchematicTimeoutError("Timeout exceeded when calling POST /billing/meter/upsert.");
            case "unknown":
                throw new errors.SchematicError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Schematic.ListPaymentMethodsRequest} request
     * @param {Billing.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.BadRequestError}
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.billing.listPaymentMethods({
     *         customer_external_id: "customer_external_id"
     *     })
     */
    public listPaymentMethods(
        request: Schematic.ListPaymentMethodsRequest,
        requestOptions?: Billing.RequestOptions,
    ): core.HttpResponsePromise<Schematic.ListPaymentMethodsResponse> {
        return core.HttpResponsePromise.fromPromise(this.__listPaymentMethods(request, requestOptions));
    }

    private async __listPaymentMethods(
        request: Schematic.ListPaymentMethodsRequest,
        requestOptions?: Billing.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.ListPaymentMethodsResponse>> {
        const { company_id: companyId, customer_external_id: customerExternalId, limit, offset } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (companyId != null) {
            _queryParams["company_id"] = companyId;
        }

        _queryParams["customer_external_id"] = customerExternalId;
        if (limit != null) {
            _queryParams["limit"] = limit.toString();
        }

        if (offset != null) {
            _queryParams["offset"] = offset.toString();
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                "billing/payment-methods",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
                requestOptions?.headers,
            ),
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Schematic.ListPaymentMethodsResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Schematic.BadRequestError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SchematicError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SchematicTimeoutError("Timeout exceeded when calling GET /billing/payment-methods.");
            case "unknown":
                throw new errors.SchematicError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Schematic.CreatePaymentMethodRequestBody} request
     * @param {Billing.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.BadRequestError}
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.billing.upsertPaymentMethod({
     *         customer_external_id: "customer_external_id",
     *         external_id: "external_id",
     *         payment_method_type: "payment_method_type"
     *     })
     */
    public upsertPaymentMethod(
        request: Schematic.CreatePaymentMethodRequestBody,
        requestOptions?: Billing.RequestOptions,
    ): core.HttpResponsePromise<Schematic.UpsertPaymentMethodResponse> {
        return core.HttpResponsePromise.fromPromise(this.__upsertPaymentMethod(request, requestOptions));
    }

    private async __upsertPaymentMethod(
        request: Schematic.CreatePaymentMethodRequestBody,
        requestOptions?: Billing.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.UpsertPaymentMethodResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                "billing/payment-methods",
            ),
            method: "POST",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Schematic.UpsertPaymentMethodResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Schematic.BadRequestError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SchematicError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SchematicTimeoutError("Timeout exceeded when calling POST /billing/payment-methods.");
            case "unknown":
                throw new errors.SchematicError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Schematic.SearchBillingPricesRequest} request
     * @param {Billing.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.BadRequestError}
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.billing.searchBillingPrices()
     */
    public searchBillingPrices(
        request: Schematic.SearchBillingPricesRequest = {},
        requestOptions?: Billing.RequestOptions,
    ): core.HttpResponsePromise<Schematic.SearchBillingPricesResponse> {
        return core.HttpResponsePromise.fromPromise(this.__searchBillingPrices(request, requestOptions));
    }

    private async __searchBillingPrices(
        request: Schematic.SearchBillingPricesRequest = {},
        requestOptions?: Billing.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.SearchBillingPricesResponse>> {
        const { ids, q, interval, usage_type: usageType, price, tiers_mode: tiersMode, limit, offset } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (ids != null) {
            if (Array.isArray(ids)) {
                _queryParams["ids"] = ids.map((item) => item);
            } else {
                _queryParams["ids"] = ids;
            }
        }

        if (q != null) {
            _queryParams["q"] = q;
        }

        if (interval != null) {
            _queryParams["interval"] = interval;
        }

        if (usageType != null) {
            _queryParams["usage_type"] = usageType;
        }

        if (price != null) {
            _queryParams["price"] = price.toString();
        }

        if (tiersMode != null) {
            _queryParams["tiers_mode"] = tiersMode;
        }

        if (limit != null) {
            _queryParams["limit"] = limit.toString();
        }

        if (offset != null) {
            _queryParams["offset"] = offset.toString();
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                "billing/price",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
                requestOptions?.headers,
            ),
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Schematic.SearchBillingPricesResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Schematic.BadRequestError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SchematicError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SchematicTimeoutError("Timeout exceeded when calling GET /billing/price.");
            case "unknown":
                throw new errors.SchematicError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Schematic.CreateBillingPriceRequestBody} request
     * @param {Billing.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.BadRequestError}
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.billing.upsertBillingPrice({
     *         billing_scheme: "per_unit",
     *         currency: "currency",
     *         external_account_id: "external_account_id",
     *         interval: "interval",
     *         is_active: true,
     *         price: 1,
     *         price_external_id: "price_external_id",
     *         price_tiers: [{
     *                 price_external_id: "price_external_id"
     *             }],
     *         product_external_id: "product_external_id",
     *         usage_type: "licensed"
     *     })
     */
    public upsertBillingPrice(
        request: Schematic.CreateBillingPriceRequestBody,
        requestOptions?: Billing.RequestOptions,
    ): core.HttpResponsePromise<Schematic.UpsertBillingPriceResponse> {
        return core.HttpResponsePromise.fromPromise(this.__upsertBillingPrice(request, requestOptions));
    }

    private async __upsertBillingPrice(
        request: Schematic.CreateBillingPriceRequestBody,
        requestOptions?: Billing.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.UpsertBillingPriceResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                "billing/price/upsert",
            ),
            method: "POST",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Schematic.UpsertBillingPriceResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Schematic.BadRequestError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SchematicError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SchematicTimeoutError("Timeout exceeded when calling POST /billing/price/upsert.");
            case "unknown":
                throw new errors.SchematicError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} billingId - billing_id
     * @param {Billing.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.BadRequestError}
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.billing.deleteBillingProduct("billing_id")
     */
    public deleteBillingProduct(
        billingId: string,
        requestOptions?: Billing.RequestOptions,
    ): core.HttpResponsePromise<Schematic.DeleteBillingProductResponse> {
        return core.HttpResponsePromise.fromPromise(this.__deleteBillingProduct(billingId, requestOptions));
    }

    private async __deleteBillingProduct(
        billingId: string,
        requestOptions?: Billing.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.DeleteBillingProductResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                `billing/product/${encodeURIComponent(billingId)}`,
            ),
            method: "DELETE",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
                requestOptions?.headers,
            ),
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Schematic.DeleteBillingProductResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Schematic.BadRequestError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SchematicError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SchematicTimeoutError(
                    "Timeout exceeded when calling DELETE /billing/product/{billing_id}.",
                );
            case "unknown":
                throw new errors.SchematicError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Schematic.ListProductPricesRequest} request
     * @param {Billing.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.BadRequestError}
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.billing.listProductPrices()
     */
    public listProductPrices(
        request: Schematic.ListProductPricesRequest = {},
        requestOptions?: Billing.RequestOptions,
    ): core.HttpResponsePromise<Schematic.ListProductPricesResponse> {
        return core.HttpResponsePromise.fromPromise(this.__listProductPrices(request, requestOptions));
    }

    private async __listProductPrices(
        request: Schematic.ListProductPricesRequest = {},
        requestOptions?: Billing.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.ListProductPricesResponse>> {
        const {
            ids,
            name,
            q,
            price_usage_type: priceUsageType,
            without_linked_to_plan: withoutLinkedToPlan,
            with_one_time_charges: withOneTimeCharges,
            with_zero_price: withZeroPrice,
            with_prices_only: withPricesOnly,
            is_active: isActive,
            limit,
            offset,
        } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (ids != null) {
            if (Array.isArray(ids)) {
                _queryParams["ids"] = ids.map((item) => item);
            } else {
                _queryParams["ids"] = ids;
            }
        }

        if (name != null) {
            _queryParams["name"] = name;
        }

        if (q != null) {
            _queryParams["q"] = q;
        }

        if (priceUsageType != null) {
            _queryParams["price_usage_type"] = priceUsageType;
        }

        if (withoutLinkedToPlan != null) {
            _queryParams["without_linked_to_plan"] = withoutLinkedToPlan.toString();
        }

        if (withOneTimeCharges != null) {
            _queryParams["with_one_time_charges"] = withOneTimeCharges.toString();
        }

        if (withZeroPrice != null) {
            _queryParams["with_zero_price"] = withZeroPrice.toString();
        }

        if (withPricesOnly != null) {
            _queryParams["with_prices_only"] = withPricesOnly.toString();
        }

        if (isActive != null) {
            _queryParams["is_active"] = isActive.toString();
        }

        if (limit != null) {
            _queryParams["limit"] = limit.toString();
        }

        if (offset != null) {
            _queryParams["offset"] = offset.toString();
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                "billing/product/prices",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
                requestOptions?.headers,
            ),
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Schematic.ListProductPricesResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Schematic.BadRequestError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SchematicError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SchematicTimeoutError("Timeout exceeded when calling GET /billing/product/prices.");
            case "unknown":
                throw new errors.SchematicError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} billingId - billing_id
     * @param {Billing.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.BadRequestError}
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.billing.deleteProductPrice("billing_id")
     */
    public deleteProductPrice(
        billingId: string,
        requestOptions?: Billing.RequestOptions,
    ): core.HttpResponsePromise<Schematic.DeleteProductPriceResponse> {
        return core.HttpResponsePromise.fromPromise(this.__deleteProductPrice(billingId, requestOptions));
    }

    private async __deleteProductPrice(
        billingId: string,
        requestOptions?: Billing.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.DeleteProductPriceResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                `billing/product/prices/${encodeURIComponent(billingId)}`,
            ),
            method: "DELETE",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
                requestOptions?.headers,
            ),
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Schematic.DeleteProductPriceResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Schematic.BadRequestError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SchematicError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SchematicTimeoutError(
                    "Timeout exceeded when calling DELETE /billing/product/prices/{billing_id}.",
                );
            case "unknown":
                throw new errors.SchematicError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Schematic.CreateBillingProductRequestBody} request
     * @param {Billing.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.BadRequestError}
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.billing.upsertBillingProduct({
     *         external_id: "external_id",
     *         name: "name",
     *         price: 1.1
     *     })
     */
    public upsertBillingProduct(
        request: Schematic.CreateBillingProductRequestBody,
        requestOptions?: Billing.RequestOptions,
    ): core.HttpResponsePromise<Schematic.UpsertBillingProductResponse> {
        return core.HttpResponsePromise.fromPromise(this.__upsertBillingProduct(request, requestOptions));
    }

    private async __upsertBillingProduct(
        request: Schematic.CreateBillingProductRequestBody,
        requestOptions?: Billing.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.UpsertBillingProductResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                "billing/product/upsert",
            ),
            method: "POST",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Schematic.UpsertBillingProductResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Schematic.BadRequestError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SchematicError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SchematicTimeoutError("Timeout exceeded when calling POST /billing/product/upsert.");
            case "unknown":
                throw new errors.SchematicError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Schematic.ListBillingProductsRequest} request
     * @param {Billing.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.BadRequestError}
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.billing.listBillingProducts()
     */
    public listBillingProducts(
        request: Schematic.ListBillingProductsRequest = {},
        requestOptions?: Billing.RequestOptions,
    ): core.HttpResponsePromise<Schematic.ListBillingProductsResponse> {
        return core.HttpResponsePromise.fromPromise(this.__listBillingProducts(request, requestOptions));
    }

    private async __listBillingProducts(
        request: Schematic.ListBillingProductsRequest = {},
        requestOptions?: Billing.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.ListBillingProductsResponse>> {
        const {
            ids,
            name,
            q,
            price_usage_type: priceUsageType,
            without_linked_to_plan: withoutLinkedToPlan,
            with_one_time_charges: withOneTimeCharges,
            with_zero_price: withZeroPrice,
            with_prices_only: withPricesOnly,
            is_active: isActive,
            limit,
            offset,
        } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (ids != null) {
            if (Array.isArray(ids)) {
                _queryParams["ids"] = ids.map((item) => item);
            } else {
                _queryParams["ids"] = ids;
            }
        }

        if (name != null) {
            _queryParams["name"] = name;
        }

        if (q != null) {
            _queryParams["q"] = q;
        }

        if (priceUsageType != null) {
            _queryParams["price_usage_type"] = priceUsageType;
        }

        if (withoutLinkedToPlan != null) {
            _queryParams["without_linked_to_plan"] = withoutLinkedToPlan.toString();
        }

        if (withOneTimeCharges != null) {
            _queryParams["with_one_time_charges"] = withOneTimeCharges.toString();
        }

        if (withZeroPrice != null) {
            _queryParams["with_zero_price"] = withZeroPrice.toString();
        }

        if (withPricesOnly != null) {
            _queryParams["with_prices_only"] = withPricesOnly.toString();
        }

        if (isActive != null) {
            _queryParams["is_active"] = isActive.toString();
        }

        if (limit != null) {
            _queryParams["limit"] = limit.toString();
        }

        if (offset != null) {
            _queryParams["offset"] = offset.toString();
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                "billing/products",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
                requestOptions?.headers,
            ),
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Schematic.ListBillingProductsResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Schematic.BadRequestError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SchematicError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SchematicTimeoutError("Timeout exceeded when calling GET /billing/products.");
            case "unknown":
                throw new errors.SchematicError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Schematic.CountBillingProductsRequest} request
     * @param {Billing.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.BadRequestError}
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.billing.countBillingProducts()
     */
    public countBillingProducts(
        request: Schematic.CountBillingProductsRequest = {},
        requestOptions?: Billing.RequestOptions,
    ): core.HttpResponsePromise<Schematic.CountBillingProductsResponse> {
        return core.HttpResponsePromise.fromPromise(this.__countBillingProducts(request, requestOptions));
    }

    private async __countBillingProducts(
        request: Schematic.CountBillingProductsRequest = {},
        requestOptions?: Billing.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.CountBillingProductsResponse>> {
        const {
            ids,
            name,
            q,
            price_usage_type: priceUsageType,
            without_linked_to_plan: withoutLinkedToPlan,
            with_one_time_charges: withOneTimeCharges,
            with_zero_price: withZeroPrice,
            with_prices_only: withPricesOnly,
            is_active: isActive,
            limit,
            offset,
        } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (ids != null) {
            if (Array.isArray(ids)) {
                _queryParams["ids"] = ids.map((item) => item);
            } else {
                _queryParams["ids"] = ids;
            }
        }

        if (name != null) {
            _queryParams["name"] = name;
        }

        if (q != null) {
            _queryParams["q"] = q;
        }

        if (priceUsageType != null) {
            _queryParams["price_usage_type"] = priceUsageType;
        }

        if (withoutLinkedToPlan != null) {
            _queryParams["without_linked_to_plan"] = withoutLinkedToPlan.toString();
        }

        if (withOneTimeCharges != null) {
            _queryParams["with_one_time_charges"] = withOneTimeCharges.toString();
        }

        if (withZeroPrice != null) {
            _queryParams["with_zero_price"] = withZeroPrice.toString();
        }

        if (withPricesOnly != null) {
            _queryParams["with_prices_only"] = withPricesOnly.toString();
        }

        if (isActive != null) {
            _queryParams["is_active"] = isActive.toString();
        }

        if (limit != null) {
            _queryParams["limit"] = limit.toString();
        }

        if (offset != null) {
            _queryParams["offset"] = offset.toString();
        }

        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                "billing/products/count",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
                requestOptions?.headers,
            ),
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Schematic.CountBillingProductsResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Schematic.BadRequestError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SchematicError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SchematicTimeoutError("Timeout exceeded when calling GET /billing/products/count.");
            case "unknown":
                throw new errors.SchematicError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Schematic.CreateBillingSubscriptionsRequestBody} request
     * @param {Billing.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.BadRequestError}
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.billing.upsertBillingSubscription({
     *         cancel_at_period_end: true,
     *         currency: "currency",
     *         customer_external_id: "customer_external_id",
     *         discounts: [{
     *                 coupon_external_id: "coupon_external_id",
     *                 external_id: "external_id",
     *                 is_active: true,
     *                 started_at: "2024-01-15T09:30:00Z"
     *             }],
     *         expired_at: "2024-01-15T09:30:00Z",
     *         product_external_ids: [{
     *                 currency: "currency",
     *                 interval: "interval",
     *                 price: 1,
     *                 price_external_id: "price_external_id",
     *                 product_external_id: "product_external_id",
     *                 quantity: 1,
     *                 usage_type: "licensed"
     *             }],
     *         subscription_external_id: "subscription_external_id",
     *         total_price: 1
     *     })
     */
    public upsertBillingSubscription(
        request: Schematic.CreateBillingSubscriptionsRequestBody,
        requestOptions?: Billing.RequestOptions,
    ): core.HttpResponsePromise<Schematic.UpsertBillingSubscriptionResponse> {
        return core.HttpResponsePromise.fromPromise(this.__upsertBillingSubscription(request, requestOptions));
    }

    private async __upsertBillingSubscription(
        request: Schematic.CreateBillingSubscriptionsRequestBody,
        requestOptions?: Billing.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.UpsertBillingSubscriptionResponse>> {
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                "billing/subscription/upsert",
            ),
            method: "POST",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ ...(await this._getCustomAuthorizationHeaders()) }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Schematic.UpsertBillingSubscriptionResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Schematic.BadRequestError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.SchematicError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.SchematicTimeoutError(
                    "Timeout exceeded when calling POST /billing/subscription/upsert.",
                );
            case "unknown":
                throw new errors.SchematicError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getCustomAuthorizationHeaders() {
        const apiKeyValue = await core.Supplier.get(this._options.apiKey);
        return { "X-Schematic-Api-Key": apiKeyValue };
    }
}
