// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions, BaseRequestOptions } from "../../../../BaseClient.js";
import { type NormalizedClientOptionsWithAuth, normalizeClientOptionsWithAuth } from "../../../../BaseClient.js";
import { mergeHeaders } from "../../../../core/headers.js";
import * as core from "../../../../core/index.js";
import * as environments from "../../../../environments.js";
import { handleNonStatusCodeError } from "../../../../errors/handleNonStatusCodeError.js";
import * as errors from "../../../../errors/index.js";
import * as Schematic from "../../../index.js";

export declare namespace BillingClient {
    export type Options = BaseClientOptions;

    export interface RequestOptions extends BaseRequestOptions {}
}

export class BillingClient {
    protected readonly _options: NormalizedClientOptionsWithAuth<BillingClient.Options>;

    constructor(options: BillingClient.Options) {
        this._options = normalizeClientOptionsWithAuth(options);
    }

    /**
     * @param {Schematic.ListCouponsRequest} request
     * @param {BillingClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.BadRequestError}
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.billing.listCoupons({
     *         is_active: true,
     *         q: "q",
     *         limit: 1,
     *         offset: 1
     *     })
     */
    public listCoupons(
        request: Schematic.ListCouponsRequest = {},
        requestOptions?: BillingClient.RequestOptions,
    ): core.HttpResponsePromise<Schematic.ListCouponsResponse> {
        return core.HttpResponsePromise.fromPromise(this.__listCoupons(request, requestOptions));
    }

    private async __listCoupons(
        request: Schematic.ListCouponsRequest = {},
        requestOptions?: BillingClient.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.ListCouponsResponse>> {
        const { is_active: isActive, q, limit, offset } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (isActive != null) {
            _queryParams.is_active = isActive.toString();
        }

        if (q != null) {
            _queryParams.q = q;
        }

        if (limit != null) {
            _queryParams.limit = limit.toString();
        }

        if (offset != null) {
            _queryParams.offset = offset.toString();
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                "billing/coupons",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Schematic.ListCouponsResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Schematic.BadRequestError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/billing/coupons");
    }

    /**
     * @param {Schematic.CreateCouponRequestBody} request
     * @param {BillingClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.BadRequestError}
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.billing.upsertBillingCoupon({
     *         amount_off: 1,
     *         duration: "duration",
     *         duration_in_months: 1,
     *         external_id: "external_id",
     *         max_redemptions: 1,
     *         name: "name",
     *         percent_off: 1.1,
     *         times_redeemed: 1
     *     })
     */
    public upsertBillingCoupon(
        request: Schematic.CreateCouponRequestBody,
        requestOptions?: BillingClient.RequestOptions,
    ): core.HttpResponsePromise<Schematic.UpsertBillingCouponResponse> {
        return core.HttpResponsePromise.fromPromise(this.__upsertBillingCoupon(request, requestOptions));
    }

    private async __upsertBillingCoupon(
        request: Schematic.CreateCouponRequestBody,
        requestOptions?: BillingClient.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.UpsertBillingCouponResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                "billing/coupons",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: _response.body as Schematic.UpsertBillingCouponResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Schematic.BadRequestError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/billing/coupons");
    }

    /**
     * @param {Schematic.CreateBillingCustomerRequestBody} request
     * @param {BillingClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.BadRequestError}
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.billing.upsertBillingCustomer({
     *         email: "email",
     *         external_id: "external_id",
     *         failed_to_import: true,
     *         meta: {
     *             "key": "value"
     *         },
     *         name: "name"
     *     })
     */
    public upsertBillingCustomer(
        request: Schematic.CreateBillingCustomerRequestBody,
        requestOptions?: BillingClient.RequestOptions,
    ): core.HttpResponsePromise<Schematic.UpsertBillingCustomerResponse> {
        return core.HttpResponsePromise.fromPromise(this.__upsertBillingCustomer(request, requestOptions));
    }

    private async __upsertBillingCustomer(
        request: Schematic.CreateBillingCustomerRequestBody,
        requestOptions?: BillingClient.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.UpsertBillingCustomerResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                "billing/customer/upsert",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: _response.body as Schematic.UpsertBillingCustomerResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Schematic.BadRequestError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/billing/customer/upsert");
    }

    /**
     * @param {Schematic.ListCustomersWithSubscriptionsRequest} request
     * @param {BillingClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.BadRequestError}
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.billing.listCustomersWithSubscriptions({
     *         name: "name",
     *         failed_to_import: true,
     *         q: "q",
     *         limit: 1,
     *         offset: 1
     *     })
     */
    public listCustomersWithSubscriptions(
        request: Schematic.ListCustomersWithSubscriptionsRequest = {},
        requestOptions?: BillingClient.RequestOptions,
    ): core.HttpResponsePromise<Schematic.ListCustomersWithSubscriptionsResponse> {
        return core.HttpResponsePromise.fromPromise(this.__listCustomersWithSubscriptions(request, requestOptions));
    }

    private async __listCustomersWithSubscriptions(
        request: Schematic.ListCustomersWithSubscriptionsRequest = {},
        requestOptions?: BillingClient.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.ListCustomersWithSubscriptionsResponse>> {
        const { company_ids: companyIds, name, failed_to_import: failedToImport, q, limit, offset } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (companyIds != null) {
            if (Array.isArray(companyIds)) {
                _queryParams.company_ids = companyIds.map((item) => item);
            } else {
                _queryParams.company_ids = companyIds;
            }
        }

        if (name != null) {
            _queryParams.name = name;
        }

        if (failedToImport != null) {
            _queryParams.failed_to_import = failedToImport.toString();
        }

        if (q != null) {
            _queryParams.q = q;
        }

        if (limit != null) {
            _queryParams.limit = limit.toString();
        }

        if (offset != null) {
            _queryParams.offset = offset.toString();
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                "billing/customers",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: _response.body as Schematic.ListCustomersWithSubscriptionsResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Schematic.BadRequestError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/billing/customers");
    }

    /**
     * @param {Schematic.CountCustomersRequest} request
     * @param {BillingClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.BadRequestError}
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.billing.countCustomers({
     *         name: "name",
     *         failed_to_import: true,
     *         q: "q",
     *         limit: 1,
     *         offset: 1
     *     })
     */
    public countCustomers(
        request: Schematic.CountCustomersRequest = {},
        requestOptions?: BillingClient.RequestOptions,
    ): core.HttpResponsePromise<Schematic.CountCustomersResponse> {
        return core.HttpResponsePromise.fromPromise(this.__countCustomers(request, requestOptions));
    }

    private async __countCustomers(
        request: Schematic.CountCustomersRequest = {},
        requestOptions?: BillingClient.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.CountCustomersResponse>> {
        const { company_ids: companyIds, name, failed_to_import: failedToImport, q, limit, offset } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (companyIds != null) {
            if (Array.isArray(companyIds)) {
                _queryParams.company_ids = companyIds.map((item) => item);
            } else {
                _queryParams.company_ids = companyIds;
            }
        }

        if (name != null) {
            _queryParams.name = name;
        }

        if (failedToImport != null) {
            _queryParams.failed_to_import = failedToImport.toString();
        }

        if (q != null) {
            _queryParams.q = q;
        }

        if (limit != null) {
            _queryParams.limit = limit.toString();
        }

        if (offset != null) {
            _queryParams.offset = offset.toString();
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                "billing/customers/count",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Schematic.CountCustomersResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Schematic.BadRequestError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/billing/customers/count");
    }

    /**
     * @param {Schematic.ListInvoicesRequest} request
     * @param {BillingClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.BadRequestError}
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.billing.listInvoices({
     *         company_id: "company_id",
     *         customer_external_id: "customer_external_id",
     *         subscription_external_id: "subscription_external_id",
     *         limit: 1,
     *         offset: 1
     *     })
     */
    public listInvoices(
        request: Schematic.ListInvoicesRequest,
        requestOptions?: BillingClient.RequestOptions,
    ): core.HttpResponsePromise<Schematic.ListInvoicesResponse> {
        return core.HttpResponsePromise.fromPromise(this.__listInvoices(request, requestOptions));
    }

    private async __listInvoices(
        request: Schematic.ListInvoicesRequest,
        requestOptions?: BillingClient.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.ListInvoicesResponse>> {
        const {
            company_id: companyId,
            customer_external_id: customerExternalId,
            subscription_external_id: subscriptionExternalId,
            limit,
            offset,
        } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (companyId != null) {
            _queryParams.company_id = companyId;
        }

        _queryParams.customer_external_id = customerExternalId;
        _queryParams.subscription_external_id = subscriptionExternalId;
        if (limit != null) {
            _queryParams.limit = limit.toString();
        }

        if (offset != null) {
            _queryParams.offset = offset.toString();
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                "billing/invoices",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Schematic.ListInvoicesResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Schematic.BadRequestError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/billing/invoices");
    }

    /**
     * @param {Schematic.CreateInvoiceRequestBody} request
     * @param {BillingClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.BadRequestError}
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.billing.upsertInvoice({
     *         amount_due: 1,
     *         amount_paid: 1,
     *         amount_remaining: 1,
     *         collection_method: "collection_method",
     *         currency: "currency",
     *         customer_external_id: "customer_external_id",
     *         subtotal: 1
     *     })
     */
    public upsertInvoice(
        request: Schematic.CreateInvoiceRequestBody,
        requestOptions?: BillingClient.RequestOptions,
    ): core.HttpResponsePromise<Schematic.UpsertInvoiceResponse> {
        return core.HttpResponsePromise.fromPromise(this.__upsertInvoice(request, requestOptions));
    }

    private async __upsertInvoice(
        request: Schematic.CreateInvoiceRequestBody,
        requestOptions?: BillingClient.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.UpsertInvoiceResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                "billing/invoices",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Schematic.UpsertInvoiceResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Schematic.BadRequestError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/billing/invoices");
    }

    /**
     * @param {Schematic.ListMetersRequest} request
     * @param {BillingClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.BadRequestError}
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.billing.listMeters({
     *         display_name: "display_name",
     *         limit: 1,
     *         offset: 1
     *     })
     */
    public listMeters(
        request: Schematic.ListMetersRequest = {},
        requestOptions?: BillingClient.RequestOptions,
    ): core.HttpResponsePromise<Schematic.ListMetersResponse> {
        return core.HttpResponsePromise.fromPromise(this.__listMeters(request, requestOptions));
    }

    private async __listMeters(
        request: Schematic.ListMetersRequest = {},
        requestOptions?: BillingClient.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.ListMetersResponse>> {
        const { display_name: displayName, limit, offset } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (displayName != null) {
            _queryParams.display_name = displayName;
        }

        if (limit != null) {
            _queryParams.limit = limit.toString();
        }

        if (offset != null) {
            _queryParams.offset = offset.toString();
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                "billing/meter",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Schematic.ListMetersResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Schematic.BadRequestError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/billing/meter");
    }

    /**
     * @param {Schematic.CreateMeterRequestBody} request
     * @param {BillingClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.BadRequestError}
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.billing.upsertBillingMeter({
     *         display_name: "display_name",
     *         event_name: "event_name",
     *         event_payload_key: "event_payload_key",
     *         external_id: "external_id"
     *     })
     */
    public upsertBillingMeter(
        request: Schematic.CreateMeterRequestBody,
        requestOptions?: BillingClient.RequestOptions,
    ): core.HttpResponsePromise<Schematic.UpsertBillingMeterResponse> {
        return core.HttpResponsePromise.fromPromise(this.__upsertBillingMeter(request, requestOptions));
    }

    private async __upsertBillingMeter(
        request: Schematic.CreateMeterRequestBody,
        requestOptions?: BillingClient.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.UpsertBillingMeterResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                "billing/meter/upsert",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Schematic.UpsertBillingMeterResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Schematic.BadRequestError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/billing/meter/upsert");
    }

    /**
     * @param {Schematic.ListPaymentMethodsRequest} request
     * @param {BillingClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.BadRequestError}
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.billing.listPaymentMethods({
     *         company_id: "company_id",
     *         customer_external_id: "customer_external_id",
     *         limit: 1,
     *         offset: 1
     *     })
     */
    public listPaymentMethods(
        request: Schematic.ListPaymentMethodsRequest,
        requestOptions?: BillingClient.RequestOptions,
    ): core.HttpResponsePromise<Schematic.ListPaymentMethodsResponse> {
        return core.HttpResponsePromise.fromPromise(this.__listPaymentMethods(request, requestOptions));
    }

    private async __listPaymentMethods(
        request: Schematic.ListPaymentMethodsRequest,
        requestOptions?: BillingClient.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.ListPaymentMethodsResponse>> {
        const { company_id: companyId, customer_external_id: customerExternalId, limit, offset } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (companyId != null) {
            _queryParams.company_id = companyId;
        }

        _queryParams.customer_external_id = customerExternalId;
        if (limit != null) {
            _queryParams.limit = limit.toString();
        }

        if (offset != null) {
            _queryParams.offset = offset.toString();
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                "billing/payment-methods",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Schematic.ListPaymentMethodsResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Schematic.BadRequestError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/billing/payment-methods");
    }

    /**
     * @param {Schematic.CreatePaymentMethodRequestBody} request
     * @param {BillingClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.BadRequestError}
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.billing.upsertPaymentMethod({
     *         customer_external_id: "customer_external_id",
     *         external_id: "external_id",
     *         payment_method_type: "payment_method_type"
     *     })
     */
    public upsertPaymentMethod(
        request: Schematic.CreatePaymentMethodRequestBody,
        requestOptions?: BillingClient.RequestOptions,
    ): core.HttpResponsePromise<Schematic.UpsertPaymentMethodResponse> {
        return core.HttpResponsePromise.fromPromise(this.__upsertPaymentMethod(request, requestOptions));
    }

    private async __upsertPaymentMethod(
        request: Schematic.CreatePaymentMethodRequestBody,
        requestOptions?: BillingClient.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.UpsertPaymentMethodResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                "billing/payment-methods",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: _response.body as Schematic.UpsertPaymentMethodResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Schematic.BadRequestError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/billing/payment-methods");
    }

    /**
     * @param {Schematic.ListBillingPricesRequest} request
     * @param {BillingClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.BadRequestError}
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.billing.listBillingPrices({
     *         for_initial_plan: true,
     *         for_trial_expiry_plan: true,
     *         interval: "interval",
     *         is_active: true,
     *         price: 1,
     *         product_id: "product_id",
     *         q: "q",
     *         tiers_mode: "graduated",
     *         usage_type: "licensed",
     *         with_meter: true,
     *         limit: 1,
     *         offset: 1
     *     })
     */
    public listBillingPrices(
        request: Schematic.ListBillingPricesRequest = {},
        requestOptions?: BillingClient.RequestOptions,
    ): core.HttpResponsePromise<Schematic.ListBillingPricesResponse> {
        return core.HttpResponsePromise.fromPromise(this.__listBillingPrices(request, requestOptions));
    }

    private async __listBillingPrices(
        request: Schematic.ListBillingPricesRequest = {},
        requestOptions?: BillingClient.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.ListBillingPricesResponse>> {
        const {
            for_initial_plan: forInitialPlan,
            for_trial_expiry_plan: forTrialExpiryPlan,
            ids,
            interval,
            is_active: isActive,
            price,
            product_id: productId,
            product_ids: productIds,
            q,
            tiers_mode: tiersMode,
            usage_type: usageType,
            with_meter: withMeter,
            limit,
            offset,
        } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (forInitialPlan != null) {
            _queryParams.for_initial_plan = forInitialPlan.toString();
        }

        if (forTrialExpiryPlan != null) {
            _queryParams.for_trial_expiry_plan = forTrialExpiryPlan.toString();
        }

        if (ids != null) {
            if (Array.isArray(ids)) {
                _queryParams.ids = ids.map((item) => item);
            } else {
                _queryParams.ids = ids;
            }
        }

        if (interval != null) {
            _queryParams.interval = interval;
        }

        if (isActive != null) {
            _queryParams.is_active = isActive.toString();
        }

        if (price != null) {
            _queryParams.price = price.toString();
        }

        if (productId != null) {
            _queryParams.product_id = productId;
        }

        if (productIds != null) {
            if (Array.isArray(productIds)) {
                _queryParams.product_ids = productIds.map((item) => item);
            } else {
                _queryParams.product_ids = productIds;
            }
        }

        if (q != null) {
            _queryParams.q = q;
        }

        if (tiersMode != null) {
            _queryParams.tiers_mode = tiersMode;
        }

        if (usageType != null) {
            _queryParams.usage_type = usageType;
        }

        if (withMeter != null) {
            _queryParams.with_meter = withMeter.toString();
        }

        if (limit != null) {
            _queryParams.limit = limit.toString();
        }

        if (offset != null) {
            _queryParams.offset = offset.toString();
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                "billing/price",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Schematic.ListBillingPricesResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Schematic.BadRequestError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/billing/price");
    }

    /**
     * @param {Schematic.CreateBillingPriceRequestBody} request
     * @param {BillingClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.BadRequestError}
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.billing.upsertBillingPrice({
     *         billing_scheme: "per_unit",
     *         currency: "currency",
     *         external_account_id: "external_account_id",
     *         interval: "interval",
     *         is_active: true,
     *         price: 1,
     *         price_external_id: "price_external_id",
     *         price_tiers: [{
     *                 price_external_id: "price_external_id"
     *             }],
     *         product_external_id: "product_external_id",
     *         usage_type: "licensed"
     *     })
     */
    public upsertBillingPrice(
        request: Schematic.CreateBillingPriceRequestBody,
        requestOptions?: BillingClient.RequestOptions,
    ): core.HttpResponsePromise<Schematic.UpsertBillingPriceResponse> {
        return core.HttpResponsePromise.fromPromise(this.__upsertBillingPrice(request, requestOptions));
    }

    private async __upsertBillingPrice(
        request: Schematic.CreateBillingPriceRequestBody,
        requestOptions?: BillingClient.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.UpsertBillingPriceResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                "billing/price/upsert",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Schematic.UpsertBillingPriceResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Schematic.BadRequestError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/billing/price/upsert");
    }

    /**
     * @param {string} billing_id - billing_id
     * @param {BillingClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.BadRequestError}
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.billing.deleteBillingProduct("billing_id")
     */
    public deleteBillingProduct(
        billing_id: string,
        requestOptions?: BillingClient.RequestOptions,
    ): core.HttpResponsePromise<Schematic.DeleteBillingProductResponse> {
        return core.HttpResponsePromise.fromPromise(this.__deleteBillingProduct(billing_id, requestOptions));
    }

    private async __deleteBillingProduct(
        billing_id: string,
        requestOptions?: BillingClient.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.DeleteBillingProductResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                `billing/product/${core.url.encodePathParam(billing_id)}`,
            ),
            method: "DELETE",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: _response.body as Schematic.DeleteBillingProductResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Schematic.BadRequestError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "DELETE",
            "/billing/product/{billing_id}",
        );
    }

    /**
     * @param {Schematic.ListBillingProductPricesRequest} request
     * @param {BillingClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.BadRequestError}
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.billing.listBillingProductPrices({
     *         for_initial_plan: true,
     *         for_trial_expiry_plan: true,
     *         interval: "interval",
     *         is_active: true,
     *         price: 1,
     *         product_id: "product_id",
     *         q: "q",
     *         tiers_mode: "graduated",
     *         usage_type: "licensed",
     *         with_meter: true,
     *         limit: 1,
     *         offset: 1
     *     })
     */
    public listBillingProductPrices(
        request: Schematic.ListBillingProductPricesRequest = {},
        requestOptions?: BillingClient.RequestOptions,
    ): core.HttpResponsePromise<Schematic.ListBillingProductPricesResponse> {
        return core.HttpResponsePromise.fromPromise(this.__listBillingProductPrices(request, requestOptions));
    }

    private async __listBillingProductPrices(
        request: Schematic.ListBillingProductPricesRequest = {},
        requestOptions?: BillingClient.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.ListBillingProductPricesResponse>> {
        const {
            for_initial_plan: forInitialPlan,
            for_trial_expiry_plan: forTrialExpiryPlan,
            ids,
            interval,
            is_active: isActive,
            price,
            product_id: productId,
            product_ids: productIds,
            q,
            tiers_mode: tiersMode,
            usage_type: usageType,
            with_meter: withMeter,
            limit,
            offset,
        } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (forInitialPlan != null) {
            _queryParams.for_initial_plan = forInitialPlan.toString();
        }

        if (forTrialExpiryPlan != null) {
            _queryParams.for_trial_expiry_plan = forTrialExpiryPlan.toString();
        }

        if (ids != null) {
            if (Array.isArray(ids)) {
                _queryParams.ids = ids.map((item) => item);
            } else {
                _queryParams.ids = ids;
            }
        }

        if (interval != null) {
            _queryParams.interval = interval;
        }

        if (isActive != null) {
            _queryParams.is_active = isActive.toString();
        }

        if (price != null) {
            _queryParams.price = price.toString();
        }

        if (productId != null) {
            _queryParams.product_id = productId;
        }

        if (productIds != null) {
            if (Array.isArray(productIds)) {
                _queryParams.product_ids = productIds.map((item) => item);
            } else {
                _queryParams.product_ids = productIds;
            }
        }

        if (q != null) {
            _queryParams.q = q;
        }

        if (tiersMode != null) {
            _queryParams.tiers_mode = tiersMode;
        }

        if (usageType != null) {
            _queryParams.usage_type = usageType;
        }

        if (withMeter != null) {
            _queryParams.with_meter = withMeter.toString();
        }

        if (limit != null) {
            _queryParams.limit = limit.toString();
        }

        if (offset != null) {
            _queryParams.offset = offset.toString();
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                "billing/product/prices",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: _response.body as Schematic.ListBillingProductPricesResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Schematic.BadRequestError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/billing/product/prices");
    }

    /**
     * @param {string} billing_id - billing_id
     * @param {BillingClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.BadRequestError}
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.billing.deleteProductPrice("billing_id")
     */
    public deleteProductPrice(
        billing_id: string,
        requestOptions?: BillingClient.RequestOptions,
    ): core.HttpResponsePromise<Schematic.DeleteProductPriceResponse> {
        return core.HttpResponsePromise.fromPromise(this.__deleteProductPrice(billing_id, requestOptions));
    }

    private async __deleteProductPrice(
        billing_id: string,
        requestOptions?: BillingClient.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.DeleteProductPriceResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                `billing/product/prices/${core.url.encodePathParam(billing_id)}`,
            ),
            method: "DELETE",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return { data: _response.body as Schematic.DeleteProductPriceResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Schematic.BadRequestError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(
            _response.error,
            _response.rawResponse,
            "DELETE",
            "/billing/product/prices/{billing_id}",
        );
    }

    /**
     * @param {Schematic.CreateBillingProductRequestBody} request
     * @param {BillingClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.BadRequestError}
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.billing.upsertBillingProduct({
     *         external_id: "external_id",
     *         name: "name",
     *         price: 1.1
     *     })
     */
    public upsertBillingProduct(
        request: Schematic.CreateBillingProductRequestBody,
        requestOptions?: BillingClient.RequestOptions,
    ): core.HttpResponsePromise<Schematic.UpsertBillingProductResponse> {
        return core.HttpResponsePromise.fromPromise(this.__upsertBillingProduct(request, requestOptions));
    }

    private async __upsertBillingProduct(
        request: Schematic.CreateBillingProductRequestBody,
        requestOptions?: BillingClient.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.UpsertBillingProductResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                "billing/product/upsert",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: _response.body as Schematic.UpsertBillingProductResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Schematic.BadRequestError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/billing/product/upsert");
    }

    /**
     * @param {Schematic.ListBillingProductsRequest} request
     * @param {BillingClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.BadRequestError}
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.billing.listBillingProducts({
     *         name: "name",
     *         q: "q",
     *         price_usage_type: "licensed",
     *         without_linked_to_plan: true,
     *         with_one_time_charges: true,
     *         with_zero_price: true,
     *         with_prices_only: true,
     *         is_active: true,
     *         limit: 1,
     *         offset: 1
     *     })
     */
    public listBillingProducts(
        request: Schematic.ListBillingProductsRequest = {},
        requestOptions?: BillingClient.RequestOptions,
    ): core.HttpResponsePromise<Schematic.ListBillingProductsResponse> {
        return core.HttpResponsePromise.fromPromise(this.__listBillingProducts(request, requestOptions));
    }

    private async __listBillingProducts(
        request: Schematic.ListBillingProductsRequest = {},
        requestOptions?: BillingClient.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.ListBillingProductsResponse>> {
        const {
            ids,
            name,
            q,
            price_usage_type: priceUsageType,
            without_linked_to_plan: withoutLinkedToPlan,
            with_one_time_charges: withOneTimeCharges,
            with_zero_price: withZeroPrice,
            with_prices_only: withPricesOnly,
            is_active: isActive,
            limit,
            offset,
        } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (ids != null) {
            if (Array.isArray(ids)) {
                _queryParams.ids = ids.map((item) => item);
            } else {
                _queryParams.ids = ids;
            }
        }

        if (name != null) {
            _queryParams.name = name;
        }

        if (q != null) {
            _queryParams.q = q;
        }

        if (priceUsageType != null) {
            _queryParams.price_usage_type = priceUsageType;
        }

        if (withoutLinkedToPlan != null) {
            _queryParams.without_linked_to_plan = withoutLinkedToPlan.toString();
        }

        if (withOneTimeCharges != null) {
            _queryParams.with_one_time_charges = withOneTimeCharges.toString();
        }

        if (withZeroPrice != null) {
            _queryParams.with_zero_price = withZeroPrice.toString();
        }

        if (withPricesOnly != null) {
            _queryParams.with_prices_only = withPricesOnly.toString();
        }

        if (isActive != null) {
            _queryParams.is_active = isActive.toString();
        }

        if (limit != null) {
            _queryParams.limit = limit.toString();
        }

        if (offset != null) {
            _queryParams.offset = offset.toString();
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                "billing/products",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: _response.body as Schematic.ListBillingProductsResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Schematic.BadRequestError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/billing/products");
    }

    /**
     * @param {Schematic.CountBillingProductsRequest} request
     * @param {BillingClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.BadRequestError}
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.billing.countBillingProducts({
     *         name: "name",
     *         q: "q",
     *         price_usage_type: "licensed",
     *         without_linked_to_plan: true,
     *         with_one_time_charges: true,
     *         with_zero_price: true,
     *         with_prices_only: true,
     *         is_active: true,
     *         limit: 1,
     *         offset: 1
     *     })
     */
    public countBillingProducts(
        request: Schematic.CountBillingProductsRequest = {},
        requestOptions?: BillingClient.RequestOptions,
    ): core.HttpResponsePromise<Schematic.CountBillingProductsResponse> {
        return core.HttpResponsePromise.fromPromise(this.__countBillingProducts(request, requestOptions));
    }

    private async __countBillingProducts(
        request: Schematic.CountBillingProductsRequest = {},
        requestOptions?: BillingClient.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.CountBillingProductsResponse>> {
        const {
            ids,
            name,
            q,
            price_usage_type: priceUsageType,
            without_linked_to_plan: withoutLinkedToPlan,
            with_one_time_charges: withOneTimeCharges,
            with_zero_price: withZeroPrice,
            with_prices_only: withPricesOnly,
            is_active: isActive,
            limit,
            offset,
        } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (ids != null) {
            if (Array.isArray(ids)) {
                _queryParams.ids = ids.map((item) => item);
            } else {
                _queryParams.ids = ids;
            }
        }

        if (name != null) {
            _queryParams.name = name;
        }

        if (q != null) {
            _queryParams.q = q;
        }

        if (priceUsageType != null) {
            _queryParams.price_usage_type = priceUsageType;
        }

        if (withoutLinkedToPlan != null) {
            _queryParams.without_linked_to_plan = withoutLinkedToPlan.toString();
        }

        if (withOneTimeCharges != null) {
            _queryParams.with_one_time_charges = withOneTimeCharges.toString();
        }

        if (withZeroPrice != null) {
            _queryParams.with_zero_price = withZeroPrice.toString();
        }

        if (withPricesOnly != null) {
            _queryParams.with_prices_only = withPricesOnly.toString();
        }

        if (isActive != null) {
            _queryParams.is_active = isActive.toString();
        }

        if (limit != null) {
            _queryParams.limit = limit.toString();
        }

        if (offset != null) {
            _queryParams.offset = offset.toString();
        }

        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                "billing/products/count",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: _response.body as Schematic.CountBillingProductsResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Schematic.BadRequestError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "GET", "/billing/products/count");
    }

    /**
     * @param {Schematic.CreateBillingSubscriptionRequestBody} request
     * @param {BillingClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Schematic.BadRequestError}
     * @throws {@link Schematic.UnauthorizedError}
     * @throws {@link Schematic.ForbiddenError}
     * @throws {@link Schematic.NotFoundError}
     * @throws {@link Schematic.InternalServerError}
     *
     * @example
     *     await client.billing.upsertBillingSubscription({
     *         cancel_at_period_end: true,
     *         currency: "currency",
     *         customer_external_id: "customer_external_id",
     *         discounts: [{
     *                 coupon_external_id: "coupon_external_id",
     *                 external_id: "external_id",
     *                 is_active: true,
     *                 started_at: "2024-01-15T09:30:00Z"
     *             }],
     *         expired_at: "2024-01-15T09:30:00Z",
     *         product_external_ids: [{
     *                 currency: "currency",
     *                 interval: "interval",
     *                 price: 1,
     *                 price_external_id: "price_external_id",
     *                 product_external_id: "product_external_id",
     *                 quantity: 1,
     *                 usage_type: "licensed"
     *             }],
     *         subscription_external_id: "subscription_external_id",
     *         total_price: 1
     *     })
     */
    public upsertBillingSubscription(
        request: Schematic.CreateBillingSubscriptionRequestBody,
        requestOptions?: BillingClient.RequestOptions,
    ): core.HttpResponsePromise<Schematic.UpsertBillingSubscriptionResponse> {
        return core.HttpResponsePromise.fromPromise(this.__upsertBillingSubscription(request, requestOptions));
    }

    private async __upsertBillingSubscription(
        request: Schematic.CreateBillingSubscriptionRequestBody,
        requestOptions?: BillingClient.RequestOptions,
    ): Promise<core.WithRawResponse<Schematic.UpsertBillingSubscriptionResponse>> {
        const _authRequest: core.AuthRequest = await this._options.authProvider.getAuthRequest();
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            _authRequest.headers,
            this._options?.headers,
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.SchematicEnvironment.Default,
                "billing/subscription/upsert",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
            fetchFn: this._options?.fetch,
            logging: this._options.logging,
        });
        if (_response.ok) {
            return {
                data: _response.body as Schematic.UpsertBillingSubscriptionResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Schematic.BadRequestError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 401:
                    throw new Schematic.UnauthorizedError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 403:
                    throw new Schematic.ForbiddenError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 404:
                    throw new Schematic.NotFoundError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                case 500:
                    throw new Schematic.InternalServerError(
                        _response.error.body as Schematic.ApiError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.SchematicError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        return handleNonStatusCodeError(_response.error, _response.rawResponse, "POST", "/billing/subscription/upsert");
    }
}
