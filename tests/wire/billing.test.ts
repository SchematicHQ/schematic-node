// This file was auto-generated by Fern from our API Definition.

import * as Schematic from "../../src/api/index";
import { SchematicClient } from "../../src/Client";
import { mockServerPool } from "../mock-server/MockServerPool";

describe("Billing", () => {
    test("listCoupons (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            data: [
                {
                    account_id: "account_id",
                    amount_off: 1,
                    currency: "currency",
                    duration: "duration",
                    duration_in_months: 1,
                    environment_id: "environment_id",
                    external_id: "external_id",
                    id: "id",
                    is_active: true,
                    max_redemptions: 1,
                    metadata: { key: "value" },
                    name: "name",
                    percent_off: 1.1,
                    times_redeemed: 1,
                    valid_from: "2024-01-15T09:30:00Z",
                    valid_until: "2024-01-15T09:30:00Z",
                },
            ],
            params: { is_active: true, limit: 1, offset: 1, q: "q" },
        };
        server.mockEndpoint().get("/billing/coupons").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.billing.listCoupons({
            is_active: true,
            q: "q",
            limit: 1,
            offset: 1,
        });
        expect(response).toEqual({
            data: [
                {
                    account_id: "account_id",
                    amount_off: 1,
                    currency: "currency",
                    duration: "duration",
                    duration_in_months: 1,
                    environment_id: "environment_id",
                    external_id: "external_id",
                    id: "id",
                    is_active: true,
                    max_redemptions: 1,
                    metadata: {
                        key: "value",
                    },
                    name: "name",
                    percent_off: 1.1,
                    times_redeemed: 1,
                    valid_from: "2024-01-15T09:30:00Z",
                    valid_until: "2024-01-15T09:30:00Z",
                },
            ],
            params: {
                is_active: true,
                limit: 1,
                offset: 1,
                q: "q",
            },
        });
    });

    test("listCoupons (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/coupons").respondWith().statusCode(400).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.listCoupons();
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("listCoupons (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/coupons").respondWith().statusCode(401).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.listCoupons();
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("listCoupons (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/coupons").respondWith().statusCode(403).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.listCoupons();
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("listCoupons (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/coupons").respondWith().statusCode(404).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.listCoupons();
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("listCoupons (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/coupons").respondWith().statusCode(500).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.listCoupons();
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("upsertBillingCoupon (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            amount_off: 1,
            duration: "duration",
            duration_in_months: 1,
            external_id: "external_id",
            max_redemptions: 1,
            name: "name",
            percent_off: 1.1,
            times_redeemed: 1,
        };
        const rawResponseBody = {
            data: {
                account_id: "account_id",
                amount_off: 1,
                currency: "currency",
                duration: "duration",
                duration_in_months: 1,
                environment_id: "environment_id",
                external_id: "external_id",
                id: "id",
                is_active: true,
                max_redemptions: 1,
                metadata: { key: "value" },
                name: "name",
                percent_off: 1.1,
                times_redeemed: 1,
                valid_from: "2024-01-15T09:30:00Z",
                valid_until: "2024-01-15T09:30:00Z",
            },
            params: { key: "value" },
        };
        server
            .mockEndpoint()
            .post("/billing/coupons")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.billing.upsertBillingCoupon({
            amount_off: 1,
            duration: "duration",
            duration_in_months: 1,
            external_id: "external_id",
            max_redemptions: 1,
            name: "name",
            percent_off: 1.1,
            times_redeemed: 1,
        });
        expect(response).toEqual({
            data: {
                account_id: "account_id",
                amount_off: 1,
                currency: "currency",
                duration: "duration",
                duration_in_months: 1,
                environment_id: "environment_id",
                external_id: "external_id",
                id: "id",
                is_active: true,
                max_redemptions: 1,
                metadata: {
                    key: "value",
                },
                name: "name",
                percent_off: 1.1,
                times_redeemed: 1,
                valid_from: "2024-01-15T09:30:00Z",
                valid_until: "2024-01-15T09:30:00Z",
            },
            params: {
                key: "value",
            },
        });
    });

    test("upsertBillingCoupon (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            amount_off: 1,
            duration: "duration",
            duration_in_months: 1,
            external_id: "external_id",
            max_redemptions: 1,
            name: "name",
            percent_off: 1.1,
            times_redeemed: 1,
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/coupons")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingCoupon({
                amount_off: 1,
                duration: "duration",
                duration_in_months: 1,
                external_id: "external_id",
                max_redemptions: 1,
                name: "name",
                percent_off: 1.1,
                times_redeemed: 1,
            });
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("upsertBillingCoupon (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            amount_off: 1,
            duration: "duration",
            duration_in_months: 1,
            external_id: "external_id",
            max_redemptions: 1,
            name: "name",
            percent_off: 1.1,
            times_redeemed: 1,
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/coupons")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingCoupon({
                amount_off: 1,
                duration: "duration",
                duration_in_months: 1,
                external_id: "external_id",
                max_redemptions: 1,
                name: "name",
                percent_off: 1.1,
                times_redeemed: 1,
            });
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("upsertBillingCoupon (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            amount_off: 1,
            duration: "duration",
            duration_in_months: 1,
            external_id: "external_id",
            max_redemptions: 1,
            name: "name",
            percent_off: 1.1,
            times_redeemed: 1,
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/coupons")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingCoupon({
                amount_off: 1,
                duration: "duration",
                duration_in_months: 1,
                external_id: "external_id",
                max_redemptions: 1,
                name: "name",
                percent_off: 1.1,
                times_redeemed: 1,
            });
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("upsertBillingCoupon (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            amount_off: 1,
            duration: "duration",
            duration_in_months: 1,
            external_id: "external_id",
            max_redemptions: 1,
            name: "name",
            percent_off: 1.1,
            times_redeemed: 1,
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/coupons")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingCoupon({
                amount_off: 1,
                duration: "duration",
                duration_in_months: 1,
                external_id: "external_id",
                max_redemptions: 1,
                name: "name",
                percent_off: 1.1,
                times_redeemed: 1,
            });
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("upsertBillingCoupon (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            amount_off: 1,
            duration: "duration",
            duration_in_months: 1,
            external_id: "external_id",
            max_redemptions: 1,
            name: "name",
            percent_off: 1.1,
            times_redeemed: 1,
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/coupons")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingCoupon({
                amount_off: 1,
                duration: "duration",
                duration_in_months: 1,
                external_id: "external_id",
                max_redemptions: 1,
                name: "name",
                percent_off: 1.1,
                times_redeemed: 1,
            });
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("upsertBillingCustomer (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            email: "email",
            external_id: "external_id",
            failed_to_import: true,
            meta: { key: "value" },
            name: "name",
        };
        const rawResponseBody = {
            data: {
                company_id: "company_id",
                deleted_at: "2024-01-15T09:30:00Z",
                email: "email",
                external_id: "external_id",
                failed_to_import: true,
                id: "id",
                name: "name",
                updated_at: "2024-01-15T09:30:00Z",
            },
            params: { key: "value" },
        };
        server
            .mockEndpoint()
            .post("/billing/customer/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.billing.upsertBillingCustomer({
            email: "email",
            external_id: "external_id",
            failed_to_import: true,
            meta: {
                key: "value",
            },
            name: "name",
        });
        expect(response).toEqual({
            data: {
                company_id: "company_id",
                deleted_at: "2024-01-15T09:30:00Z",
                email: "email",
                external_id: "external_id",
                failed_to_import: true,
                id: "id",
                name: "name",
                updated_at: "2024-01-15T09:30:00Z",
            },
            params: {
                key: "value",
            },
        });
    });

    test("upsertBillingCustomer (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            email: "email",
            external_id: "external_id",
            failed_to_import: true,
            meta: { meta: "meta" },
            name: "name",
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/customer/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingCustomer({
                email: "email",
                external_id: "external_id",
                failed_to_import: true,
                meta: {
                    meta: "meta",
                },
                name: "name",
            });
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("upsertBillingCustomer (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            email: "email",
            external_id: "external_id",
            failed_to_import: true,
            meta: { meta: "meta" },
            name: "name",
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/customer/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingCustomer({
                email: "email",
                external_id: "external_id",
                failed_to_import: true,
                meta: {
                    meta: "meta",
                },
                name: "name",
            });
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("upsertBillingCustomer (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            email: "email",
            external_id: "external_id",
            failed_to_import: true,
            meta: { meta: "meta" },
            name: "name",
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/customer/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingCustomer({
                email: "email",
                external_id: "external_id",
                failed_to_import: true,
                meta: {
                    meta: "meta",
                },
                name: "name",
            });
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("upsertBillingCustomer (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            email: "email",
            external_id: "external_id",
            failed_to_import: true,
            meta: { meta: "meta" },
            name: "name",
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/customer/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingCustomer({
                email: "email",
                external_id: "external_id",
                failed_to_import: true,
                meta: {
                    meta: "meta",
                },
                name: "name",
            });
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("upsertBillingCustomer (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            email: "email",
            external_id: "external_id",
            failed_to_import: true,
            meta: { meta: "meta" },
            name: "name",
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/customer/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingCustomer({
                email: "email",
                external_id: "external_id",
                failed_to_import: true,
                meta: {
                    meta: "meta",
                },
                name: "name",
            });
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("listCustomersWithSubscriptions (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            data: [
                {
                    company_id: "company_id",
                    deleted_at: "2024-01-15T09:30:00Z",
                    email: "email",
                    external_id: "external_id",
                    failed_to_import: true,
                    id: "id",
                    name: "name",
                    subscriptions: [
                        {
                            currency: "currency",
                            interval: "interval",
                            metered_usage: true,
                            per_unit_price: 1,
                            total_price: 1,
                        },
                    ],
                    updated_at: "2024-01-15T09:30:00Z",
                },
            ],
            params: { company_ids: ["company_ids"], failed_to_import: true, limit: 1, name: "name", offset: 1, q: "q" },
        };
        server.mockEndpoint().get("/billing/customers").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.billing.listCustomersWithSubscriptions({
            name: "name",
            failed_to_import: true,
            q: "q",
            limit: 1,
            offset: 1,
        });
        expect(response).toEqual({
            data: [
                {
                    company_id: "company_id",
                    deleted_at: "2024-01-15T09:30:00Z",
                    email: "email",
                    external_id: "external_id",
                    failed_to_import: true,
                    id: "id",
                    name: "name",
                    subscriptions: [
                        {
                            currency: "currency",
                            interval: "interval",
                            metered_usage: true,
                            per_unit_price: 1,
                            total_price: 1,
                        },
                    ],
                    updated_at: "2024-01-15T09:30:00Z",
                },
            ],
            params: {
                company_ids: ["company_ids"],
                failed_to_import: true,
                limit: 1,
                name: "name",
                offset: 1,
                q: "q",
            },
        });
    });

    test("listCustomersWithSubscriptions (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/customers").respondWith().statusCode(400).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.listCustomersWithSubscriptions();
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("listCustomersWithSubscriptions (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/customers").respondWith().statusCode(401).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.listCustomersWithSubscriptions();
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("listCustomersWithSubscriptions (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/customers").respondWith().statusCode(403).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.listCustomersWithSubscriptions();
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("listCustomersWithSubscriptions (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/customers").respondWith().statusCode(404).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.listCustomersWithSubscriptions();
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("listCustomersWithSubscriptions (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/customers").respondWith().statusCode(500).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.listCustomersWithSubscriptions();
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("countCustomers (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            data: { count: 1 },
            params: { company_ids: ["company_ids"], failed_to_import: true, limit: 1, name: "name", offset: 1, q: "q" },
        };
        server
            .mockEndpoint()
            .get("/billing/customers/count")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.billing.countCustomers({
            name: "name",
            failed_to_import: true,
            q: "q",
            limit: 1,
            offset: 1,
        });
        expect(response).toEqual({
            data: {
                count: 1,
            },
            params: {
                company_ids: ["company_ids"],
                failed_to_import: true,
                limit: 1,
                name: "name",
                offset: 1,
                q: "q",
            },
        });
    });

    test("countCustomers (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/customers/count")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.countCustomers();
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("countCustomers (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/customers/count")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.countCustomers();
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("countCustomers (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/customers/count")
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.countCustomers();
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("countCustomers (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/customers/count")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.countCustomers();
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("countCustomers (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/customers/count")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.countCustomers();
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("listInvoices (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            data: [
                {
                    amount_due: 1,
                    amount_paid: 1,
                    amount_remaining: 1,
                    collection_method: "collection_method",
                    company_id: "company_id",
                    created_at: "2024-01-15T09:30:00Z",
                    currency: "currency",
                    customer_external_id: "customer_external_id",
                    due_date: "2024-01-15T09:30:00Z",
                    environment_id: "environment_id",
                    external_id: "external_id",
                    id: "id",
                    payment_method_external_id: "payment_method_external_id",
                    subscription_external_id: "subscription_external_id",
                    subtotal: 1,
                    updated_at: "2024-01-15T09:30:00Z",
                    url: "url",
                },
            ],
            params: {
                company_id: "company_id",
                customer_external_id: "customer_external_id",
                limit: 1,
                offset: 1,
                subscription_external_id: "subscription_external_id",
            },
        };
        server.mockEndpoint().get("/billing/invoices").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.billing.listInvoices({
            company_id: "company_id",
            customer_external_id: "customer_external_id",
            subscription_external_id: "subscription_external_id",
            limit: 1,
            offset: 1,
        });
        expect(response).toEqual({
            data: [
                {
                    amount_due: 1,
                    amount_paid: 1,
                    amount_remaining: 1,
                    collection_method: "collection_method",
                    company_id: "company_id",
                    created_at: "2024-01-15T09:30:00Z",
                    currency: "currency",
                    customer_external_id: "customer_external_id",
                    due_date: "2024-01-15T09:30:00Z",
                    environment_id: "environment_id",
                    external_id: "external_id",
                    id: "id",
                    payment_method_external_id: "payment_method_external_id",
                    subscription_external_id: "subscription_external_id",
                    subtotal: 1,
                    updated_at: "2024-01-15T09:30:00Z",
                    url: "url",
                },
            ],
            params: {
                company_id: "company_id",
                customer_external_id: "customer_external_id",
                limit: 1,
                offset: 1,
                subscription_external_id: "subscription_external_id",
            },
        });
    });

    test("listInvoices (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/invoices").respondWith().statusCode(400).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.listInvoices({
                customer_external_id: "customer_external_id",
                subscription_external_id: "subscription_external_id",
            });
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("listInvoices (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/invoices").respondWith().statusCode(401).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.listInvoices({
                customer_external_id: "customer_external_id",
                subscription_external_id: "subscription_external_id",
            });
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("listInvoices (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/invoices").respondWith().statusCode(403).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.listInvoices({
                customer_external_id: "customer_external_id",
                subscription_external_id: "subscription_external_id",
            });
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("listInvoices (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/invoices").respondWith().statusCode(404).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.listInvoices({
                customer_external_id: "customer_external_id",
                subscription_external_id: "subscription_external_id",
            });
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("listInvoices (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/invoices").respondWith().statusCode(500).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.listInvoices({
                customer_external_id: "customer_external_id",
                subscription_external_id: "subscription_external_id",
            });
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("upsertInvoice (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            amount_due: 1,
            amount_paid: 1,
            amount_remaining: 1,
            collection_method: "collection_method",
            currency: "currency",
            customer_external_id: "customer_external_id",
            subtotal: 1,
        };
        const rawResponseBody = {
            data: {
                amount_due: 1,
                amount_paid: 1,
                amount_remaining: 1,
                collection_method: "collection_method",
                company_id: "company_id",
                created_at: "2024-01-15T09:30:00Z",
                currency: "currency",
                customer_external_id: "customer_external_id",
                due_date: "2024-01-15T09:30:00Z",
                environment_id: "environment_id",
                external_id: "external_id",
                id: "id",
                payment_method_external_id: "payment_method_external_id",
                subscription_external_id: "subscription_external_id",
                subtotal: 1,
                updated_at: "2024-01-15T09:30:00Z",
                url: "url",
            },
            params: { key: "value" },
        };
        server
            .mockEndpoint()
            .post("/billing/invoices")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.billing.upsertInvoice({
            amount_due: 1,
            amount_paid: 1,
            amount_remaining: 1,
            collection_method: "collection_method",
            currency: "currency",
            customer_external_id: "customer_external_id",
            subtotal: 1,
        });
        expect(response).toEqual({
            data: {
                amount_due: 1,
                amount_paid: 1,
                amount_remaining: 1,
                collection_method: "collection_method",
                company_id: "company_id",
                created_at: "2024-01-15T09:30:00Z",
                currency: "currency",
                customer_external_id: "customer_external_id",
                due_date: "2024-01-15T09:30:00Z",
                environment_id: "environment_id",
                external_id: "external_id",
                id: "id",
                payment_method_external_id: "payment_method_external_id",
                subscription_external_id: "subscription_external_id",
                subtotal: 1,
                updated_at: "2024-01-15T09:30:00Z",
                url: "url",
            },
            params: {
                key: "value",
            },
        });
    });

    test("upsertInvoice (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            amount_due: 1,
            amount_paid: 1,
            amount_remaining: 1,
            collection_method: "collection_method",
            currency: "currency",
            customer_external_id: "customer_external_id",
            subtotal: 1,
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/invoices")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertInvoice({
                amount_due: 1,
                amount_paid: 1,
                amount_remaining: 1,
                collection_method: "collection_method",
                currency: "currency",
                customer_external_id: "customer_external_id",
                subtotal: 1,
            });
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("upsertInvoice (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            amount_due: 1,
            amount_paid: 1,
            amount_remaining: 1,
            collection_method: "collection_method",
            currency: "currency",
            customer_external_id: "customer_external_id",
            subtotal: 1,
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/invoices")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertInvoice({
                amount_due: 1,
                amount_paid: 1,
                amount_remaining: 1,
                collection_method: "collection_method",
                currency: "currency",
                customer_external_id: "customer_external_id",
                subtotal: 1,
            });
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("upsertInvoice (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            amount_due: 1,
            amount_paid: 1,
            amount_remaining: 1,
            collection_method: "collection_method",
            currency: "currency",
            customer_external_id: "customer_external_id",
            subtotal: 1,
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/invoices")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertInvoice({
                amount_due: 1,
                amount_paid: 1,
                amount_remaining: 1,
                collection_method: "collection_method",
                currency: "currency",
                customer_external_id: "customer_external_id",
                subtotal: 1,
            });
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("upsertInvoice (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            amount_due: 1,
            amount_paid: 1,
            amount_remaining: 1,
            collection_method: "collection_method",
            currency: "currency",
            customer_external_id: "customer_external_id",
            subtotal: 1,
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/invoices")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertInvoice({
                amount_due: 1,
                amount_paid: 1,
                amount_remaining: 1,
                collection_method: "collection_method",
                currency: "currency",
                customer_external_id: "customer_external_id",
                subtotal: 1,
            });
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("upsertInvoice (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            amount_due: 1,
            amount_paid: 1,
            amount_remaining: 1,
            collection_method: "collection_method",
            currency: "currency",
            customer_external_id: "customer_external_id",
            subtotal: 1,
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/invoices")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertInvoice({
                amount_due: 1,
                amount_paid: 1,
                amount_remaining: 1,
                collection_method: "collection_method",
                currency: "currency",
                customer_external_id: "customer_external_id",
                subtotal: 1,
            });
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("listMeters (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            data: [
                {
                    dispaly_name: "dispaly_name",
                    event_name: "event_name",
                    event_payload_key: "event_payload_key",
                    external_price_id: "external_price_id",
                    id: "id",
                },
            ],
            params: { display_name: "display_name", limit: 1, offset: 1 },
        };
        server.mockEndpoint().get("/billing/meter").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.billing.listMeters({
            display_name: "display_name",
            limit: 1,
            offset: 1,
        });
        expect(response).toEqual({
            data: [
                {
                    dispaly_name: "dispaly_name",
                    event_name: "event_name",
                    event_payload_key: "event_payload_key",
                    external_price_id: "external_price_id",
                    id: "id",
                },
            ],
            params: {
                display_name: "display_name",
                limit: 1,
                offset: 1,
            },
        });
    });

    test("listMeters (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/meter").respondWith().statusCode(400).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.listMeters();
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("listMeters (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/meter").respondWith().statusCode(401).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.listMeters();
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("listMeters (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/meter").respondWith().statusCode(403).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.listMeters();
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("listMeters (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/meter").respondWith().statusCode(404).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.listMeters();
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("listMeters (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/meter").respondWith().statusCode(500).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.listMeters();
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("upsertBillingMeter (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            display_name: "display_name",
            event_name: "event_name",
            event_payload_key: "event_payload_key",
            external_id: "external_id",
        };
        const rawResponseBody = {
            data: {
                dispaly_name: "dispaly_name",
                event_name: "event_name",
                event_payload_key: "event_payload_key",
                external_price_id: "external_price_id",
                id: "id",
            },
            params: { key: "value" },
        };
        server
            .mockEndpoint()
            .post("/billing/meter/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.billing.upsertBillingMeter({
            display_name: "display_name",
            event_name: "event_name",
            event_payload_key: "event_payload_key",
            external_id: "external_id",
        });
        expect(response).toEqual({
            data: {
                dispaly_name: "dispaly_name",
                event_name: "event_name",
                event_payload_key: "event_payload_key",
                external_price_id: "external_price_id",
                id: "id",
            },
            params: {
                key: "value",
            },
        });
    });

    test("upsertBillingMeter (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            display_name: "display_name",
            event_name: "event_name",
            event_payload_key: "event_payload_key",
            external_id: "external_id",
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/meter/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingMeter({
                display_name: "display_name",
                event_name: "event_name",
                event_payload_key: "event_payload_key",
                external_id: "external_id",
            });
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("upsertBillingMeter (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            display_name: "display_name",
            event_name: "event_name",
            event_payload_key: "event_payload_key",
            external_id: "external_id",
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/meter/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingMeter({
                display_name: "display_name",
                event_name: "event_name",
                event_payload_key: "event_payload_key",
                external_id: "external_id",
            });
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("upsertBillingMeter (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            display_name: "display_name",
            event_name: "event_name",
            event_payload_key: "event_payload_key",
            external_id: "external_id",
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/meter/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingMeter({
                display_name: "display_name",
                event_name: "event_name",
                event_payload_key: "event_payload_key",
                external_id: "external_id",
            });
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("upsertBillingMeter (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            display_name: "display_name",
            event_name: "event_name",
            event_payload_key: "event_payload_key",
            external_id: "external_id",
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/meter/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingMeter({
                display_name: "display_name",
                event_name: "event_name",
                event_payload_key: "event_payload_key",
                external_id: "external_id",
            });
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("upsertBillingMeter (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            display_name: "display_name",
            event_name: "event_name",
            event_payload_key: "event_payload_key",
            external_id: "external_id",
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/meter/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingMeter({
                display_name: "display_name",
                event_name: "event_name",
                event_payload_key: "event_payload_key",
                external_id: "external_id",
            });
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("listPaymentMethods (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            data: [
                {
                    account_last4: "account_last4",
                    account_name: "account_name",
                    bank_name: "bank_name",
                    billing_email: "billing_email",
                    billing_name: "billing_name",
                    card_brand: "card_brand",
                    card_exp_month: 1,
                    card_exp_year: 1,
                    card_last4: "card_last4",
                    company_id: "company_id",
                    created_at: "2024-01-15T09:30:00Z",
                    customer_external_id: "customer_external_id",
                    environment_id: "environment_id",
                    external_id: "external_id",
                    id: "id",
                    payment_method_type: "payment_method_type",
                    updated_at: "2024-01-15T09:30:00Z",
                },
            ],
            params: { company_id: "company_id", customer_external_id: "customer_external_id", limit: 1, offset: 1 },
        };
        server
            .mockEndpoint()
            .get("/billing/payment-methods")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.billing.listPaymentMethods({
            company_id: "company_id",
            customer_external_id: "customer_external_id",
            limit: 1,
            offset: 1,
        });
        expect(response).toEqual({
            data: [
                {
                    account_last4: "account_last4",
                    account_name: "account_name",
                    bank_name: "bank_name",
                    billing_email: "billing_email",
                    billing_name: "billing_name",
                    card_brand: "card_brand",
                    card_exp_month: 1,
                    card_exp_year: 1,
                    card_last4: "card_last4",
                    company_id: "company_id",
                    created_at: "2024-01-15T09:30:00Z",
                    customer_external_id: "customer_external_id",
                    environment_id: "environment_id",
                    external_id: "external_id",
                    id: "id",
                    payment_method_type: "payment_method_type",
                    updated_at: "2024-01-15T09:30:00Z",
                },
            ],
            params: {
                company_id: "company_id",
                customer_external_id: "customer_external_id",
                limit: 1,
                offset: 1,
            },
        });
    });

    test("listPaymentMethods (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/payment-methods")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.listPaymentMethods({
                customer_external_id: "customer_external_id",
            });
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("listPaymentMethods (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/payment-methods")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.listPaymentMethods({
                customer_external_id: "customer_external_id",
            });
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("listPaymentMethods (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/payment-methods")
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.listPaymentMethods({
                customer_external_id: "customer_external_id",
            });
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("listPaymentMethods (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/payment-methods")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.listPaymentMethods({
                customer_external_id: "customer_external_id",
            });
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("listPaymentMethods (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/payment-methods")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.listPaymentMethods({
                customer_external_id: "customer_external_id",
            });
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("upsertPaymentMethod (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            customer_external_id: "customer_external_id",
            external_id: "external_id",
            payment_method_type: "payment_method_type",
        };
        const rawResponseBody = {
            data: {
                account_last4: "account_last4",
                account_name: "account_name",
                bank_name: "bank_name",
                billing_email: "billing_email",
                billing_name: "billing_name",
                card_brand: "card_brand",
                card_exp_month: 1,
                card_exp_year: 1,
                card_last4: "card_last4",
                company_id: "company_id",
                created_at: "2024-01-15T09:30:00Z",
                customer_external_id: "customer_external_id",
                environment_id: "environment_id",
                external_id: "external_id",
                id: "id",
                payment_method_type: "payment_method_type",
                updated_at: "2024-01-15T09:30:00Z",
            },
            params: { key: "value" },
        };
        server
            .mockEndpoint()
            .post("/billing/payment-methods")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.billing.upsertPaymentMethod({
            customer_external_id: "customer_external_id",
            external_id: "external_id",
            payment_method_type: "payment_method_type",
        });
        expect(response).toEqual({
            data: {
                account_last4: "account_last4",
                account_name: "account_name",
                bank_name: "bank_name",
                billing_email: "billing_email",
                billing_name: "billing_name",
                card_brand: "card_brand",
                card_exp_month: 1,
                card_exp_year: 1,
                card_last4: "card_last4",
                company_id: "company_id",
                created_at: "2024-01-15T09:30:00Z",
                customer_external_id: "customer_external_id",
                environment_id: "environment_id",
                external_id: "external_id",
                id: "id",
                payment_method_type: "payment_method_type",
                updated_at: "2024-01-15T09:30:00Z",
            },
            params: {
                key: "value",
            },
        });
    });

    test("upsertPaymentMethod (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            customer_external_id: "customer_external_id",
            external_id: "external_id",
            payment_method_type: "payment_method_type",
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/payment-methods")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertPaymentMethod({
                customer_external_id: "customer_external_id",
                external_id: "external_id",
                payment_method_type: "payment_method_type",
            });
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("upsertPaymentMethod (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            customer_external_id: "customer_external_id",
            external_id: "external_id",
            payment_method_type: "payment_method_type",
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/payment-methods")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertPaymentMethod({
                customer_external_id: "customer_external_id",
                external_id: "external_id",
                payment_method_type: "payment_method_type",
            });
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("upsertPaymentMethod (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            customer_external_id: "customer_external_id",
            external_id: "external_id",
            payment_method_type: "payment_method_type",
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/payment-methods")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertPaymentMethod({
                customer_external_id: "customer_external_id",
                external_id: "external_id",
                payment_method_type: "payment_method_type",
            });
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("upsertPaymentMethod (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            customer_external_id: "customer_external_id",
            external_id: "external_id",
            payment_method_type: "payment_method_type",
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/payment-methods")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertPaymentMethod({
                customer_external_id: "customer_external_id",
                external_id: "external_id",
                payment_method_type: "payment_method_type",
            });
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("upsertPaymentMethod (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            customer_external_id: "customer_external_id",
            external_id: "external_id",
            payment_method_type: "payment_method_type",
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/payment-methods")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertPaymentMethod({
                customer_external_id: "customer_external_id",
                external_id: "external_id",
                payment_method_type: "payment_method_type",
            });
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("searchBillingPrices (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            data: [
                {
                    billing_scheme: "billing_scheme",
                    created_at: "2024-01-15T09:30:00Z",
                    currency: "currency",
                    id: "id",
                    interval: "interval",
                    is_active: true,
                    meter_event_name: "meter_event_name",
                    meter_event_payload_key: "meter_event_payload_key",
                    meter_id: "meter_id",
                    package_size: 1,
                    price: 1,
                    price_decimal: "price_decimal",
                    price_external_id: "price_external_id",
                    price_id: "price_id",
                    price_tier: [{}],
                    product_external_id: "product_external_id",
                    product_id: "product_id",
                    product_name: "product_name",
                    tiers_mode: "tiers_mode",
                    updated_at: "2024-01-15T09:30:00Z",
                    usage_type: "usage_type",
                },
            ],
            params: {
                for_initial_plan: true,
                for_trial_expiry_plan: true,
                ids: ["ids"],
                interval: "interval",
                limit: 1,
                offset: 1,
                price: 1,
                product_id: "product_id",
                q: "q",
                requires_payment_method: true,
                tiers_mode: "volume",
                usage_type: "licensed",
            },
        };
        server.mockEndpoint().get("/billing/price").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.billing.searchBillingPrices({
            for_initial_plan: true,
            for_trial_expiry_plan: true,
            product_id: "product_id",
            interval: "interval",
            price: 1,
            q: "q",
            requires_payment_method: true,
            tiers_mode: "volume",
            usage_type: "licensed",
            limit: 1,
            offset: 1,
        });
        expect(response).toEqual({
            data: [
                {
                    billing_scheme: "billing_scheme",
                    created_at: "2024-01-15T09:30:00Z",
                    currency: "currency",
                    id: "id",
                    interval: "interval",
                    is_active: true,
                    meter_event_name: "meter_event_name",
                    meter_event_payload_key: "meter_event_payload_key",
                    meter_id: "meter_id",
                    package_size: 1,
                    price: 1,
                    price_decimal: "price_decimal",
                    price_external_id: "price_external_id",
                    price_id: "price_id",
                    price_tier: [{}],
                    product_external_id: "product_external_id",
                    product_id: "product_id",
                    product_name: "product_name",
                    tiers_mode: "tiers_mode",
                    updated_at: "2024-01-15T09:30:00Z",
                    usage_type: "usage_type",
                },
            ],
            params: {
                for_initial_plan: true,
                for_trial_expiry_plan: true,
                ids: ["ids"],
                interval: "interval",
                limit: 1,
                offset: 1,
                price: 1,
                product_id: "product_id",
                q: "q",
                requires_payment_method: true,
                tiers_mode: "volume",
                usage_type: "licensed",
            },
        });
    });

    test("searchBillingPrices (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/price").respondWith().statusCode(400).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.searchBillingPrices();
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("searchBillingPrices (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/price").respondWith().statusCode(401).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.searchBillingPrices();
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("searchBillingPrices (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/price").respondWith().statusCode(403).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.searchBillingPrices();
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("searchBillingPrices (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/price").respondWith().statusCode(404).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.searchBillingPrices();
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("searchBillingPrices (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/price").respondWith().statusCode(500).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.searchBillingPrices();
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("upsertBillingPrice (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            billing_scheme: "per_unit",
            currency: "currency",
            external_account_id: "external_account_id",
            interval: "interval",
            is_active: true,
            price: 1,
            price_external_id: "price_external_id",
            price_tiers: [{ price_external_id: "price_external_id" }],
            product_external_id: "product_external_id",
            usage_type: "licensed",
        };
        const rawResponseBody = {
            data: {
                currency: "currency",
                external_price_id: "external_price_id",
                id: "id",
                interval: "interval",
                price: 1,
                price_decimal: "price_decimal",
                scheme: "scheme",
            },
            params: { key: "value" },
        };
        server
            .mockEndpoint()
            .post("/billing/price/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.billing.upsertBillingPrice({
            billing_scheme: "per_unit",
            currency: "currency",
            external_account_id: "external_account_id",
            interval: "interval",
            is_active: true,
            price: 1,
            price_external_id: "price_external_id",
            price_tiers: [
                {
                    price_external_id: "price_external_id",
                },
            ],
            product_external_id: "product_external_id",
            usage_type: "licensed",
        });
        expect(response).toEqual({
            data: {
                currency: "currency",
                external_price_id: "external_price_id",
                id: "id",
                interval: "interval",
                price: 1,
                price_decimal: "price_decimal",
                scheme: "scheme",
            },
            params: {
                key: "value",
            },
        });
    });

    test("upsertBillingPrice (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            billing_scheme: "per_unit",
            currency: "currency",
            external_account_id: "external_account_id",
            interval: "interval",
            is_active: true,
            price: 1,
            price_external_id: "price_external_id",
            price_tiers: [{ price_external_id: "price_external_id" }, { price_external_id: "price_external_id" }],
            product_external_id: "product_external_id",
            usage_type: "licensed",
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/price/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingPrice({
                billing_scheme: "per_unit",
                currency: "currency",
                external_account_id: "external_account_id",
                interval: "interval",
                is_active: true,
                price: 1,
                price_external_id: "price_external_id",
                price_tiers: [
                    {
                        price_external_id: "price_external_id",
                    },
                    {
                        price_external_id: "price_external_id",
                    },
                ],
                product_external_id: "product_external_id",
                usage_type: "licensed",
            });
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("upsertBillingPrice (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            billing_scheme: "per_unit",
            currency: "currency",
            external_account_id: "external_account_id",
            interval: "interval",
            is_active: true,
            price: 1,
            price_external_id: "price_external_id",
            price_tiers: [{ price_external_id: "price_external_id" }, { price_external_id: "price_external_id" }],
            product_external_id: "product_external_id",
            usage_type: "licensed",
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/price/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingPrice({
                billing_scheme: "per_unit",
                currency: "currency",
                external_account_id: "external_account_id",
                interval: "interval",
                is_active: true,
                price: 1,
                price_external_id: "price_external_id",
                price_tiers: [
                    {
                        price_external_id: "price_external_id",
                    },
                    {
                        price_external_id: "price_external_id",
                    },
                ],
                product_external_id: "product_external_id",
                usage_type: "licensed",
            });
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("upsertBillingPrice (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            billing_scheme: "per_unit",
            currency: "currency",
            external_account_id: "external_account_id",
            interval: "interval",
            is_active: true,
            price: 1,
            price_external_id: "price_external_id",
            price_tiers: [{ price_external_id: "price_external_id" }, { price_external_id: "price_external_id" }],
            product_external_id: "product_external_id",
            usage_type: "licensed",
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/price/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingPrice({
                billing_scheme: "per_unit",
                currency: "currency",
                external_account_id: "external_account_id",
                interval: "interval",
                is_active: true,
                price: 1,
                price_external_id: "price_external_id",
                price_tiers: [
                    {
                        price_external_id: "price_external_id",
                    },
                    {
                        price_external_id: "price_external_id",
                    },
                ],
                product_external_id: "product_external_id",
                usage_type: "licensed",
            });
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("upsertBillingPrice (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            billing_scheme: "per_unit",
            currency: "currency",
            external_account_id: "external_account_id",
            interval: "interval",
            is_active: true,
            price: 1,
            price_external_id: "price_external_id",
            price_tiers: [{ price_external_id: "price_external_id" }, { price_external_id: "price_external_id" }],
            product_external_id: "product_external_id",
            usage_type: "licensed",
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/price/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingPrice({
                billing_scheme: "per_unit",
                currency: "currency",
                external_account_id: "external_account_id",
                interval: "interval",
                is_active: true,
                price: 1,
                price_external_id: "price_external_id",
                price_tiers: [
                    {
                        price_external_id: "price_external_id",
                    },
                    {
                        price_external_id: "price_external_id",
                    },
                ],
                product_external_id: "product_external_id",
                usage_type: "licensed",
            });
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("upsertBillingPrice (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            billing_scheme: "per_unit",
            currency: "currency",
            external_account_id: "external_account_id",
            interval: "interval",
            is_active: true,
            price: 1,
            price_external_id: "price_external_id",
            price_tiers: [{ price_external_id: "price_external_id" }, { price_external_id: "price_external_id" }],
            product_external_id: "product_external_id",
            usage_type: "licensed",
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/price/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingPrice({
                billing_scheme: "per_unit",
                currency: "currency",
                external_account_id: "external_account_id",
                interval: "interval",
                is_active: true,
                price: 1,
                price_external_id: "price_external_id",
                price_tiers: [
                    {
                        price_external_id: "price_external_id",
                    },
                    {
                        price_external_id: "price_external_id",
                    },
                ],
                product_external_id: "product_external_id",
                usage_type: "licensed",
            });
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("deleteBillingProduct (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { data: { deleted: true }, params: { key: "value" } };
        server
            .mockEndpoint()
            .delete("/billing/product/billing_id")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.billing.deleteBillingProduct("billing_id");
        expect(response).toEqual({
            data: {
                deleted: true,
            },
            params: {
                key: "value",
            },
        });
    });

    test("deleteBillingProduct (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .delete("/billing/product/billing_id")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.deleteBillingProduct("billing_id");
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("deleteBillingProduct (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .delete("/billing/product/billing_id")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.deleteBillingProduct("billing_id");
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("deleteBillingProduct (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .delete("/billing/product/billing_id")
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.deleteBillingProduct("billing_id");
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("deleteBillingProduct (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .delete("/billing/product/billing_id")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.deleteBillingProduct("billing_id");
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("deleteBillingProduct (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .delete("/billing/product/billing_id")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.deleteBillingProduct("billing_id");
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("listProductPrices (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            data: [
                {
                    currency: "currency",
                    external_price_id: "external_price_id",
                    id: "id",
                    interval: "interval",
                    price: 1,
                    price_decimal: "price_decimal",
                    scheme: "scheme",
                },
            ],
            params: {
                ids: ["ids"],
                is_active: true,
                limit: 1,
                name: "name",
                offset: 1,
                price_usage_type: "licensed",
                q: "q",
                with_one_time_charges: true,
                with_prices_only: true,
                with_zero_price: true,
                without_linked_to_plan: true,
            },
        };
        server
            .mockEndpoint()
            .get("/billing/product/prices")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.billing.listProductPrices({
            name: "name",
            q: "q",
            price_usage_type: "licensed",
            without_linked_to_plan: true,
            with_one_time_charges: true,
            with_zero_price: true,
            with_prices_only: true,
            is_active: true,
            limit: 1,
            offset: 1,
        });
        expect(response).toEqual({
            data: [
                {
                    currency: "currency",
                    external_price_id: "external_price_id",
                    id: "id",
                    interval: "interval",
                    price: 1,
                    price_decimal: "price_decimal",
                    scheme: "scheme",
                },
            ],
            params: {
                ids: ["ids"],
                is_active: true,
                limit: 1,
                name: "name",
                offset: 1,
                price_usage_type: "licensed",
                q: "q",
                with_one_time_charges: true,
                with_prices_only: true,
                with_zero_price: true,
                without_linked_to_plan: true,
            },
        });
    });

    test("listProductPrices (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/product/prices")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.listProductPrices();
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("listProductPrices (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/product/prices")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.listProductPrices();
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("listProductPrices (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/product/prices")
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.listProductPrices();
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("listProductPrices (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/product/prices")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.listProductPrices();
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("listProductPrices (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/product/prices")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.listProductPrices();
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("deleteProductPrice (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { data: { deleted: true }, params: { key: "value" } };
        server
            .mockEndpoint()
            .delete("/billing/product/prices/billing_id")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.billing.deleteProductPrice("billing_id");
        expect(response).toEqual({
            data: {
                deleted: true,
            },
            params: {
                key: "value",
            },
        });
    });

    test("deleteProductPrice (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .delete("/billing/product/prices/billing_id")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.deleteProductPrice("billing_id");
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("deleteProductPrice (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .delete("/billing/product/prices/billing_id")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.deleteProductPrice("billing_id");
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("deleteProductPrice (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .delete("/billing/product/prices/billing_id")
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.deleteProductPrice("billing_id");
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("deleteProductPrice (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .delete("/billing/product/prices/billing_id")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.deleteProductPrice("billing_id");
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("deleteProductPrice (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .delete("/billing/product/prices/billing_id")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.deleteProductPrice("billing_id");
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("upsertBillingProduct (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { external_id: "external_id", name: "name", price: 1.1 };
        const rawResponseBody = {
            data: {
                account_id: "account_id",
                created_at: "2024-01-15T09:30:00Z",
                environment_id: "environment_id",
                external_id: "external_id",
                is_active: true,
                name: "name",
                price: 1.1,
                price_decimal: "price_decimal",
                product_id: "product_id",
                quantity: 1.1,
                updated_at: "2024-01-15T09:30:00Z",
            },
            params: { key: "value" },
        };
        server
            .mockEndpoint()
            .post("/billing/product/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.billing.upsertBillingProduct({
            external_id: "external_id",
            name: "name",
            price: 1.1,
        });
        expect(response).toEqual({
            data: {
                account_id: "account_id",
                created_at: "2024-01-15T09:30:00Z",
                environment_id: "environment_id",
                external_id: "external_id",
                is_active: true,
                name: "name",
                price: 1.1,
                price_decimal: "price_decimal",
                product_id: "product_id",
                quantity: 1.1,
                updated_at: "2024-01-15T09:30:00Z",
            },
            params: {
                key: "value",
            },
        });
    });

    test("upsertBillingProduct (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { external_id: "external_id", name: "name", price: 1.1 };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/product/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingProduct({
                external_id: "external_id",
                name: "name",
                price: 1.1,
            });
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("upsertBillingProduct (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { external_id: "external_id", name: "name", price: 1.1 };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/product/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingProduct({
                external_id: "external_id",
                name: "name",
                price: 1.1,
            });
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("upsertBillingProduct (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { external_id: "external_id", name: "name", price: 1.1 };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/product/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingProduct({
                external_id: "external_id",
                name: "name",
                price: 1.1,
            });
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("upsertBillingProduct (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { external_id: "external_id", name: "name", price: 1.1 };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/product/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingProduct({
                external_id: "external_id",
                name: "name",
                price: 1.1,
            });
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("upsertBillingProduct (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { external_id: "external_id", name: "name", price: 1.1 };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/product/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingProduct({
                external_id: "external_id",
                name: "name",
                price: 1.1,
            });
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("listBillingProducts (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            data: [
                {
                    account_id: "account_id",
                    created_at: "2024-01-15T09:30:00Z",
                    environment_id: "environment_id",
                    external_id: "external_id",
                    is_active: true,
                    name: "name",
                    price: 1.1,
                    price_decimal: "price_decimal",
                    prices: [
                        {
                            currency: "currency",
                            external_price_id: "external_price_id",
                            id: "id",
                            interval: "interval",
                            price: 1,
                            scheme: "scheme",
                        },
                    ],
                    product_id: "product_id",
                    quantity: 1.1,
                    subscription_count: 1,
                    updated_at: "2024-01-15T09:30:00Z",
                },
            ],
            params: {
                ids: ["ids"],
                is_active: true,
                limit: 1,
                name: "name",
                offset: 1,
                price_usage_type: "licensed",
                q: "q",
                with_one_time_charges: true,
                with_prices_only: true,
                with_zero_price: true,
                without_linked_to_plan: true,
            },
        };
        server.mockEndpoint().get("/billing/products").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.billing.listBillingProducts({
            name: "name",
            q: "q",
            price_usage_type: "licensed",
            without_linked_to_plan: true,
            with_one_time_charges: true,
            with_zero_price: true,
            with_prices_only: true,
            is_active: true,
            limit: 1,
            offset: 1,
        });
        expect(response).toEqual({
            data: [
                {
                    account_id: "account_id",
                    created_at: "2024-01-15T09:30:00Z",
                    environment_id: "environment_id",
                    external_id: "external_id",
                    is_active: true,
                    name: "name",
                    price: 1.1,
                    price_decimal: "price_decimal",
                    prices: [
                        {
                            currency: "currency",
                            external_price_id: "external_price_id",
                            id: "id",
                            interval: "interval",
                            price: 1,
                            scheme: "scheme",
                        },
                    ],
                    product_id: "product_id",
                    quantity: 1.1,
                    subscription_count: 1,
                    updated_at: "2024-01-15T09:30:00Z",
                },
            ],
            params: {
                ids: ["ids"],
                is_active: true,
                limit: 1,
                name: "name",
                offset: 1,
                price_usage_type: "licensed",
                q: "q",
                with_one_time_charges: true,
                with_prices_only: true,
                with_zero_price: true,
                without_linked_to_plan: true,
            },
        });
    });

    test("listBillingProducts (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/products").respondWith().statusCode(400).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.listBillingProducts();
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("listBillingProducts (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/products").respondWith().statusCode(401).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.listBillingProducts();
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("listBillingProducts (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/products").respondWith().statusCode(403).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.listBillingProducts();
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("listBillingProducts (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/products").respondWith().statusCode(404).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.listBillingProducts();
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("listBillingProducts (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/products").respondWith().statusCode(500).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.listBillingProducts();
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("countBillingProducts (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            data: { count: 1 },
            params: {
                ids: ["ids"],
                is_active: true,
                limit: 1,
                name: "name",
                offset: 1,
                price_usage_type: "licensed",
                q: "q",
                with_one_time_charges: true,
                with_prices_only: true,
                with_zero_price: true,
                without_linked_to_plan: true,
            },
        };
        server
            .mockEndpoint()
            .get("/billing/products/count")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.billing.countBillingProducts({
            name: "name",
            q: "q",
            price_usage_type: "licensed",
            without_linked_to_plan: true,
            with_one_time_charges: true,
            with_zero_price: true,
            with_prices_only: true,
            is_active: true,
            limit: 1,
            offset: 1,
        });
        expect(response).toEqual({
            data: {
                count: 1,
            },
            params: {
                ids: ["ids"],
                is_active: true,
                limit: 1,
                name: "name",
                offset: 1,
                price_usage_type: "licensed",
                q: "q",
                with_one_time_charges: true,
                with_prices_only: true,
                with_zero_price: true,
                without_linked_to_plan: true,
            },
        });
    });

    test("countBillingProducts (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/products/count")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.countBillingProducts();
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("countBillingProducts (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/products/count")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.countBillingProducts();
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("countBillingProducts (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/products/count")
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.countBillingProducts();
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("countBillingProducts (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/products/count")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.countBillingProducts();
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("countBillingProducts (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/products/count")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.countBillingProducts();
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("upsertBillingSubscription (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            cancel_at_period_end: true,
            currency: "currency",
            customer_external_id: "customer_external_id",
            discounts: [
                {
                    coupon_external_id: "coupon_external_id",
                    external_id: "external_id",
                    is_active: true,
                    started_at: "2024-01-15T09:30:00Z",
                },
            ],
            expired_at: "2024-01-15T09:30:00Z",
            product_external_ids: [
                {
                    currency: "currency",
                    interval: "interval",
                    price: 1,
                    price_external_id: "price_external_id",
                    product_external_id: "product_external_id",
                    quantity: 1,
                    usage_type: "licensed",
                },
            ],
            subscription_external_id: "subscription_external_id",
            total_price: 1,
        };
        const rawResponseBody = {
            data: {
                cancel_at: 1,
                cancel_at_period_end: true,
                company_id: "company_id",
                created_at: "2024-01-15T09:30:00Z",
                currency: "currency",
                customer_external_id: "customer_external_id",
                default_payment_method_id: "default_payment_method_id",
                expired_at: "2024-01-15T09:30:00Z",
                id: "id",
                interval: "interval",
                metadata: { key: "value" },
                period_end: 1,
                period_start: 1,
                status: "status",
                subscription_external_id: "subscription_external_id",
                total_price: 1,
                trial_end: 1,
                trial_end_setting: "trial_end_setting",
            },
            params: { key: "value" },
        };
        server
            .mockEndpoint()
            .post("/billing/subscription/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.billing.upsertBillingSubscription({
            cancel_at_period_end: true,
            currency: "currency",
            customer_external_id: "customer_external_id",
            discounts: [
                {
                    coupon_external_id: "coupon_external_id",
                    external_id: "external_id",
                    is_active: true,
                    started_at: "2024-01-15T09:30:00Z",
                },
            ],
            expired_at: "2024-01-15T09:30:00Z",
            product_external_ids: [
                {
                    currency: "currency",
                    interval: "interval",
                    price: 1,
                    price_external_id: "price_external_id",
                    product_external_id: "product_external_id",
                    quantity: 1,
                    usage_type: "licensed",
                },
            ],
            subscription_external_id: "subscription_external_id",
            total_price: 1,
        });
        expect(response).toEqual({
            data: {
                cancel_at: 1,
                cancel_at_period_end: true,
                company_id: "company_id",
                created_at: "2024-01-15T09:30:00Z",
                currency: "currency",
                customer_external_id: "customer_external_id",
                default_payment_method_id: "default_payment_method_id",
                expired_at: "2024-01-15T09:30:00Z",
                id: "id",
                interval: "interval",
                metadata: {
                    key: "value",
                },
                period_end: 1,
                period_start: 1,
                status: "status",
                subscription_external_id: "subscription_external_id",
                total_price: 1,
                trial_end: 1,
                trial_end_setting: "trial_end_setting",
            },
            params: {
                key: "value",
            },
        });
    });

    test("upsertBillingSubscription (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            cancel_at_period_end: true,
            currency: "currency",
            customer_external_id: "customer_external_id",
            discounts: [
                {
                    coupon_external_id: "coupon_external_id",
                    external_id: "external_id",
                    is_active: true,
                    started_at: "2024-01-15T09:30:00Z",
                },
                {
                    coupon_external_id: "coupon_external_id",
                    external_id: "external_id",
                    is_active: true,
                    started_at: "2024-01-15T09:30:00Z",
                },
            ],
            expired_at: "2024-01-15T09:30:00Z",
            product_external_ids: [
                {
                    currency: "currency",
                    interval: "interval",
                    price: 1,
                    price_external_id: "price_external_id",
                    product_external_id: "product_external_id",
                    quantity: 1,
                    usage_type: "licensed",
                },
                {
                    currency: "currency",
                    interval: "interval",
                    price: 1,
                    price_external_id: "price_external_id",
                    product_external_id: "product_external_id",
                    quantity: 1,
                    usage_type: "licensed",
                },
            ],
            subscription_external_id: "subscription_external_id",
            total_price: 1,
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/subscription/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingSubscription({
                cancel_at_period_end: true,
                currency: "currency",
                customer_external_id: "customer_external_id",
                discounts: [
                    {
                        coupon_external_id: "coupon_external_id",
                        external_id: "external_id",
                        is_active: true,
                        started_at: "2024-01-15T09:30:00Z",
                    },
                    {
                        coupon_external_id: "coupon_external_id",
                        external_id: "external_id",
                        is_active: true,
                        started_at: "2024-01-15T09:30:00Z",
                    },
                ],
                expired_at: "2024-01-15T09:30:00Z",
                product_external_ids: [
                    {
                        currency: "currency",
                        interval: "interval",
                        price: 1,
                        price_external_id: "price_external_id",
                        product_external_id: "product_external_id",
                        quantity: 1,
                        usage_type: "licensed",
                    },
                    {
                        currency: "currency",
                        interval: "interval",
                        price: 1,
                        price_external_id: "price_external_id",
                        product_external_id: "product_external_id",
                        quantity: 1,
                        usage_type: "licensed",
                    },
                ],
                subscription_external_id: "subscription_external_id",
                total_price: 1,
            });
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("upsertBillingSubscription (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            cancel_at_period_end: true,
            currency: "currency",
            customer_external_id: "customer_external_id",
            discounts: [
                {
                    coupon_external_id: "coupon_external_id",
                    external_id: "external_id",
                    is_active: true,
                    started_at: "2024-01-15T09:30:00Z",
                },
                {
                    coupon_external_id: "coupon_external_id",
                    external_id: "external_id",
                    is_active: true,
                    started_at: "2024-01-15T09:30:00Z",
                },
            ],
            expired_at: "2024-01-15T09:30:00Z",
            product_external_ids: [
                {
                    currency: "currency",
                    interval: "interval",
                    price: 1,
                    price_external_id: "price_external_id",
                    product_external_id: "product_external_id",
                    quantity: 1,
                    usage_type: "licensed",
                },
                {
                    currency: "currency",
                    interval: "interval",
                    price: 1,
                    price_external_id: "price_external_id",
                    product_external_id: "product_external_id",
                    quantity: 1,
                    usage_type: "licensed",
                },
            ],
            subscription_external_id: "subscription_external_id",
            total_price: 1,
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/subscription/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingSubscription({
                cancel_at_period_end: true,
                currency: "currency",
                customer_external_id: "customer_external_id",
                discounts: [
                    {
                        coupon_external_id: "coupon_external_id",
                        external_id: "external_id",
                        is_active: true,
                        started_at: "2024-01-15T09:30:00Z",
                    },
                    {
                        coupon_external_id: "coupon_external_id",
                        external_id: "external_id",
                        is_active: true,
                        started_at: "2024-01-15T09:30:00Z",
                    },
                ],
                expired_at: "2024-01-15T09:30:00Z",
                product_external_ids: [
                    {
                        currency: "currency",
                        interval: "interval",
                        price: 1,
                        price_external_id: "price_external_id",
                        product_external_id: "product_external_id",
                        quantity: 1,
                        usage_type: "licensed",
                    },
                    {
                        currency: "currency",
                        interval: "interval",
                        price: 1,
                        price_external_id: "price_external_id",
                        product_external_id: "product_external_id",
                        quantity: 1,
                        usage_type: "licensed",
                    },
                ],
                subscription_external_id: "subscription_external_id",
                total_price: 1,
            });
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("upsertBillingSubscription (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            cancel_at_period_end: true,
            currency: "currency",
            customer_external_id: "customer_external_id",
            discounts: [
                {
                    coupon_external_id: "coupon_external_id",
                    external_id: "external_id",
                    is_active: true,
                    started_at: "2024-01-15T09:30:00Z",
                },
                {
                    coupon_external_id: "coupon_external_id",
                    external_id: "external_id",
                    is_active: true,
                    started_at: "2024-01-15T09:30:00Z",
                },
            ],
            expired_at: "2024-01-15T09:30:00Z",
            product_external_ids: [
                {
                    currency: "currency",
                    interval: "interval",
                    price: 1,
                    price_external_id: "price_external_id",
                    product_external_id: "product_external_id",
                    quantity: 1,
                    usage_type: "licensed",
                },
                {
                    currency: "currency",
                    interval: "interval",
                    price: 1,
                    price_external_id: "price_external_id",
                    product_external_id: "product_external_id",
                    quantity: 1,
                    usage_type: "licensed",
                },
            ],
            subscription_external_id: "subscription_external_id",
            total_price: 1,
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/subscription/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingSubscription({
                cancel_at_period_end: true,
                currency: "currency",
                customer_external_id: "customer_external_id",
                discounts: [
                    {
                        coupon_external_id: "coupon_external_id",
                        external_id: "external_id",
                        is_active: true,
                        started_at: "2024-01-15T09:30:00Z",
                    },
                    {
                        coupon_external_id: "coupon_external_id",
                        external_id: "external_id",
                        is_active: true,
                        started_at: "2024-01-15T09:30:00Z",
                    },
                ],
                expired_at: "2024-01-15T09:30:00Z",
                product_external_ids: [
                    {
                        currency: "currency",
                        interval: "interval",
                        price: 1,
                        price_external_id: "price_external_id",
                        product_external_id: "product_external_id",
                        quantity: 1,
                        usage_type: "licensed",
                    },
                    {
                        currency: "currency",
                        interval: "interval",
                        price: 1,
                        price_external_id: "price_external_id",
                        product_external_id: "product_external_id",
                        quantity: 1,
                        usage_type: "licensed",
                    },
                ],
                subscription_external_id: "subscription_external_id",
                total_price: 1,
            });
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("upsertBillingSubscription (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            cancel_at_period_end: true,
            currency: "currency",
            customer_external_id: "customer_external_id",
            discounts: [
                {
                    coupon_external_id: "coupon_external_id",
                    external_id: "external_id",
                    is_active: true,
                    started_at: "2024-01-15T09:30:00Z",
                },
                {
                    coupon_external_id: "coupon_external_id",
                    external_id: "external_id",
                    is_active: true,
                    started_at: "2024-01-15T09:30:00Z",
                },
            ],
            expired_at: "2024-01-15T09:30:00Z",
            product_external_ids: [
                {
                    currency: "currency",
                    interval: "interval",
                    price: 1,
                    price_external_id: "price_external_id",
                    product_external_id: "product_external_id",
                    quantity: 1,
                    usage_type: "licensed",
                },
                {
                    currency: "currency",
                    interval: "interval",
                    price: 1,
                    price_external_id: "price_external_id",
                    product_external_id: "product_external_id",
                    quantity: 1,
                    usage_type: "licensed",
                },
            ],
            subscription_external_id: "subscription_external_id",
            total_price: 1,
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/subscription/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingSubscription({
                cancel_at_period_end: true,
                currency: "currency",
                customer_external_id: "customer_external_id",
                discounts: [
                    {
                        coupon_external_id: "coupon_external_id",
                        external_id: "external_id",
                        is_active: true,
                        started_at: "2024-01-15T09:30:00Z",
                    },
                    {
                        coupon_external_id: "coupon_external_id",
                        external_id: "external_id",
                        is_active: true,
                        started_at: "2024-01-15T09:30:00Z",
                    },
                ],
                expired_at: "2024-01-15T09:30:00Z",
                product_external_ids: [
                    {
                        currency: "currency",
                        interval: "interval",
                        price: 1,
                        price_external_id: "price_external_id",
                        product_external_id: "product_external_id",
                        quantity: 1,
                        usage_type: "licensed",
                    },
                    {
                        currency: "currency",
                        interval: "interval",
                        price: 1,
                        price_external_id: "price_external_id",
                        product_external_id: "product_external_id",
                        quantity: 1,
                        usage_type: "licensed",
                    },
                ],
                subscription_external_id: "subscription_external_id",
                total_price: 1,
            });
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("upsertBillingSubscription (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            cancel_at_period_end: true,
            currency: "currency",
            customer_external_id: "customer_external_id",
            discounts: [
                {
                    coupon_external_id: "coupon_external_id",
                    external_id: "external_id",
                    is_active: true,
                    started_at: "2024-01-15T09:30:00Z",
                },
                {
                    coupon_external_id: "coupon_external_id",
                    external_id: "external_id",
                    is_active: true,
                    started_at: "2024-01-15T09:30:00Z",
                },
            ],
            expired_at: "2024-01-15T09:30:00Z",
            product_external_ids: [
                {
                    currency: "currency",
                    interval: "interval",
                    price: 1,
                    price_external_id: "price_external_id",
                    product_external_id: "product_external_id",
                    quantity: 1,
                    usage_type: "licensed",
                },
                {
                    currency: "currency",
                    interval: "interval",
                    price: 1,
                    price_external_id: "price_external_id",
                    product_external_id: "product_external_id",
                    quantity: 1,
                    usage_type: "licensed",
                },
            ],
            subscription_external_id: "subscription_external_id",
            total_price: 1,
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/subscription/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingSubscription({
                cancel_at_period_end: true,
                currency: "currency",
                customer_external_id: "customer_external_id",
                discounts: [
                    {
                        coupon_external_id: "coupon_external_id",
                        external_id: "external_id",
                        is_active: true,
                        started_at: "2024-01-15T09:30:00Z",
                    },
                    {
                        coupon_external_id: "coupon_external_id",
                        external_id: "external_id",
                        is_active: true,
                        started_at: "2024-01-15T09:30:00Z",
                    },
                ],
                expired_at: "2024-01-15T09:30:00Z",
                product_external_ids: [
                    {
                        currency: "currency",
                        interval: "interval",
                        price: 1,
                        price_external_id: "price_external_id",
                        product_external_id: "product_external_id",
                        quantity: 1,
                        usage_type: "licensed",
                    },
                    {
                        currency: "currency",
                        interval: "interval",
                        price: 1,
                        price_external_id: "price_external_id",
                        product_external_id: "product_external_id",
                        quantity: 1,
                        usage_type: "licensed",
                    },
                ],
                subscription_external_id: "subscription_external_id",
                total_price: 1,
            });
        }).rejects.toThrow(Schematic.InternalServerError);
    });
});
