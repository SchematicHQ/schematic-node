// This file was auto-generated by Fern from our API Definition.

import * as Schematic from "../../src/api/index";
import { SchematicClient } from "../../src/Client";
import { mockServerPool } from "../mock-server/MockServerPool";

describe("BillingClient", () => {
    test("listCoupons (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            data: [
                {
                    account_id: "account_id",
                    amount_off: 1,
                    currency: "currency",
                    duration: "duration",
                    duration_in_months: 1,
                    environment_id: "environment_id",
                    external_id: "external_id",
                    id: "id",
                    is_active: true,
                    max_redemptions: 1,
                    metadata: { key: "value" },
                    name: "name",
                    percent_off: 1.1,
                    times_redeemed: 1,
                    valid_from: "2024-01-15T09:30:00Z",
                    valid_until: "2024-01-15T09:30:00Z",
                },
            ],
            params: { is_active: true, limit: 1, offset: 1, q: "q" },
        };
        server.mockEndpoint().get("/billing/coupons").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.billing.listCoupons({
            isActive: true,
            q: "q",
            limit: 1,
            offset: 1,
        });
        expect(response).toEqual({
            data: [
                {
                    accountId: "account_id",
                    amountOff: 1,
                    currency: "currency",
                    duration: "duration",
                    durationInMonths: 1,
                    environmentId: "environment_id",
                    externalId: "external_id",
                    id: "id",
                    isActive: true,
                    maxRedemptions: 1,
                    metadata: {
                        key: "value",
                    },
                    name: "name",
                    percentOff: 1.1,
                    timesRedeemed: 1,
                    validFrom: new Date("2024-01-15T09:30:00.000Z"),
                    validUntil: new Date("2024-01-15T09:30:00.000Z"),
                },
            ],
            params: {
                isActive: true,
                limit: 1,
                offset: 1,
                q: "q",
            },
        });
    });

    test("listCoupons (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/coupons").respondWith().statusCode(400).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.listCoupons();
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("listCoupons (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/coupons").respondWith().statusCode(401).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.listCoupons();
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("listCoupons (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/coupons").respondWith().statusCode(403).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.listCoupons();
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("listCoupons (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/coupons").respondWith().statusCode(404).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.listCoupons();
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("listCoupons (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/coupons").respondWith().statusCode(500).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.listCoupons();
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("upsertBillingCoupon (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            amount_off: 1,
            duration: "duration",
            duration_in_months: 1,
            external_id: "external_id",
            max_redemptions: 1,
            name: "name",
            percent_off: 1.1,
            times_redeemed: 1,
        };
        const rawResponseBody = {
            data: {
                account_id: "account_id",
                amount_off: 1,
                currency: "currency",
                duration: "duration",
                duration_in_months: 1,
                environment_id: "environment_id",
                external_id: "external_id",
                id: "id",
                is_active: true,
                max_redemptions: 1,
                metadata: { key: "value" },
                name: "name",
                percent_off: 1.1,
                times_redeemed: 1,
                valid_from: "2024-01-15T09:30:00Z",
                valid_until: "2024-01-15T09:30:00Z",
            },
            params: { key: "value" },
        };
        server
            .mockEndpoint()
            .post("/billing/coupons")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.billing.upsertBillingCoupon({
            amountOff: 1,
            duration: "duration",
            durationInMonths: 1,
            externalId: "external_id",
            maxRedemptions: 1,
            name: "name",
            percentOff: 1.1,
            timesRedeemed: 1,
        });
        expect(response).toEqual({
            data: {
                accountId: "account_id",
                amountOff: 1,
                currency: "currency",
                duration: "duration",
                durationInMonths: 1,
                environmentId: "environment_id",
                externalId: "external_id",
                id: "id",
                isActive: true,
                maxRedemptions: 1,
                metadata: {
                    key: "value",
                },
                name: "name",
                percentOff: 1.1,
                timesRedeemed: 1,
                validFrom: new Date("2024-01-15T09:30:00.000Z"),
                validUntil: new Date("2024-01-15T09:30:00.000Z"),
            },
            params: {
                key: "value",
            },
        });
    });

    test("upsertBillingCoupon (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            amount_off: 1,
            duration: "duration",
            duration_in_months: 1,
            external_id: "external_id",
            max_redemptions: 1,
            name: "name",
            percent_off: 1.1,
            times_redeemed: 1,
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/coupons")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingCoupon({
                amountOff: 1,
                duration: "duration",
                durationInMonths: 1,
                externalId: "external_id",
                maxRedemptions: 1,
                name: "name",
                percentOff: 1.1,
                timesRedeemed: 1,
            });
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("upsertBillingCoupon (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            amount_off: 1,
            duration: "duration",
            duration_in_months: 1,
            external_id: "external_id",
            max_redemptions: 1,
            name: "name",
            percent_off: 1.1,
            times_redeemed: 1,
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/coupons")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingCoupon({
                amountOff: 1,
                duration: "duration",
                durationInMonths: 1,
                externalId: "external_id",
                maxRedemptions: 1,
                name: "name",
                percentOff: 1.1,
                timesRedeemed: 1,
            });
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("upsertBillingCoupon (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            amount_off: 1,
            duration: "duration",
            duration_in_months: 1,
            external_id: "external_id",
            max_redemptions: 1,
            name: "name",
            percent_off: 1.1,
            times_redeemed: 1,
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/coupons")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingCoupon({
                amountOff: 1,
                duration: "duration",
                durationInMonths: 1,
                externalId: "external_id",
                maxRedemptions: 1,
                name: "name",
                percentOff: 1.1,
                timesRedeemed: 1,
            });
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("upsertBillingCoupon (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            amount_off: 1,
            duration: "duration",
            duration_in_months: 1,
            external_id: "external_id",
            max_redemptions: 1,
            name: "name",
            percent_off: 1.1,
            times_redeemed: 1,
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/coupons")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingCoupon({
                amountOff: 1,
                duration: "duration",
                durationInMonths: 1,
                externalId: "external_id",
                maxRedemptions: 1,
                name: "name",
                percentOff: 1.1,
                timesRedeemed: 1,
            });
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("upsertBillingCoupon (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            amount_off: 1,
            duration: "duration",
            duration_in_months: 1,
            external_id: "external_id",
            max_redemptions: 1,
            name: "name",
            percent_off: 1.1,
            times_redeemed: 1,
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/coupons")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingCoupon({
                amountOff: 1,
                duration: "duration",
                durationInMonths: 1,
                externalId: "external_id",
                maxRedemptions: 1,
                name: "name",
                percentOff: 1.1,
                timesRedeemed: 1,
            });
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("upsertBillingCustomer (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            email: "email",
            external_id: "external_id",
            failed_to_import: true,
            meta: { key: "value" },
            name: "name",
        };
        const rawResponseBody = {
            data: {
                company_id: "company_id",
                deleted_at: "2024-01-15T09:30:00Z",
                email: "email",
                external_id: "external_id",
                failed_to_import: true,
                id: "id",
                name: "name",
                updated_at: "2024-01-15T09:30:00Z",
            },
            params: { key: "value" },
        };
        server
            .mockEndpoint()
            .post("/billing/customer/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.billing.upsertBillingCustomer({
            email: "email",
            externalId: "external_id",
            failedToImport: true,
            meta: {
                key: "value",
            },
            name: "name",
        });
        expect(response).toEqual({
            data: {
                companyId: "company_id",
                deletedAt: new Date("2024-01-15T09:30:00.000Z"),
                email: "email",
                externalId: "external_id",
                failedToImport: true,
                id: "id",
                name: "name",
                updatedAt: new Date("2024-01-15T09:30:00.000Z"),
            },
            params: {
                key: "value",
            },
        });
    });

    test("upsertBillingCustomer (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            email: "email",
            external_id: "external_id",
            failed_to_import: true,
            meta: { meta: "meta" },
            name: "name",
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/customer/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingCustomer({
                email: "email",
                externalId: "external_id",
                failedToImport: true,
                meta: {
                    meta: "meta",
                },
                name: "name",
            });
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("upsertBillingCustomer (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            email: "email",
            external_id: "external_id",
            failed_to_import: true,
            meta: { meta: "meta" },
            name: "name",
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/customer/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingCustomer({
                email: "email",
                externalId: "external_id",
                failedToImport: true,
                meta: {
                    meta: "meta",
                },
                name: "name",
            });
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("upsertBillingCustomer (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            email: "email",
            external_id: "external_id",
            failed_to_import: true,
            meta: { meta: "meta" },
            name: "name",
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/customer/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingCustomer({
                email: "email",
                externalId: "external_id",
                failedToImport: true,
                meta: {
                    meta: "meta",
                },
                name: "name",
            });
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("upsertBillingCustomer (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            email: "email",
            external_id: "external_id",
            failed_to_import: true,
            meta: { meta: "meta" },
            name: "name",
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/customer/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingCustomer({
                email: "email",
                externalId: "external_id",
                failedToImport: true,
                meta: {
                    meta: "meta",
                },
                name: "name",
            });
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("upsertBillingCustomer (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            email: "email",
            external_id: "external_id",
            failed_to_import: true,
            meta: { meta: "meta" },
            name: "name",
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/customer/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingCustomer({
                email: "email",
                externalId: "external_id",
                failedToImport: true,
                meta: {
                    meta: "meta",
                },
                name: "name",
            });
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("listCustomersWithSubscriptions (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            data: [
                {
                    company_id: "company_id",
                    deleted_at: "2024-01-15T09:30:00Z",
                    email: "email",
                    external_id: "external_id",
                    failed_to_import: true,
                    id: "id",
                    name: "name",
                    subscriptions: [
                        {
                            currency: "currency",
                            interval: "interval",
                            metered_usage: true,
                            per_unit_price: 1,
                            total_price: 1,
                        },
                    ],
                    updated_at: "2024-01-15T09:30:00Z",
                },
            ],
            params: { company_ids: ["company_ids"], failed_to_import: true, limit: 1, name: "name", offset: 1, q: "q" },
        };
        server.mockEndpoint().get("/billing/customers").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.billing.listCustomersWithSubscriptions({
            name: "name",
            failedToImport: true,
            q: "q",
            limit: 1,
            offset: 1,
        });
        expect(response).toEqual({
            data: [
                {
                    companyId: "company_id",
                    deletedAt: new Date("2024-01-15T09:30:00.000Z"),
                    email: "email",
                    externalId: "external_id",
                    failedToImport: true,
                    id: "id",
                    name: "name",
                    subscriptions: [
                        {
                            currency: "currency",
                            interval: "interval",
                            meteredUsage: true,
                            perUnitPrice: 1,
                            totalPrice: 1,
                        },
                    ],
                    updatedAt: new Date("2024-01-15T09:30:00.000Z"),
                },
            ],
            params: {
                companyIds: ["company_ids"],
                failedToImport: true,
                limit: 1,
                name: "name",
                offset: 1,
                q: "q",
            },
        });
    });

    test("listCustomersWithSubscriptions (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/customers").respondWith().statusCode(400).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.listCustomersWithSubscriptions();
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("listCustomersWithSubscriptions (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/customers").respondWith().statusCode(401).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.listCustomersWithSubscriptions();
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("listCustomersWithSubscriptions (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/customers").respondWith().statusCode(403).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.listCustomersWithSubscriptions();
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("listCustomersWithSubscriptions (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/customers").respondWith().statusCode(404).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.listCustomersWithSubscriptions();
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("listCustomersWithSubscriptions (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/customers").respondWith().statusCode(500).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.listCustomersWithSubscriptions();
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("countCustomers (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            data: { count: 1 },
            params: { company_ids: ["company_ids"], failed_to_import: true, limit: 1, name: "name", offset: 1, q: "q" },
        };
        server
            .mockEndpoint()
            .get("/billing/customers/count")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.billing.countCustomers({
            name: "name",
            failedToImport: true,
            q: "q",
            limit: 1,
            offset: 1,
        });
        expect(response).toEqual({
            data: {
                count: 1,
            },
            params: {
                companyIds: ["company_ids"],
                failedToImport: true,
                limit: 1,
                name: "name",
                offset: 1,
                q: "q",
            },
        });
    });

    test("countCustomers (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/customers/count")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.countCustomers();
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("countCustomers (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/customers/count")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.countCustomers();
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("countCustomers (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/customers/count")
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.countCustomers();
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("countCustomers (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/customers/count")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.countCustomers();
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("countCustomers (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/customers/count")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.countCustomers();
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("listInvoices (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            data: [
                {
                    amount_due: 1,
                    amount_paid: 1,
                    amount_remaining: 1,
                    collection_method: "collection_method",
                    company_id: "company_id",
                    created_at: "2024-01-15T09:30:00Z",
                    currency: "currency",
                    customer_external_id: "customer_external_id",
                    due_date: "2024-01-15T09:30:00Z",
                    environment_id: "environment_id",
                    external_id: "external_id",
                    id: "id",
                    payment_method_external_id: "payment_method_external_id",
                    subscription_external_id: "subscription_external_id",
                    subtotal: 1,
                    updated_at: "2024-01-15T09:30:00Z",
                    url: "url",
                },
            ],
            params: {
                company_id: "company_id",
                customer_external_id: "customer_external_id",
                limit: 1,
                offset: 1,
                subscription_external_id: "subscription_external_id",
            },
        };
        server.mockEndpoint().get("/billing/invoices").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.billing.listInvoices({
            companyId: "company_id",
            customerExternalId: "customer_external_id",
            subscriptionExternalId: "subscription_external_id",
            limit: 1,
            offset: 1,
        });
        expect(response).toEqual({
            data: [
                {
                    amountDue: 1,
                    amountPaid: 1,
                    amountRemaining: 1,
                    collectionMethod: "collection_method",
                    companyId: "company_id",
                    createdAt: new Date("2024-01-15T09:30:00.000Z"),
                    currency: "currency",
                    customerExternalId: "customer_external_id",
                    dueDate: new Date("2024-01-15T09:30:00.000Z"),
                    environmentId: "environment_id",
                    externalId: "external_id",
                    id: "id",
                    paymentMethodExternalId: "payment_method_external_id",
                    subscriptionExternalId: "subscription_external_id",
                    subtotal: 1,
                    updatedAt: new Date("2024-01-15T09:30:00.000Z"),
                    url: "url",
                },
            ],
            params: {
                companyId: "company_id",
                customerExternalId: "customer_external_id",
                limit: 1,
                offset: 1,
                subscriptionExternalId: "subscription_external_id",
            },
        });
    });

    test("listInvoices (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/invoices").respondWith().statusCode(400).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.listInvoices({
                customerExternalId: "customer_external_id",
                subscriptionExternalId: "subscription_external_id",
            });
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("listInvoices (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/invoices").respondWith().statusCode(401).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.listInvoices({
                customerExternalId: "customer_external_id",
                subscriptionExternalId: "subscription_external_id",
            });
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("listInvoices (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/invoices").respondWith().statusCode(403).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.listInvoices({
                customerExternalId: "customer_external_id",
                subscriptionExternalId: "subscription_external_id",
            });
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("listInvoices (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/invoices").respondWith().statusCode(404).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.listInvoices({
                customerExternalId: "customer_external_id",
                subscriptionExternalId: "subscription_external_id",
            });
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("listInvoices (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/invoices").respondWith().statusCode(500).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.listInvoices({
                customerExternalId: "customer_external_id",
                subscriptionExternalId: "subscription_external_id",
            });
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("upsertInvoice (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            amount_due: 1,
            amount_paid: 1,
            amount_remaining: 1,
            collection_method: "collection_method",
            currency: "currency",
            customer_external_id: "customer_external_id",
            subtotal: 1,
        };
        const rawResponseBody = {
            data: {
                amount_due: 1,
                amount_paid: 1,
                amount_remaining: 1,
                collection_method: "collection_method",
                company_id: "company_id",
                created_at: "2024-01-15T09:30:00Z",
                currency: "currency",
                customer_external_id: "customer_external_id",
                due_date: "2024-01-15T09:30:00Z",
                environment_id: "environment_id",
                external_id: "external_id",
                id: "id",
                payment_method_external_id: "payment_method_external_id",
                subscription_external_id: "subscription_external_id",
                subtotal: 1,
                updated_at: "2024-01-15T09:30:00Z",
                url: "url",
            },
            params: { key: "value" },
        };
        server
            .mockEndpoint()
            .post("/billing/invoices")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.billing.upsertInvoice({
            amountDue: 1,
            amountPaid: 1,
            amountRemaining: 1,
            collectionMethod: "collection_method",
            currency: "currency",
            customerExternalId: "customer_external_id",
            subtotal: 1,
        });
        expect(response).toEqual({
            data: {
                amountDue: 1,
                amountPaid: 1,
                amountRemaining: 1,
                collectionMethod: "collection_method",
                companyId: "company_id",
                createdAt: new Date("2024-01-15T09:30:00.000Z"),
                currency: "currency",
                customerExternalId: "customer_external_id",
                dueDate: new Date("2024-01-15T09:30:00.000Z"),
                environmentId: "environment_id",
                externalId: "external_id",
                id: "id",
                paymentMethodExternalId: "payment_method_external_id",
                subscriptionExternalId: "subscription_external_id",
                subtotal: 1,
                updatedAt: new Date("2024-01-15T09:30:00.000Z"),
                url: "url",
            },
            params: {
                key: "value",
            },
        });
    });

    test("upsertInvoice (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            amount_due: 1,
            amount_paid: 1,
            amount_remaining: 1,
            collection_method: "collection_method",
            currency: "currency",
            customer_external_id: "customer_external_id",
            subtotal: 1,
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/invoices")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertInvoice({
                amountDue: 1,
                amountPaid: 1,
                amountRemaining: 1,
                collectionMethod: "collection_method",
                currency: "currency",
                customerExternalId: "customer_external_id",
                subtotal: 1,
            });
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("upsertInvoice (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            amount_due: 1,
            amount_paid: 1,
            amount_remaining: 1,
            collection_method: "collection_method",
            currency: "currency",
            customer_external_id: "customer_external_id",
            subtotal: 1,
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/invoices")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertInvoice({
                amountDue: 1,
                amountPaid: 1,
                amountRemaining: 1,
                collectionMethod: "collection_method",
                currency: "currency",
                customerExternalId: "customer_external_id",
                subtotal: 1,
            });
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("upsertInvoice (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            amount_due: 1,
            amount_paid: 1,
            amount_remaining: 1,
            collection_method: "collection_method",
            currency: "currency",
            customer_external_id: "customer_external_id",
            subtotal: 1,
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/invoices")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertInvoice({
                amountDue: 1,
                amountPaid: 1,
                amountRemaining: 1,
                collectionMethod: "collection_method",
                currency: "currency",
                customerExternalId: "customer_external_id",
                subtotal: 1,
            });
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("upsertInvoice (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            amount_due: 1,
            amount_paid: 1,
            amount_remaining: 1,
            collection_method: "collection_method",
            currency: "currency",
            customer_external_id: "customer_external_id",
            subtotal: 1,
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/invoices")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertInvoice({
                amountDue: 1,
                amountPaid: 1,
                amountRemaining: 1,
                collectionMethod: "collection_method",
                currency: "currency",
                customerExternalId: "customer_external_id",
                subtotal: 1,
            });
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("upsertInvoice (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            amount_due: 1,
            amount_paid: 1,
            amount_remaining: 1,
            collection_method: "collection_method",
            currency: "currency",
            customer_external_id: "customer_external_id",
            subtotal: 1,
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/invoices")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertInvoice({
                amountDue: 1,
                amountPaid: 1,
                amountRemaining: 1,
                collectionMethod: "collection_method",
                currency: "currency",
                customerExternalId: "customer_external_id",
                subtotal: 1,
            });
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("listMeters (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            data: [
                {
                    dispaly_name: "dispaly_name",
                    event_name: "event_name",
                    event_payload_key: "event_payload_key",
                    external_price_id: "external_price_id",
                    id: "id",
                },
            ],
            params: { display_name: "display_name", limit: 1, offset: 1 },
        };
        server.mockEndpoint().get("/billing/meter").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.billing.listMeters({
            displayName: "display_name",
            limit: 1,
            offset: 1,
        });
        expect(response).toEqual({
            data: [
                {
                    dispalyName: "dispaly_name",
                    eventName: "event_name",
                    eventPayloadKey: "event_payload_key",
                    externalPriceId: "external_price_id",
                    id: "id",
                },
            ],
            params: {
                displayName: "display_name",
                limit: 1,
                offset: 1,
            },
        });
    });

    test("listMeters (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/meter").respondWith().statusCode(400).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.listMeters();
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("listMeters (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/meter").respondWith().statusCode(401).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.listMeters();
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("listMeters (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/meter").respondWith().statusCode(403).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.listMeters();
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("listMeters (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/meter").respondWith().statusCode(404).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.listMeters();
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("listMeters (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/meter").respondWith().statusCode(500).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.listMeters();
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("upsertBillingMeter (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            display_name: "display_name",
            event_name: "event_name",
            event_payload_key: "event_payload_key",
            external_id: "external_id",
        };
        const rawResponseBody = {
            data: {
                dispaly_name: "dispaly_name",
                event_name: "event_name",
                event_payload_key: "event_payload_key",
                external_price_id: "external_price_id",
                id: "id",
            },
            params: { key: "value" },
        };
        server
            .mockEndpoint()
            .post("/billing/meter/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.billing.upsertBillingMeter({
            displayName: "display_name",
            eventName: "event_name",
            eventPayloadKey: "event_payload_key",
            externalId: "external_id",
        });
        expect(response).toEqual({
            data: {
                dispalyName: "dispaly_name",
                eventName: "event_name",
                eventPayloadKey: "event_payload_key",
                externalPriceId: "external_price_id",
                id: "id",
            },
            params: {
                key: "value",
            },
        });
    });

    test("upsertBillingMeter (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            display_name: "display_name",
            event_name: "event_name",
            event_payload_key: "event_payload_key",
            external_id: "external_id",
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/meter/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingMeter({
                displayName: "display_name",
                eventName: "event_name",
                eventPayloadKey: "event_payload_key",
                externalId: "external_id",
            });
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("upsertBillingMeter (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            display_name: "display_name",
            event_name: "event_name",
            event_payload_key: "event_payload_key",
            external_id: "external_id",
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/meter/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingMeter({
                displayName: "display_name",
                eventName: "event_name",
                eventPayloadKey: "event_payload_key",
                externalId: "external_id",
            });
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("upsertBillingMeter (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            display_name: "display_name",
            event_name: "event_name",
            event_payload_key: "event_payload_key",
            external_id: "external_id",
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/meter/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingMeter({
                displayName: "display_name",
                eventName: "event_name",
                eventPayloadKey: "event_payload_key",
                externalId: "external_id",
            });
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("upsertBillingMeter (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            display_name: "display_name",
            event_name: "event_name",
            event_payload_key: "event_payload_key",
            external_id: "external_id",
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/meter/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingMeter({
                displayName: "display_name",
                eventName: "event_name",
                eventPayloadKey: "event_payload_key",
                externalId: "external_id",
            });
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("upsertBillingMeter (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            display_name: "display_name",
            event_name: "event_name",
            event_payload_key: "event_payload_key",
            external_id: "external_id",
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/meter/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingMeter({
                displayName: "display_name",
                eventName: "event_name",
                eventPayloadKey: "event_payload_key",
                externalId: "external_id",
            });
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("listPaymentMethods (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            data: [
                {
                    account_last4: "account_last4",
                    account_name: "account_name",
                    bank_name: "bank_name",
                    billing_email: "billing_email",
                    billing_name: "billing_name",
                    card_brand: "card_brand",
                    card_exp_month: 1,
                    card_exp_year: 1,
                    card_last4: "card_last4",
                    company_id: "company_id",
                    created_at: "2024-01-15T09:30:00Z",
                    customer_external_id: "customer_external_id",
                    environment_id: "environment_id",
                    external_id: "external_id",
                    id: "id",
                    payment_method_type: "payment_method_type",
                    updated_at: "2024-01-15T09:30:00Z",
                },
            ],
            params: { company_id: "company_id", customer_external_id: "customer_external_id", limit: 1, offset: 1 },
        };
        server
            .mockEndpoint()
            .get("/billing/payment-methods")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.billing.listPaymentMethods({
            companyId: "company_id",
            customerExternalId: "customer_external_id",
            limit: 1,
            offset: 1,
        });
        expect(response).toEqual({
            data: [
                {
                    accountLast4: "account_last4",
                    accountName: "account_name",
                    bankName: "bank_name",
                    billingEmail: "billing_email",
                    billingName: "billing_name",
                    cardBrand: "card_brand",
                    cardExpMonth: 1,
                    cardExpYear: 1,
                    cardLast4: "card_last4",
                    companyId: "company_id",
                    createdAt: new Date("2024-01-15T09:30:00.000Z"),
                    customerExternalId: "customer_external_id",
                    environmentId: "environment_id",
                    externalId: "external_id",
                    id: "id",
                    paymentMethodType: "payment_method_type",
                    updatedAt: new Date("2024-01-15T09:30:00.000Z"),
                },
            ],
            params: {
                companyId: "company_id",
                customerExternalId: "customer_external_id",
                limit: 1,
                offset: 1,
            },
        });
    });

    test("listPaymentMethods (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/payment-methods")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.listPaymentMethods({
                customerExternalId: "customer_external_id",
            });
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("listPaymentMethods (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/payment-methods")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.listPaymentMethods({
                customerExternalId: "customer_external_id",
            });
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("listPaymentMethods (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/payment-methods")
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.listPaymentMethods({
                customerExternalId: "customer_external_id",
            });
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("listPaymentMethods (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/payment-methods")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.listPaymentMethods({
                customerExternalId: "customer_external_id",
            });
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("listPaymentMethods (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/payment-methods")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.listPaymentMethods({
                customerExternalId: "customer_external_id",
            });
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("upsertPaymentMethod (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            customer_external_id: "customer_external_id",
            external_id: "external_id",
            payment_method_type: "payment_method_type",
        };
        const rawResponseBody = {
            data: {
                account_last4: "account_last4",
                account_name: "account_name",
                bank_name: "bank_name",
                billing_email: "billing_email",
                billing_name: "billing_name",
                card_brand: "card_brand",
                card_exp_month: 1,
                card_exp_year: 1,
                card_last4: "card_last4",
                company_id: "company_id",
                created_at: "2024-01-15T09:30:00Z",
                customer_external_id: "customer_external_id",
                environment_id: "environment_id",
                external_id: "external_id",
                id: "id",
                payment_method_type: "payment_method_type",
                updated_at: "2024-01-15T09:30:00Z",
            },
            params: { key: "value" },
        };
        server
            .mockEndpoint()
            .post("/billing/payment-methods")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.billing.upsertPaymentMethod({
            customerExternalId: "customer_external_id",
            externalId: "external_id",
            paymentMethodType: "payment_method_type",
        });
        expect(response).toEqual({
            data: {
                accountLast4: "account_last4",
                accountName: "account_name",
                bankName: "bank_name",
                billingEmail: "billing_email",
                billingName: "billing_name",
                cardBrand: "card_brand",
                cardExpMonth: 1,
                cardExpYear: 1,
                cardLast4: "card_last4",
                companyId: "company_id",
                createdAt: new Date("2024-01-15T09:30:00.000Z"),
                customerExternalId: "customer_external_id",
                environmentId: "environment_id",
                externalId: "external_id",
                id: "id",
                paymentMethodType: "payment_method_type",
                updatedAt: new Date("2024-01-15T09:30:00.000Z"),
            },
            params: {
                key: "value",
            },
        });
    });

    test("upsertPaymentMethod (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            customer_external_id: "customer_external_id",
            external_id: "external_id",
            payment_method_type: "payment_method_type",
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/payment-methods")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertPaymentMethod({
                customerExternalId: "customer_external_id",
                externalId: "external_id",
                paymentMethodType: "payment_method_type",
            });
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("upsertPaymentMethod (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            customer_external_id: "customer_external_id",
            external_id: "external_id",
            payment_method_type: "payment_method_type",
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/payment-methods")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertPaymentMethod({
                customerExternalId: "customer_external_id",
                externalId: "external_id",
                paymentMethodType: "payment_method_type",
            });
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("upsertPaymentMethod (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            customer_external_id: "customer_external_id",
            external_id: "external_id",
            payment_method_type: "payment_method_type",
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/payment-methods")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertPaymentMethod({
                customerExternalId: "customer_external_id",
                externalId: "external_id",
                paymentMethodType: "payment_method_type",
            });
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("upsertPaymentMethod (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            customer_external_id: "customer_external_id",
            external_id: "external_id",
            payment_method_type: "payment_method_type",
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/payment-methods")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertPaymentMethod({
                customerExternalId: "customer_external_id",
                externalId: "external_id",
                paymentMethodType: "payment_method_type",
            });
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("upsertPaymentMethod (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            customer_external_id: "customer_external_id",
            external_id: "external_id",
            payment_method_type: "payment_method_type",
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/payment-methods")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertPaymentMethod({
                customerExternalId: "customer_external_id",
                externalId: "external_id",
                paymentMethodType: "payment_method_type",
            });
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("listBillingPrices (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            data: [
                {
                    billing_scheme: "per_unit",
                    created_at: "2024-01-15T09:30:00Z",
                    currency: "currency",
                    id: "id",
                    interval: "day",
                    is_active: true,
                    meter_event_name: "meter_event_name",
                    meter_event_payload_key: "meter_event_payload_key",
                    meter_id: "meter_id",
                    package_size: 1,
                    price: 1,
                    price_decimal: "price_decimal",
                    price_external_id: "price_external_id",
                    price_id: "price_id",
                    price_tier: [{}],
                    product_external_id: "product_external_id",
                    product_id: "product_id",
                    product_name: "product_name",
                    tiers_mode: "graduated",
                    updated_at: "2024-01-15T09:30:00Z",
                    usage_type: "licensed",
                },
            ],
            params: {
                for_initial_plan: true,
                for_trial_expiry_plan: true,
                ids: ["ids"],
                interval: "interval",
                is_active: true,
                limit: 1,
                offset: 1,
                price: 1,
                product_id: "product_id",
                product_ids: ["product_ids"],
                q: "q",
                tiers_mode: "graduated",
                usage_type: "licensed",
                with_meter: true,
            },
        };
        server.mockEndpoint().get("/billing/price").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.billing.listBillingPrices({
            forInitialPlan: true,
            forTrialExpiryPlan: true,
            interval: "interval",
            isActive: true,
            price: 1,
            productId: "product_id",
            q: "q",
            tiersMode: "graduated",
            usageType: "licensed",
            withMeter: true,
            limit: 1,
            offset: 1,
        });
        expect(response).toEqual({
            data: [
                {
                    billingScheme: "per_unit",
                    createdAt: new Date("2024-01-15T09:30:00.000Z"),
                    currency: "currency",
                    id: "id",
                    interval: "day",
                    isActive: true,
                    meterEventName: "meter_event_name",
                    meterEventPayloadKey: "meter_event_payload_key",
                    meterId: "meter_id",
                    packageSize: 1,
                    price: 1,
                    priceDecimal: "price_decimal",
                    priceExternalId: "price_external_id",
                    priceId: "price_id",
                    priceTier: [{}],
                    productExternalId: "product_external_id",
                    productId: "product_id",
                    productName: "product_name",
                    tiersMode: "graduated",
                    updatedAt: new Date("2024-01-15T09:30:00.000Z"),
                    usageType: "licensed",
                },
            ],
            params: {
                forInitialPlan: true,
                forTrialExpiryPlan: true,
                ids: ["ids"],
                interval: "interval",
                isActive: true,
                limit: 1,
                offset: 1,
                price: 1,
                productId: "product_id",
                productIds: ["product_ids"],
                q: "q",
                tiersMode: "graduated",
                usageType: "licensed",
                withMeter: true,
            },
        });
    });

    test("listBillingPrices (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/price").respondWith().statusCode(400).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.listBillingPrices();
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("listBillingPrices (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/price").respondWith().statusCode(401).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.listBillingPrices();
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("listBillingPrices (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/price").respondWith().statusCode(403).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.listBillingPrices();
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("listBillingPrices (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/price").respondWith().statusCode(404).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.listBillingPrices();
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("listBillingPrices (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/price").respondWith().statusCode(500).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.listBillingPrices();
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("upsertBillingPrice (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            billing_scheme: "per_unit",
            currency: "currency",
            external_account_id: "external_account_id",
            interval: "interval",
            is_active: true,
            price: 1,
            price_external_id: "price_external_id",
            price_tiers: [{ price_external_id: "price_external_id" }],
            product_external_id: "product_external_id",
            usage_type: "licensed",
        };
        const rawResponseBody = {
            data: {
                currency: "currency",
                external_price_id: "external_price_id",
                id: "id",
                interval: "day",
                price: 1,
                price_decimal: "price_decimal",
                scheme: "per_unit",
            },
            params: { key: "value" },
        };
        server
            .mockEndpoint()
            .post("/billing/price/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.billing.upsertBillingPrice({
            billingScheme: "per_unit",
            currency: "currency",
            externalAccountId: "external_account_id",
            interval: "interval",
            isActive: true,
            price: 1,
            priceExternalId: "price_external_id",
            priceTiers: [
                {
                    priceExternalId: "price_external_id",
                },
            ],
            productExternalId: "product_external_id",
            usageType: "licensed",
        });
        expect(response).toEqual({
            data: {
                currency: "currency",
                externalPriceId: "external_price_id",
                id: "id",
                interval: "day",
                price: 1,
                priceDecimal: "price_decimal",
                scheme: "per_unit",
            },
            params: {
                key: "value",
            },
        });
    });

    test("upsertBillingPrice (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            billing_scheme: "per_unit",
            currency: "currency",
            external_account_id: "external_account_id",
            interval: "interval",
            is_active: true,
            price: 1,
            price_external_id: "price_external_id",
            price_tiers: [{ price_external_id: "price_external_id" }, { price_external_id: "price_external_id" }],
            product_external_id: "product_external_id",
            usage_type: "licensed",
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/price/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingPrice({
                billingScheme: "per_unit",
                currency: "currency",
                externalAccountId: "external_account_id",
                interval: "interval",
                isActive: true,
                price: 1,
                priceExternalId: "price_external_id",
                priceTiers: [
                    {
                        priceExternalId: "price_external_id",
                    },
                    {
                        priceExternalId: "price_external_id",
                    },
                ],
                productExternalId: "product_external_id",
                usageType: "licensed",
            });
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("upsertBillingPrice (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            billing_scheme: "per_unit",
            currency: "currency",
            external_account_id: "external_account_id",
            interval: "interval",
            is_active: true,
            price: 1,
            price_external_id: "price_external_id",
            price_tiers: [{ price_external_id: "price_external_id" }, { price_external_id: "price_external_id" }],
            product_external_id: "product_external_id",
            usage_type: "licensed",
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/price/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingPrice({
                billingScheme: "per_unit",
                currency: "currency",
                externalAccountId: "external_account_id",
                interval: "interval",
                isActive: true,
                price: 1,
                priceExternalId: "price_external_id",
                priceTiers: [
                    {
                        priceExternalId: "price_external_id",
                    },
                    {
                        priceExternalId: "price_external_id",
                    },
                ],
                productExternalId: "product_external_id",
                usageType: "licensed",
            });
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("upsertBillingPrice (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            billing_scheme: "per_unit",
            currency: "currency",
            external_account_id: "external_account_id",
            interval: "interval",
            is_active: true,
            price: 1,
            price_external_id: "price_external_id",
            price_tiers: [{ price_external_id: "price_external_id" }, { price_external_id: "price_external_id" }],
            product_external_id: "product_external_id",
            usage_type: "licensed",
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/price/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingPrice({
                billingScheme: "per_unit",
                currency: "currency",
                externalAccountId: "external_account_id",
                interval: "interval",
                isActive: true,
                price: 1,
                priceExternalId: "price_external_id",
                priceTiers: [
                    {
                        priceExternalId: "price_external_id",
                    },
                    {
                        priceExternalId: "price_external_id",
                    },
                ],
                productExternalId: "product_external_id",
                usageType: "licensed",
            });
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("upsertBillingPrice (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            billing_scheme: "per_unit",
            currency: "currency",
            external_account_id: "external_account_id",
            interval: "interval",
            is_active: true,
            price: 1,
            price_external_id: "price_external_id",
            price_tiers: [{ price_external_id: "price_external_id" }, { price_external_id: "price_external_id" }],
            product_external_id: "product_external_id",
            usage_type: "licensed",
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/price/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingPrice({
                billingScheme: "per_unit",
                currency: "currency",
                externalAccountId: "external_account_id",
                interval: "interval",
                isActive: true,
                price: 1,
                priceExternalId: "price_external_id",
                priceTiers: [
                    {
                        priceExternalId: "price_external_id",
                    },
                    {
                        priceExternalId: "price_external_id",
                    },
                ],
                productExternalId: "product_external_id",
                usageType: "licensed",
            });
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("upsertBillingPrice (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            billing_scheme: "per_unit",
            currency: "currency",
            external_account_id: "external_account_id",
            interval: "interval",
            is_active: true,
            price: 1,
            price_external_id: "price_external_id",
            price_tiers: [{ price_external_id: "price_external_id" }, { price_external_id: "price_external_id" }],
            product_external_id: "product_external_id",
            usage_type: "licensed",
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/price/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingPrice({
                billingScheme: "per_unit",
                currency: "currency",
                externalAccountId: "external_account_id",
                interval: "interval",
                isActive: true,
                price: 1,
                priceExternalId: "price_external_id",
                priceTiers: [
                    {
                        priceExternalId: "price_external_id",
                    },
                    {
                        priceExternalId: "price_external_id",
                    },
                ],
                productExternalId: "product_external_id",
                usageType: "licensed",
            });
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("deleteBillingProduct (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { data: { deleted: true }, params: { key: "value" } };
        server
            .mockEndpoint()
            .delete("/billing/product/billing_id")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.billing.deleteBillingProduct("billing_id");
        expect(response).toEqual({
            data: {
                deleted: true,
            },
            params: {
                key: "value",
            },
        });
    });

    test("deleteBillingProduct (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .delete("/billing/product/billing_id")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.deleteBillingProduct("billing_id");
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("deleteBillingProduct (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .delete("/billing/product/billing_id")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.deleteBillingProduct("billing_id");
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("deleteBillingProduct (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .delete("/billing/product/billing_id")
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.deleteBillingProduct("billing_id");
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("deleteBillingProduct (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .delete("/billing/product/billing_id")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.deleteBillingProduct("billing_id");
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("deleteBillingProduct (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .delete("/billing/product/billing_id")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.deleteBillingProduct("billing_id");
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("listBillingProductPrices (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            data: [
                {
                    billing_scheme: "per_unit",
                    created_at: "2024-01-15T09:30:00Z",
                    currency: "currency",
                    id: "id",
                    interval: "day",
                    is_active: true,
                    meter_event_name: "meter_event_name",
                    meter_event_payload_key: "meter_event_payload_key",
                    meter_id: "meter_id",
                    package_size: 1,
                    price: 1,
                    price_decimal: "price_decimal",
                    price_external_id: "price_external_id",
                    price_id: "price_id",
                    price_tier: [{}],
                    product_external_id: "product_external_id",
                    product_id: "product_id",
                    product_name: "product_name",
                    tiers_mode: "graduated",
                    updated_at: "2024-01-15T09:30:00Z",
                    usage_type: "licensed",
                },
            ],
            params: {
                for_initial_plan: true,
                for_trial_expiry_plan: true,
                ids: ["ids"],
                interval: "interval",
                is_active: true,
                limit: 1,
                offset: 1,
                price: 1,
                product_id: "product_id",
                product_ids: ["product_ids"],
                q: "q",
                tiers_mode: "graduated",
                usage_type: "licensed",
                with_meter: true,
            },
        };
        server
            .mockEndpoint()
            .get("/billing/product/prices")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.billing.listBillingProductPrices({
            forInitialPlan: true,
            forTrialExpiryPlan: true,
            interval: "interval",
            isActive: true,
            price: 1,
            productId: "product_id",
            q: "q",
            tiersMode: "graduated",
            usageType: "licensed",
            withMeter: true,
            limit: 1,
            offset: 1,
        });
        expect(response).toEqual({
            data: [
                {
                    billingScheme: "per_unit",
                    createdAt: new Date("2024-01-15T09:30:00.000Z"),
                    currency: "currency",
                    id: "id",
                    interval: "day",
                    isActive: true,
                    meterEventName: "meter_event_name",
                    meterEventPayloadKey: "meter_event_payload_key",
                    meterId: "meter_id",
                    packageSize: 1,
                    price: 1,
                    priceDecimal: "price_decimal",
                    priceExternalId: "price_external_id",
                    priceId: "price_id",
                    priceTier: [{}],
                    productExternalId: "product_external_id",
                    productId: "product_id",
                    productName: "product_name",
                    tiersMode: "graduated",
                    updatedAt: new Date("2024-01-15T09:30:00.000Z"),
                    usageType: "licensed",
                },
            ],
            params: {
                forInitialPlan: true,
                forTrialExpiryPlan: true,
                ids: ["ids"],
                interval: "interval",
                isActive: true,
                limit: 1,
                offset: 1,
                price: 1,
                productId: "product_id",
                productIds: ["product_ids"],
                q: "q",
                tiersMode: "graduated",
                usageType: "licensed",
                withMeter: true,
            },
        });
    });

    test("listBillingProductPrices (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/product/prices")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.listBillingProductPrices();
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("listBillingProductPrices (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/product/prices")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.listBillingProductPrices();
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("listBillingProductPrices (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/product/prices")
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.listBillingProductPrices();
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("listBillingProductPrices (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/product/prices")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.listBillingProductPrices();
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("listBillingProductPrices (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/product/prices")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.listBillingProductPrices();
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("deleteProductPrice (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { data: { deleted: true }, params: { key: "value" } };
        server
            .mockEndpoint()
            .delete("/billing/product/prices/billing_id")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.billing.deleteProductPrice("billing_id");
        expect(response).toEqual({
            data: {
                deleted: true,
            },
            params: {
                key: "value",
            },
        });
    });

    test("deleteProductPrice (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .delete("/billing/product/prices/billing_id")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.deleteProductPrice("billing_id");
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("deleteProductPrice (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .delete("/billing/product/prices/billing_id")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.deleteProductPrice("billing_id");
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("deleteProductPrice (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .delete("/billing/product/prices/billing_id")
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.deleteProductPrice("billing_id");
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("deleteProductPrice (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .delete("/billing/product/prices/billing_id")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.deleteProductPrice("billing_id");
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("deleteProductPrice (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .delete("/billing/product/prices/billing_id")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.deleteProductPrice("billing_id");
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("upsertBillingProduct (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { external_id: "external_id", name: "name", price: 1.1 };
        const rawResponseBody = {
            data: {
                account_id: "account_id",
                created_at: "2024-01-15T09:30:00Z",
                environment_id: "environment_id",
                external_id: "external_id",
                is_active: true,
                name: "name",
                price: 1.1,
                price_decimal: "price_decimal",
                product_id: "product_id",
                quantity: 1.1,
                updated_at: "2024-01-15T09:30:00Z",
            },
            params: { key: "value" },
        };
        server
            .mockEndpoint()
            .post("/billing/product/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.billing.upsertBillingProduct({
            externalId: "external_id",
            name: "name",
            price: 1.1,
        });
        expect(response).toEqual({
            data: {
                accountId: "account_id",
                createdAt: new Date("2024-01-15T09:30:00.000Z"),
                environmentId: "environment_id",
                externalId: "external_id",
                isActive: true,
                name: "name",
                price: 1.1,
                priceDecimal: "price_decimal",
                productId: "product_id",
                quantity: 1.1,
                updatedAt: new Date("2024-01-15T09:30:00.000Z"),
            },
            params: {
                key: "value",
            },
        });
    });

    test("upsertBillingProduct (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { external_id: "external_id", name: "name", price: 1.1 };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/product/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingProduct({
                externalId: "external_id",
                name: "name",
                price: 1.1,
            });
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("upsertBillingProduct (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { external_id: "external_id", name: "name", price: 1.1 };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/product/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingProduct({
                externalId: "external_id",
                name: "name",
                price: 1.1,
            });
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("upsertBillingProduct (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { external_id: "external_id", name: "name", price: 1.1 };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/product/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingProduct({
                externalId: "external_id",
                name: "name",
                price: 1.1,
            });
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("upsertBillingProduct (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { external_id: "external_id", name: "name", price: 1.1 };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/product/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingProduct({
                externalId: "external_id",
                name: "name",
                price: 1.1,
            });
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("upsertBillingProduct (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { external_id: "external_id", name: "name", price: 1.1 };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/product/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingProduct({
                externalId: "external_id",
                name: "name",
                price: 1.1,
            });
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("listBillingProducts (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            data: [
                {
                    account_id: "account_id",
                    created_at: "2024-01-15T09:30:00Z",
                    environment_id: "environment_id",
                    external_id: "external_id",
                    is_active: true,
                    name: "name",
                    price: 1.1,
                    price_decimal: "price_decimal",
                    prices: [
                        {
                            currency: "currency",
                            external_price_id: "external_price_id",
                            id: "id",
                            interval: "day",
                            price: 1,
                            scheme: "per_unit",
                        },
                    ],
                    product_id: "product_id",
                    quantity: 1.1,
                    subscription_count: 1,
                    updated_at: "2024-01-15T09:30:00Z",
                },
            ],
            params: {
                ids: ["ids"],
                is_active: true,
                limit: 1,
                name: "name",
                offset: 1,
                price_usage_type: "licensed",
                q: "q",
                with_one_time_charges: true,
                with_prices_only: true,
                with_zero_price: true,
                without_linked_to_plan: true,
            },
        };
        server.mockEndpoint().get("/billing/products").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.billing.listBillingProducts({
            name: "name",
            q: "q",
            priceUsageType: "licensed",
            withoutLinkedToPlan: true,
            withOneTimeCharges: true,
            withZeroPrice: true,
            withPricesOnly: true,
            isActive: true,
            limit: 1,
            offset: 1,
        });
        expect(response).toEqual({
            data: [
                {
                    accountId: "account_id",
                    createdAt: new Date("2024-01-15T09:30:00.000Z"),
                    environmentId: "environment_id",
                    externalId: "external_id",
                    isActive: true,
                    name: "name",
                    price: 1.1,
                    priceDecimal: "price_decimal",
                    prices: [
                        {
                            currency: "currency",
                            externalPriceId: "external_price_id",
                            id: "id",
                            interval: "day",
                            price: 1,
                            scheme: "per_unit",
                        },
                    ],
                    productId: "product_id",
                    quantity: 1.1,
                    subscriptionCount: 1,
                    updatedAt: new Date("2024-01-15T09:30:00.000Z"),
                },
            ],
            params: {
                ids: ["ids"],
                isActive: true,
                limit: 1,
                name: "name",
                offset: 1,
                priceUsageType: "licensed",
                q: "q",
                withOneTimeCharges: true,
                withPricesOnly: true,
                withZeroPrice: true,
                withoutLinkedToPlan: true,
            },
        });
    });

    test("listBillingProducts (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/products").respondWith().statusCode(400).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.listBillingProducts();
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("listBillingProducts (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/products").respondWith().statusCode(401).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.listBillingProducts();
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("listBillingProducts (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/products").respondWith().statusCode(403).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.listBillingProducts();
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("listBillingProducts (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/products").respondWith().statusCode(404).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.listBillingProducts();
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("listBillingProducts (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/products").respondWith().statusCode(500).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.billing.listBillingProducts();
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("countBillingProducts (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            data: { count: 1 },
            params: {
                ids: ["ids"],
                is_active: true,
                limit: 1,
                name: "name",
                offset: 1,
                price_usage_type: "licensed",
                q: "q",
                with_one_time_charges: true,
                with_prices_only: true,
                with_zero_price: true,
                without_linked_to_plan: true,
            },
        };
        server
            .mockEndpoint()
            .get("/billing/products/count")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.billing.countBillingProducts({
            name: "name",
            q: "q",
            priceUsageType: "licensed",
            withoutLinkedToPlan: true,
            withOneTimeCharges: true,
            withZeroPrice: true,
            withPricesOnly: true,
            isActive: true,
            limit: 1,
            offset: 1,
        });
        expect(response).toEqual({
            data: {
                count: 1,
            },
            params: {
                ids: ["ids"],
                isActive: true,
                limit: 1,
                name: "name",
                offset: 1,
                priceUsageType: "licensed",
                q: "q",
                withOneTimeCharges: true,
                withPricesOnly: true,
                withZeroPrice: true,
                withoutLinkedToPlan: true,
            },
        });
    });

    test("countBillingProducts (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/products/count")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.countBillingProducts();
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("countBillingProducts (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/products/count")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.countBillingProducts();
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("countBillingProducts (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/products/count")
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.countBillingProducts();
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("countBillingProducts (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/products/count")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.countBillingProducts();
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("countBillingProducts (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/products/count")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.countBillingProducts();
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("upsertBillingSubscription (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            cancel_at_period_end: true,
            currency: "currency",
            customer_external_id: "customer_external_id",
            discounts: [
                {
                    coupon_external_id: "coupon_external_id",
                    external_id: "external_id",
                    is_active: true,
                    started_at: "2024-01-15T09:30:00Z",
                },
            ],
            expired_at: "2024-01-15T09:30:00Z",
            product_external_ids: [
                {
                    currency: "currency",
                    interval: "interval",
                    price: 1,
                    price_external_id: "price_external_id",
                    product_external_id: "product_external_id",
                    quantity: 1,
                    usage_type: "licensed",
                },
            ],
            subscription_external_id: "subscription_external_id",
            total_price: 1,
        };
        const rawResponseBody = {
            data: {
                application_id: "application_id",
                cancel_at: 1,
                cancel_at_period_end: true,
                company_id: "company_id",
                created_at: "2024-01-15T09:30:00Z",
                currency: "currency",
                customer_external_id: "customer_external_id",
                default_payment_method_id: "default_payment_method_id",
                expired_at: "2024-01-15T09:30:00Z",
                id: "id",
                interval: "interval",
                metadata: { key: "value" },
                period_end: 1,
                period_start: 1,
                status: "status",
                subscription_external_id: "subscription_external_id",
                total_price: 1,
                trial_end: 1,
                trial_end_setting: "cancel",
            },
            params: { key: "value" },
        };
        server
            .mockEndpoint()
            .post("/billing/subscription/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.billing.upsertBillingSubscription({
            cancelAtPeriodEnd: true,
            currency: "currency",
            customerExternalId: "customer_external_id",
            discounts: [
                {
                    couponExternalId: "coupon_external_id",
                    externalId: "external_id",
                    isActive: true,
                    startedAt: new Date("2024-01-15T09:30:00.000Z"),
                },
            ],
            expiredAt: new Date("2024-01-15T09:30:00.000Z"),
            productExternalIds: [
                {
                    currency: "currency",
                    interval: "interval",
                    price: 1,
                    priceExternalId: "price_external_id",
                    productExternalId: "product_external_id",
                    quantity: 1,
                    usageType: "licensed",
                },
            ],
            subscriptionExternalId: "subscription_external_id",
            totalPrice: 1,
        });
        expect(response).toEqual({
            data: {
                applicationId: "application_id",
                cancelAt: 1,
                cancelAtPeriodEnd: true,
                companyId: "company_id",
                createdAt: new Date("2024-01-15T09:30:00.000Z"),
                currency: "currency",
                customerExternalId: "customer_external_id",
                defaultPaymentMethodId: "default_payment_method_id",
                expiredAt: new Date("2024-01-15T09:30:00.000Z"),
                id: "id",
                interval: "interval",
                metadata: {
                    key: "value",
                },
                periodEnd: 1,
                periodStart: 1,
                status: "status",
                subscriptionExternalId: "subscription_external_id",
                totalPrice: 1,
                trialEnd: 1,
                trialEndSetting: "cancel",
            },
            params: {
                key: "value",
            },
        });
    });

    test("upsertBillingSubscription (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            cancel_at_period_end: true,
            currency: "currency",
            customer_external_id: "customer_external_id",
            discounts: [
                {
                    coupon_external_id: "coupon_external_id",
                    external_id: "external_id",
                    is_active: true,
                    started_at: "2024-01-15T09:30:00Z",
                },
                {
                    coupon_external_id: "coupon_external_id",
                    external_id: "external_id",
                    is_active: true,
                    started_at: "2024-01-15T09:30:00Z",
                },
            ],
            expired_at: "2024-01-15T09:30:00Z",
            product_external_ids: [
                {
                    currency: "currency",
                    interval: "interval",
                    price: 1,
                    price_external_id: "price_external_id",
                    product_external_id: "product_external_id",
                    quantity: 1,
                    usage_type: "licensed",
                },
                {
                    currency: "currency",
                    interval: "interval",
                    price: 1,
                    price_external_id: "price_external_id",
                    product_external_id: "product_external_id",
                    quantity: 1,
                    usage_type: "licensed",
                },
            ],
            subscription_external_id: "subscription_external_id",
            total_price: 1,
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/subscription/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingSubscription({
                cancelAtPeriodEnd: true,
                currency: "currency",
                customerExternalId: "customer_external_id",
                discounts: [
                    {
                        couponExternalId: "coupon_external_id",
                        externalId: "external_id",
                        isActive: true,
                        startedAt: new Date("2024-01-15T09:30:00.000Z"),
                    },
                    {
                        couponExternalId: "coupon_external_id",
                        externalId: "external_id",
                        isActive: true,
                        startedAt: new Date("2024-01-15T09:30:00.000Z"),
                    },
                ],
                expiredAt: new Date("2024-01-15T09:30:00.000Z"),
                productExternalIds: [
                    {
                        currency: "currency",
                        interval: "interval",
                        price: 1,
                        priceExternalId: "price_external_id",
                        productExternalId: "product_external_id",
                        quantity: 1,
                        usageType: "licensed",
                    },
                    {
                        currency: "currency",
                        interval: "interval",
                        price: 1,
                        priceExternalId: "price_external_id",
                        productExternalId: "product_external_id",
                        quantity: 1,
                        usageType: "licensed",
                    },
                ],
                subscriptionExternalId: "subscription_external_id",
                totalPrice: 1,
            });
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("upsertBillingSubscription (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            cancel_at_period_end: true,
            currency: "currency",
            customer_external_id: "customer_external_id",
            discounts: [
                {
                    coupon_external_id: "coupon_external_id",
                    external_id: "external_id",
                    is_active: true,
                    started_at: "2024-01-15T09:30:00Z",
                },
                {
                    coupon_external_id: "coupon_external_id",
                    external_id: "external_id",
                    is_active: true,
                    started_at: "2024-01-15T09:30:00Z",
                },
            ],
            expired_at: "2024-01-15T09:30:00Z",
            product_external_ids: [
                {
                    currency: "currency",
                    interval: "interval",
                    price: 1,
                    price_external_id: "price_external_id",
                    product_external_id: "product_external_id",
                    quantity: 1,
                    usage_type: "licensed",
                },
                {
                    currency: "currency",
                    interval: "interval",
                    price: 1,
                    price_external_id: "price_external_id",
                    product_external_id: "product_external_id",
                    quantity: 1,
                    usage_type: "licensed",
                },
            ],
            subscription_external_id: "subscription_external_id",
            total_price: 1,
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/subscription/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingSubscription({
                cancelAtPeriodEnd: true,
                currency: "currency",
                customerExternalId: "customer_external_id",
                discounts: [
                    {
                        couponExternalId: "coupon_external_id",
                        externalId: "external_id",
                        isActive: true,
                        startedAt: new Date("2024-01-15T09:30:00.000Z"),
                    },
                    {
                        couponExternalId: "coupon_external_id",
                        externalId: "external_id",
                        isActive: true,
                        startedAt: new Date("2024-01-15T09:30:00.000Z"),
                    },
                ],
                expiredAt: new Date("2024-01-15T09:30:00.000Z"),
                productExternalIds: [
                    {
                        currency: "currency",
                        interval: "interval",
                        price: 1,
                        priceExternalId: "price_external_id",
                        productExternalId: "product_external_id",
                        quantity: 1,
                        usageType: "licensed",
                    },
                    {
                        currency: "currency",
                        interval: "interval",
                        price: 1,
                        priceExternalId: "price_external_id",
                        productExternalId: "product_external_id",
                        quantity: 1,
                        usageType: "licensed",
                    },
                ],
                subscriptionExternalId: "subscription_external_id",
                totalPrice: 1,
            });
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("upsertBillingSubscription (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            cancel_at_period_end: true,
            currency: "currency",
            customer_external_id: "customer_external_id",
            discounts: [
                {
                    coupon_external_id: "coupon_external_id",
                    external_id: "external_id",
                    is_active: true,
                    started_at: "2024-01-15T09:30:00Z",
                },
                {
                    coupon_external_id: "coupon_external_id",
                    external_id: "external_id",
                    is_active: true,
                    started_at: "2024-01-15T09:30:00Z",
                },
            ],
            expired_at: "2024-01-15T09:30:00Z",
            product_external_ids: [
                {
                    currency: "currency",
                    interval: "interval",
                    price: 1,
                    price_external_id: "price_external_id",
                    product_external_id: "product_external_id",
                    quantity: 1,
                    usage_type: "licensed",
                },
                {
                    currency: "currency",
                    interval: "interval",
                    price: 1,
                    price_external_id: "price_external_id",
                    product_external_id: "product_external_id",
                    quantity: 1,
                    usage_type: "licensed",
                },
            ],
            subscription_external_id: "subscription_external_id",
            total_price: 1,
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/subscription/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingSubscription({
                cancelAtPeriodEnd: true,
                currency: "currency",
                customerExternalId: "customer_external_id",
                discounts: [
                    {
                        couponExternalId: "coupon_external_id",
                        externalId: "external_id",
                        isActive: true,
                        startedAt: new Date("2024-01-15T09:30:00.000Z"),
                    },
                    {
                        couponExternalId: "coupon_external_id",
                        externalId: "external_id",
                        isActive: true,
                        startedAt: new Date("2024-01-15T09:30:00.000Z"),
                    },
                ],
                expiredAt: new Date("2024-01-15T09:30:00.000Z"),
                productExternalIds: [
                    {
                        currency: "currency",
                        interval: "interval",
                        price: 1,
                        priceExternalId: "price_external_id",
                        productExternalId: "product_external_id",
                        quantity: 1,
                        usageType: "licensed",
                    },
                    {
                        currency: "currency",
                        interval: "interval",
                        price: 1,
                        priceExternalId: "price_external_id",
                        productExternalId: "product_external_id",
                        quantity: 1,
                        usageType: "licensed",
                    },
                ],
                subscriptionExternalId: "subscription_external_id",
                totalPrice: 1,
            });
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("upsertBillingSubscription (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            cancel_at_period_end: true,
            currency: "currency",
            customer_external_id: "customer_external_id",
            discounts: [
                {
                    coupon_external_id: "coupon_external_id",
                    external_id: "external_id",
                    is_active: true,
                    started_at: "2024-01-15T09:30:00Z",
                },
                {
                    coupon_external_id: "coupon_external_id",
                    external_id: "external_id",
                    is_active: true,
                    started_at: "2024-01-15T09:30:00Z",
                },
            ],
            expired_at: "2024-01-15T09:30:00Z",
            product_external_ids: [
                {
                    currency: "currency",
                    interval: "interval",
                    price: 1,
                    price_external_id: "price_external_id",
                    product_external_id: "product_external_id",
                    quantity: 1,
                    usage_type: "licensed",
                },
                {
                    currency: "currency",
                    interval: "interval",
                    price: 1,
                    price_external_id: "price_external_id",
                    product_external_id: "product_external_id",
                    quantity: 1,
                    usage_type: "licensed",
                },
            ],
            subscription_external_id: "subscription_external_id",
            total_price: 1,
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/subscription/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingSubscription({
                cancelAtPeriodEnd: true,
                currency: "currency",
                customerExternalId: "customer_external_id",
                discounts: [
                    {
                        couponExternalId: "coupon_external_id",
                        externalId: "external_id",
                        isActive: true,
                        startedAt: new Date("2024-01-15T09:30:00.000Z"),
                    },
                    {
                        couponExternalId: "coupon_external_id",
                        externalId: "external_id",
                        isActive: true,
                        startedAt: new Date("2024-01-15T09:30:00.000Z"),
                    },
                ],
                expiredAt: new Date("2024-01-15T09:30:00.000Z"),
                productExternalIds: [
                    {
                        currency: "currency",
                        interval: "interval",
                        price: 1,
                        priceExternalId: "price_external_id",
                        productExternalId: "product_external_id",
                        quantity: 1,
                        usageType: "licensed",
                    },
                    {
                        currency: "currency",
                        interval: "interval",
                        price: 1,
                        priceExternalId: "price_external_id",
                        productExternalId: "product_external_id",
                        quantity: 1,
                        usageType: "licensed",
                    },
                ],
                subscriptionExternalId: "subscription_external_id",
                totalPrice: 1,
            });
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("upsertBillingSubscription (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            cancel_at_period_end: true,
            currency: "currency",
            customer_external_id: "customer_external_id",
            discounts: [
                {
                    coupon_external_id: "coupon_external_id",
                    external_id: "external_id",
                    is_active: true,
                    started_at: "2024-01-15T09:30:00Z",
                },
                {
                    coupon_external_id: "coupon_external_id",
                    external_id: "external_id",
                    is_active: true,
                    started_at: "2024-01-15T09:30:00Z",
                },
            ],
            expired_at: "2024-01-15T09:30:00Z",
            product_external_ids: [
                {
                    currency: "currency",
                    interval: "interval",
                    price: 1,
                    price_external_id: "price_external_id",
                    product_external_id: "product_external_id",
                    quantity: 1,
                    usage_type: "licensed",
                },
                {
                    currency: "currency",
                    interval: "interval",
                    price: 1,
                    price_external_id: "price_external_id",
                    product_external_id: "product_external_id",
                    quantity: 1,
                    usage_type: "licensed",
                },
            ],
            subscription_external_id: "subscription_external_id",
            total_price: 1,
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/subscription/upsert")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.billing.upsertBillingSubscription({
                cancelAtPeriodEnd: true,
                currency: "currency",
                customerExternalId: "customer_external_id",
                discounts: [
                    {
                        couponExternalId: "coupon_external_id",
                        externalId: "external_id",
                        isActive: true,
                        startedAt: new Date("2024-01-15T09:30:00.000Z"),
                    },
                    {
                        couponExternalId: "coupon_external_id",
                        externalId: "external_id",
                        isActive: true,
                        startedAt: new Date("2024-01-15T09:30:00.000Z"),
                    },
                ],
                expiredAt: new Date("2024-01-15T09:30:00.000Z"),
                productExternalIds: [
                    {
                        currency: "currency",
                        interval: "interval",
                        price: 1,
                        priceExternalId: "price_external_id",
                        productExternalId: "product_external_id",
                        quantity: 1,
                        usageType: "licensed",
                    },
                    {
                        currency: "currency",
                        interval: "interval",
                        price: 1,
                        priceExternalId: "price_external_id",
                        productExternalId: "product_external_id",
                        quantity: 1,
                        usageType: "licensed",
                    },
                ],
                subscriptionExternalId: "subscription_external_id",
                totalPrice: 1,
            });
        }).rejects.toThrow(Schematic.InternalServerError);
    });
});
