// This file was auto-generated by Fern from our API Definition.

import * as Schematic from "../../src/api/index";
import { SchematicClient } from "../../src/Client";
import { mockServerPool } from "../mock-server/MockServerPool";

describe("Credits", () => {
    test("listBillingCredits (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            data: [
                {
                    burn_strategy: "burn_strategy",
                    created_at: "2024-01-15T09:30:00Z",
                    default_expiry_unit: "default_expiry_unit",
                    default_expiry_unit_count: 1,
                    default_rollover_policy: "default_rollover_policy",
                    description: "description",
                    icon: "icon",
                    id: "id",
                    name: "name",
                    plural_name: "plural_name",
                    price: {
                        currency: "currency",
                        external_price_id: "external_price_id",
                        id: "id",
                        interval: "interval",
                        price: 1,
                        scheme: "scheme",
                    },
                    product: {
                        account_id: "account_id",
                        created_at: "2024-01-15T09:30:00Z",
                        environment_id: "environment_id",
                        external_id: "external_id",
                        is_active: true,
                        name: "name",
                        price: 1.1,
                        product_id: "product_id",
                        quantity: 1.1,
                        updated_at: "2024-01-15T09:30:00Z",
                    },
                    singular_name: "singular_name",
                    updated_at: "2024-01-15T09:30:00Z",
                },
            ],
            params: { ids: ["ids"], limit: 1, name: "name", offset: 1 },
        };
        server.mockEndpoint().get("/billing/credits").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.credits.listBillingCredits({
            name: "name",
            limit: 1,
            offset: 1,
        });
        expect(response).toEqual({
            data: [
                {
                    burn_strategy: "burn_strategy",
                    created_at: "2024-01-15T09:30:00Z",
                    default_expiry_unit: "default_expiry_unit",
                    default_expiry_unit_count: 1,
                    default_rollover_policy: "default_rollover_policy",
                    description: "description",
                    icon: "icon",
                    id: "id",
                    name: "name",
                    plural_name: "plural_name",
                    price: {
                        currency: "currency",
                        external_price_id: "external_price_id",
                        id: "id",
                        interval: "interval",
                        price: 1,
                        scheme: "scheme",
                    },
                    product: {
                        account_id: "account_id",
                        created_at: "2024-01-15T09:30:00Z",
                        environment_id: "environment_id",
                        external_id: "external_id",
                        is_active: true,
                        name: "name",
                        price: 1.1,
                        product_id: "product_id",
                        quantity: 1.1,
                        updated_at: "2024-01-15T09:30:00Z",
                    },
                    singular_name: "singular_name",
                    updated_at: "2024-01-15T09:30:00Z",
                },
            ],
            params: {
                ids: ["ids"],
                limit: 1,
                name: "name",
                offset: 1,
            },
        });
    });

    test("listBillingCredits (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/credits").respondWith().statusCode(400).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.credits.listBillingCredits();
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("listBillingCredits (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/credits").respondWith().statusCode(401).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.credits.listBillingCredits();
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("listBillingCredits (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/credits").respondWith().statusCode(403).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.credits.listBillingCredits();
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("listBillingCredits (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/credits").respondWith().statusCode(404).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.credits.listBillingCredits();
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("listBillingCredits (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/credits").respondWith().statusCode(500).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.credits.listBillingCredits();
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("createBillingCredit (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { currency: "currency", description: "description", name: "name" };
        const rawResponseBody = {
            data: {
                burn_strategy: "burn_strategy",
                created_at: "2024-01-15T09:30:00Z",
                default_expiry_unit: "default_expiry_unit",
                default_expiry_unit_count: 1,
                default_rollover_policy: "default_rollover_policy",
                description: "description",
                icon: "icon",
                id: "id",
                name: "name",
                plural_name: "plural_name",
                price: {
                    currency: "currency",
                    external_price_id: "external_price_id",
                    id: "id",
                    interval: "interval",
                    price: 1,
                    price_decimal: "price_decimal",
                    scheme: "scheme",
                },
                product: {
                    account_id: "account_id",
                    created_at: "2024-01-15T09:30:00Z",
                    environment_id: "environment_id",
                    external_id: "external_id",
                    is_active: true,
                    name: "name",
                    price: 1.1,
                    price_decimal: "price_decimal",
                    product_id: "product_id",
                    quantity: 1.1,
                    updated_at: "2024-01-15T09:30:00Z",
                },
                singular_name: "singular_name",
                updated_at: "2024-01-15T09:30:00Z",
            },
            params: { key: "value" },
        };
        server
            .mockEndpoint()
            .post("/billing/credits")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.credits.createBillingCredit({
            currency: "currency",
            description: "description",
            name: "name",
        });
        expect(response).toEqual({
            data: {
                burn_strategy: "burn_strategy",
                created_at: "2024-01-15T09:30:00Z",
                default_expiry_unit: "default_expiry_unit",
                default_expiry_unit_count: 1,
                default_rollover_policy: "default_rollover_policy",
                description: "description",
                icon: "icon",
                id: "id",
                name: "name",
                plural_name: "plural_name",
                price: {
                    currency: "currency",
                    external_price_id: "external_price_id",
                    id: "id",
                    interval: "interval",
                    price: 1,
                    price_decimal: "price_decimal",
                    scheme: "scheme",
                },
                product: {
                    account_id: "account_id",
                    created_at: "2024-01-15T09:30:00Z",
                    environment_id: "environment_id",
                    external_id: "external_id",
                    is_active: true,
                    name: "name",
                    price: 1.1,
                    price_decimal: "price_decimal",
                    product_id: "product_id",
                    quantity: 1.1,
                    updated_at: "2024-01-15T09:30:00Z",
                },
                singular_name: "singular_name",
                updated_at: "2024-01-15T09:30:00Z",
            },
            params: {
                key: "value",
            },
        });
    });

    test("createBillingCredit (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { currency: "currency", description: "description", name: "name" };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/credits")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.createBillingCredit({
                currency: "currency",
                description: "description",
                name: "name",
            });
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("createBillingCredit (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { currency: "currency", description: "description", name: "name" };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/credits")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.createBillingCredit({
                currency: "currency",
                description: "description",
                name: "name",
            });
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("createBillingCredit (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { currency: "currency", description: "description", name: "name" };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/credits")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.createBillingCredit({
                currency: "currency",
                description: "description",
                name: "name",
            });
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("createBillingCredit (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { currency: "currency", description: "description", name: "name" };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/credits")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.createBillingCredit({
                currency: "currency",
                description: "description",
                name: "name",
            });
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("createBillingCredit (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { currency: "currency", description: "description", name: "name" };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/credits")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.createBillingCredit({
                currency: "currency",
                description: "description",
                name: "name",
            });
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("getSingleBillingCredit (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            data: {
                burn_strategy: "burn_strategy",
                created_at: "2024-01-15T09:30:00Z",
                default_expiry_unit: "default_expiry_unit",
                default_expiry_unit_count: 1,
                default_rollover_policy: "default_rollover_policy",
                description: "description",
                icon: "icon",
                id: "id",
                name: "name",
                plural_name: "plural_name",
                price: {
                    currency: "currency",
                    external_price_id: "external_price_id",
                    id: "id",
                    interval: "interval",
                    price: 1,
                    price_decimal: "price_decimal",
                    scheme: "scheme",
                },
                product: {
                    account_id: "account_id",
                    created_at: "2024-01-15T09:30:00Z",
                    environment_id: "environment_id",
                    external_id: "external_id",
                    is_active: true,
                    name: "name",
                    price: 1.1,
                    price_decimal: "price_decimal",
                    product_id: "product_id",
                    quantity: 1.1,
                    updated_at: "2024-01-15T09:30:00Z",
                },
                singular_name: "singular_name",
                updated_at: "2024-01-15T09:30:00Z",
            },
            params: { key: "value" },
        };
        server
            .mockEndpoint()
            .get("/billing/credits/billing_id")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.credits.getSingleBillingCredit("billing_id");
        expect(response).toEqual({
            data: {
                burn_strategy: "burn_strategy",
                created_at: "2024-01-15T09:30:00Z",
                default_expiry_unit: "default_expiry_unit",
                default_expiry_unit_count: 1,
                default_rollover_policy: "default_rollover_policy",
                description: "description",
                icon: "icon",
                id: "id",
                name: "name",
                plural_name: "plural_name",
                price: {
                    currency: "currency",
                    external_price_id: "external_price_id",
                    id: "id",
                    interval: "interval",
                    price: 1,
                    price_decimal: "price_decimal",
                    scheme: "scheme",
                },
                product: {
                    account_id: "account_id",
                    created_at: "2024-01-15T09:30:00Z",
                    environment_id: "environment_id",
                    external_id: "external_id",
                    is_active: true,
                    name: "name",
                    price: 1.1,
                    price_decimal: "price_decimal",
                    product_id: "product_id",
                    quantity: 1.1,
                    updated_at: "2024-01-15T09:30:00Z",
                },
                singular_name: "singular_name",
                updated_at: "2024-01-15T09:30:00Z",
            },
            params: {
                key: "value",
            },
        });
    });

    test("getSingleBillingCredit (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/billing_id")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.getSingleBillingCredit("billing_id");
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("getSingleBillingCredit (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/billing_id")
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.getSingleBillingCredit("billing_id");
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("getSingleBillingCredit (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/billing_id")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.getSingleBillingCredit("billing_id");
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("getSingleBillingCredit (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/billing_id")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.getSingleBillingCredit("billing_id");
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("updateBillingCredit (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { description: "description", name: "name" };
        const rawResponseBody = {
            data: {
                burn_strategy: "burn_strategy",
                created_at: "2024-01-15T09:30:00Z",
                default_expiry_unit: "default_expiry_unit",
                default_expiry_unit_count: 1,
                default_rollover_policy: "default_rollover_policy",
                description: "description",
                icon: "icon",
                id: "id",
                name: "name",
                plural_name: "plural_name",
                price: {
                    currency: "currency",
                    external_price_id: "external_price_id",
                    id: "id",
                    interval: "interval",
                    price: 1,
                    price_decimal: "price_decimal",
                    scheme: "scheme",
                },
                product: {
                    account_id: "account_id",
                    created_at: "2024-01-15T09:30:00Z",
                    environment_id: "environment_id",
                    external_id: "external_id",
                    is_active: true,
                    name: "name",
                    price: 1.1,
                    price_decimal: "price_decimal",
                    product_id: "product_id",
                    quantity: 1.1,
                    updated_at: "2024-01-15T09:30:00Z",
                },
                singular_name: "singular_name",
                updated_at: "2024-01-15T09:30:00Z",
            },
            params: { key: "value" },
        };
        server
            .mockEndpoint()
            .put("/billing/credits/billing_id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.credits.updateBillingCredit("billing_id", {
            description: "description",
            name: "name",
        });
        expect(response).toEqual({
            data: {
                burn_strategy: "burn_strategy",
                created_at: "2024-01-15T09:30:00Z",
                default_expiry_unit: "default_expiry_unit",
                default_expiry_unit_count: 1,
                default_rollover_policy: "default_rollover_policy",
                description: "description",
                icon: "icon",
                id: "id",
                name: "name",
                plural_name: "plural_name",
                price: {
                    currency: "currency",
                    external_price_id: "external_price_id",
                    id: "id",
                    interval: "interval",
                    price: 1,
                    price_decimal: "price_decimal",
                    scheme: "scheme",
                },
                product: {
                    account_id: "account_id",
                    created_at: "2024-01-15T09:30:00Z",
                    environment_id: "environment_id",
                    external_id: "external_id",
                    is_active: true,
                    name: "name",
                    price: 1.1,
                    price_decimal: "price_decimal",
                    product_id: "product_id",
                    quantity: 1.1,
                    updated_at: "2024-01-15T09:30:00Z",
                },
                singular_name: "singular_name",
                updated_at: "2024-01-15T09:30:00Z",
            },
            params: {
                key: "value",
            },
        });
    });

    test("updateBillingCredit (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { description: "description", name: "name" };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .put("/billing/credits/billing_id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.updateBillingCredit("billing_id", {
                description: "description",
                name: "name",
            });
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("updateBillingCredit (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { description: "description", name: "name" };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .put("/billing/credits/billing_id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.updateBillingCredit("billing_id", {
                description: "description",
                name: "name",
            });
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("updateBillingCredit (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { description: "description", name: "name" };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .put("/billing/credits/billing_id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.updateBillingCredit("billing_id", {
                description: "description",
                name: "name",
            });
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("updateBillingCredit (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { description: "description", name: "name" };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .put("/billing/credits/billing_id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.updateBillingCredit("billing_id", {
                description: "description",
                name: "name",
            });
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("updateBillingCredit (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { description: "description", name: "name" };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .put("/billing/credits/billing_id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.updateBillingCredit("billing_id", {
                description: "description",
                name: "name",
            });
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("softDeleteBillingCredit (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { data: { deleted: true }, params: { key: "value" } };
        server
            .mockEndpoint()
            .delete("/billing/credits/billing_id")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.credits.softDeleteBillingCredit("billing_id");
        expect(response).toEqual({
            data: {
                deleted: true,
            },
            params: {
                key: "value",
            },
        });
    });

    test("softDeleteBillingCredit (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .delete("/billing/credits/billing_id")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.softDeleteBillingCredit("billing_id");
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("softDeleteBillingCredit (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .delete("/billing/credits/billing_id")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.softDeleteBillingCredit("billing_id");
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("softDeleteBillingCredit (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .delete("/billing/credits/billing_id")
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.softDeleteBillingCredit("billing_id");
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("softDeleteBillingCredit (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .delete("/billing/credits/billing_id")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.softDeleteBillingCredit("billing_id");
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("softDeleteBillingCredit (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .delete("/billing/credits/billing_id")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.softDeleteBillingCredit("billing_id");
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("listCreditBundles (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            data: [
                {
                    billing_invoice_id: "billing_invoice_id",
                    bundle_type: "bundle_type",
                    created_at: "2024-01-15T09:30:00Z",
                    credit_description: "credit_description",
                    credit_icon: "credit_icon",
                    credit_id: "credit_id",
                    credit_name: "credit_name",
                    expiry_type: "expiry_type",
                    expiry_unit: "expiry_unit",
                    expiry_unit_count: 1,
                    has_grants: true,
                    id: "id",
                    name: "name",
                    plural_name: "plural_name",
                    price: {
                        currency: "currency",
                        external_price_id: "external_price_id",
                        id: "id",
                        interval: "interval",
                        price: 1,
                        scheme: "scheme",
                    },
                    quantity: 1,
                    singular_name: "singular_name",
                    status: "status",
                    unit_price: {
                        currency: "currency",
                        external_price_id: "external_price_id",
                        id: "id",
                        interval: "interval",
                        price: 1,
                        scheme: "scheme",
                    },
                    updated_at: "2024-01-15T09:30:00Z",
                },
            ],
            params: {
                bundle_type: "fixed",
                credit_id: "credit_id",
                ids: ["ids"],
                limit: 1,
                offset: 1,
                status: "active",
            },
        };
        server
            .mockEndpoint()
            .get("/billing/credits/bundles")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.credits.listCreditBundles({
            credit_id: "credit_id",
            status: "active",
            bundle_type: "fixed",
            limit: 1,
            offset: 1,
        });
        expect(response).toEqual({
            data: [
                {
                    billing_invoice_id: "billing_invoice_id",
                    bundle_type: "bundle_type",
                    created_at: "2024-01-15T09:30:00Z",
                    credit_description: "credit_description",
                    credit_icon: "credit_icon",
                    credit_id: "credit_id",
                    credit_name: "credit_name",
                    expiry_type: "expiry_type",
                    expiry_unit: "expiry_unit",
                    expiry_unit_count: 1,
                    has_grants: true,
                    id: "id",
                    name: "name",
                    plural_name: "plural_name",
                    price: {
                        currency: "currency",
                        external_price_id: "external_price_id",
                        id: "id",
                        interval: "interval",
                        price: 1,
                        scheme: "scheme",
                    },
                    quantity: 1,
                    singular_name: "singular_name",
                    status: "status",
                    unit_price: {
                        currency: "currency",
                        external_price_id: "external_price_id",
                        id: "id",
                        interval: "interval",
                        price: 1,
                        scheme: "scheme",
                    },
                    updated_at: "2024-01-15T09:30:00Z",
                },
            ],
            params: {
                bundle_type: "fixed",
                credit_id: "credit_id",
                ids: ["ids"],
                limit: 1,
                offset: 1,
                status: "active",
            },
        });
    });

    test("listCreditBundles (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/bundles")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.listCreditBundles();
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("listCreditBundles (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/bundles")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.listCreditBundles();
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("listCreditBundles (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/bundles")
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.listCreditBundles();
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("listCreditBundles (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/bundles")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.listCreditBundles();
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("listCreditBundles (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/bundles")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.listCreditBundles();
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("createCreditBundle (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            bundle_name: "bundle_name",
            credit_id: "credit_id",
            currency: "currency",
            price_per_unit: 1,
        };
        const rawResponseBody = {
            data: {
                billing_invoice_id: "billing_invoice_id",
                bundle_type: "bundle_type",
                created_at: "2024-01-15T09:30:00Z",
                credit_description: "credit_description",
                credit_icon: "credit_icon",
                credit_id: "credit_id",
                credit_name: "credit_name",
                expiry_type: "expiry_type",
                expiry_unit: "expiry_unit",
                expiry_unit_count: 1,
                has_grants: true,
                id: "id",
                name: "name",
                plural_name: "plural_name",
                price: {
                    currency: "currency",
                    external_price_id: "external_price_id",
                    id: "id",
                    interval: "interval",
                    price: 1,
                    price_decimal: "price_decimal",
                    scheme: "scheme",
                },
                quantity: 1,
                singular_name: "singular_name",
                status: "status",
                unit_price: {
                    currency: "currency",
                    external_price_id: "external_price_id",
                    id: "id",
                    interval: "interval",
                    price: 1,
                    price_decimal: "price_decimal",
                    scheme: "scheme",
                },
                updated_at: "2024-01-15T09:30:00Z",
            },
            params: { key: "value" },
        };
        server
            .mockEndpoint()
            .post("/billing/credits/bundles")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.credits.createCreditBundle({
            bundle_name: "bundle_name",
            credit_id: "credit_id",
            currency: "currency",
            price_per_unit: 1,
        });
        expect(response).toEqual({
            data: {
                billing_invoice_id: "billing_invoice_id",
                bundle_type: "bundle_type",
                created_at: "2024-01-15T09:30:00Z",
                credit_description: "credit_description",
                credit_icon: "credit_icon",
                credit_id: "credit_id",
                credit_name: "credit_name",
                expiry_type: "expiry_type",
                expiry_unit: "expiry_unit",
                expiry_unit_count: 1,
                has_grants: true,
                id: "id",
                name: "name",
                plural_name: "plural_name",
                price: {
                    currency: "currency",
                    external_price_id: "external_price_id",
                    id: "id",
                    interval: "interval",
                    price: 1,
                    price_decimal: "price_decimal",
                    scheme: "scheme",
                },
                quantity: 1,
                singular_name: "singular_name",
                status: "status",
                unit_price: {
                    currency: "currency",
                    external_price_id: "external_price_id",
                    id: "id",
                    interval: "interval",
                    price: 1,
                    price_decimal: "price_decimal",
                    scheme: "scheme",
                },
                updated_at: "2024-01-15T09:30:00Z",
            },
            params: {
                key: "value",
            },
        });
    });

    test("createCreditBundle (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            bundle_name: "bundle_name",
            credit_id: "credit_id",
            currency: "currency",
            price_per_unit: 1,
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/credits/bundles")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.createCreditBundle({
                bundle_name: "bundle_name",
                credit_id: "credit_id",
                currency: "currency",
                price_per_unit: 1,
            });
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("createCreditBundle (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            bundle_name: "bundle_name",
            credit_id: "credit_id",
            currency: "currency",
            price_per_unit: 1,
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/credits/bundles")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.createCreditBundle({
                bundle_name: "bundle_name",
                credit_id: "credit_id",
                currency: "currency",
                price_per_unit: 1,
            });
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("createCreditBundle (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            bundle_name: "bundle_name",
            credit_id: "credit_id",
            currency: "currency",
            price_per_unit: 1,
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/credits/bundles")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.createCreditBundle({
                bundle_name: "bundle_name",
                credit_id: "credit_id",
                currency: "currency",
                price_per_unit: 1,
            });
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("createCreditBundle (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            bundle_name: "bundle_name",
            credit_id: "credit_id",
            currency: "currency",
            price_per_unit: 1,
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/credits/bundles")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.createCreditBundle({
                bundle_name: "bundle_name",
                credit_id: "credit_id",
                currency: "currency",
                price_per_unit: 1,
            });
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("createCreditBundle (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            bundle_name: "bundle_name",
            credit_id: "credit_id",
            currency: "currency",
            price_per_unit: 1,
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/credits/bundles")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.createCreditBundle({
                bundle_name: "bundle_name",
                credit_id: "credit_id",
                currency: "currency",
                price_per_unit: 1,
            });
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("getCreditBundle (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            data: {
                billing_invoice_id: "billing_invoice_id",
                bundle_type: "bundle_type",
                created_at: "2024-01-15T09:30:00Z",
                credit_description: "credit_description",
                credit_icon: "credit_icon",
                credit_id: "credit_id",
                credit_name: "credit_name",
                expiry_type: "expiry_type",
                expiry_unit: "expiry_unit",
                expiry_unit_count: 1,
                has_grants: true,
                id: "id",
                name: "name",
                plural_name: "plural_name",
                price: {
                    currency: "currency",
                    external_price_id: "external_price_id",
                    id: "id",
                    interval: "interval",
                    price: 1,
                    price_decimal: "price_decimal",
                    scheme: "scheme",
                },
                quantity: 1,
                singular_name: "singular_name",
                status: "status",
                unit_price: {
                    currency: "currency",
                    external_price_id: "external_price_id",
                    id: "id",
                    interval: "interval",
                    price: 1,
                    price_decimal: "price_decimal",
                    scheme: "scheme",
                },
                updated_at: "2024-01-15T09:30:00Z",
            },
            params: { key: "value" },
        };
        server
            .mockEndpoint()
            .get("/billing/credits/bundles/billing_id")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.credits.getCreditBundle("billing_id");
        expect(response).toEqual({
            data: {
                billing_invoice_id: "billing_invoice_id",
                bundle_type: "bundle_type",
                created_at: "2024-01-15T09:30:00Z",
                credit_description: "credit_description",
                credit_icon: "credit_icon",
                credit_id: "credit_id",
                credit_name: "credit_name",
                expiry_type: "expiry_type",
                expiry_unit: "expiry_unit",
                expiry_unit_count: 1,
                has_grants: true,
                id: "id",
                name: "name",
                plural_name: "plural_name",
                price: {
                    currency: "currency",
                    external_price_id: "external_price_id",
                    id: "id",
                    interval: "interval",
                    price: 1,
                    price_decimal: "price_decimal",
                    scheme: "scheme",
                },
                quantity: 1,
                singular_name: "singular_name",
                status: "status",
                unit_price: {
                    currency: "currency",
                    external_price_id: "external_price_id",
                    id: "id",
                    interval: "interval",
                    price: 1,
                    price_decimal: "price_decimal",
                    scheme: "scheme",
                },
                updated_at: "2024-01-15T09:30:00Z",
            },
            params: {
                key: "value",
            },
        });
    });

    test("getCreditBundle (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/bundles/billing_id")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.getCreditBundle("billing_id");
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("getCreditBundle (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/bundles/billing_id")
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.getCreditBundle("billing_id");
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("getCreditBundle (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/bundles/billing_id")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.getCreditBundle("billing_id");
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("getCreditBundle (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/bundles/billing_id")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.getCreditBundle("billing_id");
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("updateCreditBundleDetails (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { bundle_name: "bundle_name", price_per_unit: 1 };
        const rawResponseBody = {
            data: {
                billing_invoice_id: "billing_invoice_id",
                bundle_type: "bundle_type",
                created_at: "2024-01-15T09:30:00Z",
                credit_description: "credit_description",
                credit_icon: "credit_icon",
                credit_id: "credit_id",
                credit_name: "credit_name",
                expiry_type: "expiry_type",
                expiry_unit: "expiry_unit",
                expiry_unit_count: 1,
                has_grants: true,
                id: "id",
                name: "name",
                plural_name: "plural_name",
                price: {
                    currency: "currency",
                    external_price_id: "external_price_id",
                    id: "id",
                    interval: "interval",
                    price: 1,
                    price_decimal: "price_decimal",
                    scheme: "scheme",
                },
                quantity: 1,
                singular_name: "singular_name",
                status: "status",
                unit_price: {
                    currency: "currency",
                    external_price_id: "external_price_id",
                    id: "id",
                    interval: "interval",
                    price: 1,
                    price_decimal: "price_decimal",
                    scheme: "scheme",
                },
                updated_at: "2024-01-15T09:30:00Z",
            },
            params: { key: "value" },
        };
        server
            .mockEndpoint()
            .put("/billing/credits/bundles/billing_id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.credits.updateCreditBundleDetails("billing_id", {
            bundle_name: "bundle_name",
            price_per_unit: 1,
        });
        expect(response).toEqual({
            data: {
                billing_invoice_id: "billing_invoice_id",
                bundle_type: "bundle_type",
                created_at: "2024-01-15T09:30:00Z",
                credit_description: "credit_description",
                credit_icon: "credit_icon",
                credit_id: "credit_id",
                credit_name: "credit_name",
                expiry_type: "expiry_type",
                expiry_unit: "expiry_unit",
                expiry_unit_count: 1,
                has_grants: true,
                id: "id",
                name: "name",
                plural_name: "plural_name",
                price: {
                    currency: "currency",
                    external_price_id: "external_price_id",
                    id: "id",
                    interval: "interval",
                    price: 1,
                    price_decimal: "price_decimal",
                    scheme: "scheme",
                },
                quantity: 1,
                singular_name: "singular_name",
                status: "status",
                unit_price: {
                    currency: "currency",
                    external_price_id: "external_price_id",
                    id: "id",
                    interval: "interval",
                    price: 1,
                    price_decimal: "price_decimal",
                    scheme: "scheme",
                },
                updated_at: "2024-01-15T09:30:00Z",
            },
            params: {
                key: "value",
            },
        });
    });

    test("updateCreditBundleDetails (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { bundle_name: "bundle_name", price_per_unit: 1 };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .put("/billing/credits/bundles/billing_id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.updateCreditBundleDetails("billing_id", {
                bundle_name: "bundle_name",
                price_per_unit: 1,
            });
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("updateCreditBundleDetails (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { bundle_name: "bundle_name", price_per_unit: 1 };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .put("/billing/credits/bundles/billing_id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.updateCreditBundleDetails("billing_id", {
                bundle_name: "bundle_name",
                price_per_unit: 1,
            });
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("updateCreditBundleDetails (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { bundle_name: "bundle_name", price_per_unit: 1 };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .put("/billing/credits/bundles/billing_id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.updateCreditBundleDetails("billing_id", {
                bundle_name: "bundle_name",
                price_per_unit: 1,
            });
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("updateCreditBundleDetails (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { bundle_name: "bundle_name", price_per_unit: 1 };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .put("/billing/credits/bundles/billing_id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.updateCreditBundleDetails("billing_id", {
                bundle_name: "bundle_name",
                price_per_unit: 1,
            });
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("updateCreditBundleDetails (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { bundle_name: "bundle_name", price_per_unit: 1 };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .put("/billing/credits/bundles/billing_id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.updateCreditBundleDetails("billing_id", {
                bundle_name: "bundle_name",
                price_per_unit: 1,
            });
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("deleteCreditBundle (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { data: { deleted: true }, params: { key: "value" } };
        server
            .mockEndpoint()
            .delete("/billing/credits/bundles/billing_id")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.credits.deleteCreditBundle("billing_id");
        expect(response).toEqual({
            data: {
                deleted: true,
            },
            params: {
                key: "value",
            },
        });
    });

    test("deleteCreditBundle (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .delete("/billing/credits/bundles/billing_id")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.deleteCreditBundle("billing_id");
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("deleteCreditBundle (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .delete("/billing/credits/bundles/billing_id")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.deleteCreditBundle("billing_id");
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("deleteCreditBundle (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .delete("/billing/credits/bundles/billing_id")
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.deleteCreditBundle("billing_id");
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("deleteCreditBundle (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .delete("/billing/credits/bundles/billing_id")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.deleteCreditBundle("billing_id");
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("deleteCreditBundle (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .delete("/billing/credits/bundles/billing_id")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.deleteCreditBundle("billing_id");
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("countCreditBundles (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            data: { count: 1 },
            params: {
                bundle_type: "fixed",
                credit_id: "credit_id",
                ids: ["ids"],
                limit: 1,
                offset: 1,
                status: "active",
            },
        };
        server
            .mockEndpoint()
            .get("/billing/credits/bundles/count")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.credits.countCreditBundles({
            credit_id: "credit_id",
            status: "active",
            bundle_type: "fixed",
            limit: 1,
            offset: 1,
        });
        expect(response).toEqual({
            data: {
                count: 1,
            },
            params: {
                bundle_type: "fixed",
                credit_id: "credit_id",
                ids: ["ids"],
                limit: 1,
                offset: 1,
                status: "active",
            },
        });
    });

    test("countCreditBundles (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/bundles/count")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.countCreditBundles();
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("countCreditBundles (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/bundles/count")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.countCreditBundles();
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("countCreditBundles (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/bundles/count")
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.countCreditBundles();
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("countCreditBundles (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/bundles/count")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.countCreditBundles();
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("countCreditBundles (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/bundles/count")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.countCreditBundles();
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("countBillingCredits (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { data: { count: 1 }, params: { ids: ["ids"], limit: 1, name: "name", offset: 1 } };
        server
            .mockEndpoint()
            .get("/billing/credits/count")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.credits.countBillingCredits({
            name: "name",
            limit: 1,
            offset: 1,
        });
        expect(response).toEqual({
            data: {
                count: 1,
            },
            params: {
                ids: ["ids"],
                limit: 1,
                name: "name",
                offset: 1,
            },
        });
    });

    test("countBillingCredits (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/count")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.countBillingCredits();
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("countBillingCredits (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/count")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.countBillingCredits();
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("countBillingCredits (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/count")
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.countBillingCredits();
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("countBillingCredits (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/count")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.countBillingCredits();
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("countBillingCredits (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/count")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.countBillingCredits();
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("zeroOutGrant (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = {
            data: {
                company_id: "company_id",
                company_name: "company_name",
                created_at: "2024-01-15T09:30:00Z",
                credit_icon: "credit_icon",
                credit_id: "credit_id",
                credit_name: "credit_name",
                expires_at: "2024-01-15T09:30:00Z",
                grant_reason: "grant_reason",
                id: "id",
                plan_id: "plan_id",
                plan_name: "plan_name",
                price: {
                    currency: "currency",
                    external_price_id: "external_price_id",
                    id: "id",
                    interval: "interval",
                    price: 1,
                    price_decimal: "price_decimal",
                    scheme: "scheme",
                },
                quantity: 1,
                quantity_remaining: 1.1,
                quantity_used: 1.1,
                source_label: "source_label",
                updated_at: "2024-01-15T09:30:00Z",
                valid_from: "2024-01-15T09:30:00Z",
                zeroed_out_date: "2024-01-15T09:30:00Z",
                zeroed_out_reason: "zeroed_out_reason",
            },
            params: { key: "value" },
        };
        server
            .mockEndpoint()
            .put("/billing/credits/grants/billing_id/zero-out")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.credits.zeroOutGrant("billing_id");
        expect(response).toEqual({
            data: {
                company_id: "company_id",
                company_name: "company_name",
                created_at: "2024-01-15T09:30:00Z",
                credit_icon: "credit_icon",
                credit_id: "credit_id",
                credit_name: "credit_name",
                expires_at: "2024-01-15T09:30:00Z",
                grant_reason: "grant_reason",
                id: "id",
                plan_id: "plan_id",
                plan_name: "plan_name",
                price: {
                    currency: "currency",
                    external_price_id: "external_price_id",
                    id: "id",
                    interval: "interval",
                    price: 1,
                    price_decimal: "price_decimal",
                    scheme: "scheme",
                },
                quantity: 1,
                quantity_remaining: 1.1,
                quantity_used: 1.1,
                source_label: "source_label",
                updated_at: "2024-01-15T09:30:00Z",
                valid_from: "2024-01-15T09:30:00Z",
                zeroed_out_date: "2024-01-15T09:30:00Z",
                zeroed_out_reason: "zeroed_out_reason",
            },
            params: {
                key: "value",
            },
        });
    });

    test("zeroOutGrant (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .put("/billing/credits/grants/billing_id/zero-out")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.zeroOutGrant("billing_id");
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("zeroOutGrant (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .put("/billing/credits/grants/billing_id/zero-out")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.zeroOutGrant("billing_id");
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("zeroOutGrant (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .put("/billing/credits/grants/billing_id/zero-out")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.zeroOutGrant("billing_id");
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("zeroOutGrant (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .put("/billing/credits/grants/billing_id/zero-out")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.zeroOutGrant("billing_id");
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("zeroOutGrant (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .put("/billing/credits/grants/billing_id/zero-out")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.zeroOutGrant("billing_id");
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("grantBillingCreditsToCompany (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { company_id: "company_id", credit_id: "credit_id", quantity: 1, reason: "reason" };
        const rawResponseBody = {
            data: {
                company_id: "company_id",
                company_name: "company_name",
                created_at: "2024-01-15T09:30:00Z",
                credit_icon: "credit_icon",
                credit_id: "credit_id",
                credit_name: "credit_name",
                expires_at: "2024-01-15T09:30:00Z",
                grant_reason: "grant_reason",
                id: "id",
                plan_id: "plan_id",
                plan_name: "plan_name",
                price: {
                    currency: "currency",
                    external_price_id: "external_price_id",
                    id: "id",
                    interval: "interval",
                    price: 1,
                    price_decimal: "price_decimal",
                    scheme: "scheme",
                },
                quantity: 1,
                quantity_remaining: 1.1,
                quantity_used: 1.1,
                source_label: "source_label",
                updated_at: "2024-01-15T09:30:00Z",
                valid_from: "2024-01-15T09:30:00Z",
                zeroed_out_date: "2024-01-15T09:30:00Z",
                zeroed_out_reason: "zeroed_out_reason",
            },
            params: { key: "value" },
        };
        server
            .mockEndpoint()
            .post("/billing/credits/grants/company")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.credits.grantBillingCreditsToCompany({
            company_id: "company_id",
            credit_id: "credit_id",
            quantity: 1,
            reason: "reason",
        });
        expect(response).toEqual({
            data: {
                company_id: "company_id",
                company_name: "company_name",
                created_at: "2024-01-15T09:30:00Z",
                credit_icon: "credit_icon",
                credit_id: "credit_id",
                credit_name: "credit_name",
                expires_at: "2024-01-15T09:30:00Z",
                grant_reason: "grant_reason",
                id: "id",
                plan_id: "plan_id",
                plan_name: "plan_name",
                price: {
                    currency: "currency",
                    external_price_id: "external_price_id",
                    id: "id",
                    interval: "interval",
                    price: 1,
                    price_decimal: "price_decimal",
                    scheme: "scheme",
                },
                quantity: 1,
                quantity_remaining: 1.1,
                quantity_used: 1.1,
                source_label: "source_label",
                updated_at: "2024-01-15T09:30:00Z",
                valid_from: "2024-01-15T09:30:00Z",
                zeroed_out_date: "2024-01-15T09:30:00Z",
                zeroed_out_reason: "zeroed_out_reason",
            },
            params: {
                key: "value",
            },
        });
    });

    test("grantBillingCreditsToCompany (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { company_id: "company_id", credit_id: "credit_id", quantity: 1, reason: "reason" };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/credits/grants/company")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.grantBillingCreditsToCompany({
                company_id: "company_id",
                credit_id: "credit_id",
                quantity: 1,
                reason: "reason",
            });
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("grantBillingCreditsToCompany (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { company_id: "company_id", credit_id: "credit_id", quantity: 1, reason: "reason" };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/credits/grants/company")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.grantBillingCreditsToCompany({
                company_id: "company_id",
                credit_id: "credit_id",
                quantity: 1,
                reason: "reason",
            });
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("grantBillingCreditsToCompany (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { company_id: "company_id", credit_id: "credit_id", quantity: 1, reason: "reason" };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/credits/grants/company")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.grantBillingCreditsToCompany({
                company_id: "company_id",
                credit_id: "credit_id",
                quantity: 1,
                reason: "reason",
            });
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("grantBillingCreditsToCompany (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { company_id: "company_id", credit_id: "credit_id", quantity: 1, reason: "reason" };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/credits/grants/company")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.grantBillingCreditsToCompany({
                company_id: "company_id",
                credit_id: "credit_id",
                quantity: 1,
                reason: "reason",
            });
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("grantBillingCreditsToCompany (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { company_id: "company_id", credit_id: "credit_id", quantity: 1, reason: "reason" };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/credits/grants/company")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.grantBillingCreditsToCompany({
                company_id: "company_id",
                credit_id: "credit_id",
                quantity: 1,
                reason: "reason",
            });
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("listCompanyGrants (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            data: [
                {
                    company_id: "company_id",
                    company_name: "company_name",
                    created_at: "2024-01-15T09:30:00Z",
                    credit_icon: "credit_icon",
                    credit_id: "credit_id",
                    credit_name: "credit_name",
                    expires_at: "2024-01-15T09:30:00Z",
                    grant_reason: "grant_reason",
                    id: "id",
                    plan_id: "plan_id",
                    plan_name: "plan_name",
                    price: {
                        currency: "currency",
                        external_price_id: "external_price_id",
                        id: "id",
                        interval: "interval",
                        price: 1,
                        scheme: "scheme",
                    },
                    quantity: 1,
                    quantity_remaining: 1.1,
                    quantity_used: 1.1,
                    source_label: "source_label",
                    updated_at: "2024-01-15T09:30:00Z",
                    valid_from: "2024-01-15T09:30:00Z",
                    zeroed_out_date: "2024-01-15T09:30:00Z",
                    zeroed_out_reason: "zeroed_out_reason",
                },
            ],
            params: { company_id: "company_id", dir: "asc", limit: 1, offset: 1, order: "created_at" },
        };
        server
            .mockEndpoint()
            .get("/billing/credits/grants/company/list")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.credits.listCompanyGrants({
            company_id: "company_id",
            order: "created_at",
            dir: "asc",
            limit: 1,
            offset: 1,
        });
        expect(response).toEqual({
            data: [
                {
                    company_id: "company_id",
                    company_name: "company_name",
                    created_at: "2024-01-15T09:30:00Z",
                    credit_icon: "credit_icon",
                    credit_id: "credit_id",
                    credit_name: "credit_name",
                    expires_at: "2024-01-15T09:30:00Z",
                    grant_reason: "grant_reason",
                    id: "id",
                    plan_id: "plan_id",
                    plan_name: "plan_name",
                    price: {
                        currency: "currency",
                        external_price_id: "external_price_id",
                        id: "id",
                        interval: "interval",
                        price: 1,
                        scheme: "scheme",
                    },
                    quantity: 1,
                    quantity_remaining: 1.1,
                    quantity_used: 1.1,
                    source_label: "source_label",
                    updated_at: "2024-01-15T09:30:00Z",
                    valid_from: "2024-01-15T09:30:00Z",
                    zeroed_out_date: "2024-01-15T09:30:00Z",
                    zeroed_out_reason: "zeroed_out_reason",
                },
            ],
            params: {
                company_id: "company_id",
                dir: "asc",
                limit: 1,
                offset: 1,
                order: "created_at",
            },
        });
    });

    test("listCompanyGrants (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/grants/company/list")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.listCompanyGrants();
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("listCompanyGrants (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/grants/company/list")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.listCompanyGrants();
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("listCompanyGrants (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/grants/company/list")
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.listCompanyGrants();
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("listCompanyGrants (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/grants/company/list")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.listCompanyGrants();
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("listCompanyGrants (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/grants/company/list")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.listCompanyGrants();
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("countBillingCreditsGrants (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            data: { count: 1 },
            params: { credit_id: "credit_id", ids: ["ids"], limit: 1, offset: 1 },
        };
        server
            .mockEndpoint()
            .get("/billing/credits/grants/count")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.credits.countBillingCreditsGrants({
            credit_id: "credit_id",
            limit: 1,
            offset: 1,
        });
        expect(response).toEqual({
            data: {
                count: 1,
            },
            params: {
                credit_id: "credit_id",
                ids: ["ids"],
                limit: 1,
                offset: 1,
            },
        });
    });

    test("countBillingCreditsGrants (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/grants/count")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.countBillingCreditsGrants();
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("countBillingCreditsGrants (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/grants/count")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.countBillingCreditsGrants();
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("countBillingCreditsGrants (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/grants/count")
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.countBillingCreditsGrants();
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("countBillingCreditsGrants (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/grants/count")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.countBillingCreditsGrants();
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("countBillingCreditsGrants (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/grants/count")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.countBillingCreditsGrants();
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("listGrantsForCredit (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            data: [
                {
                    company_id: "company_id",
                    company_name: "company_name",
                    created_at: "2024-01-15T09:30:00Z",
                    credit_icon: "credit_icon",
                    credit_id: "credit_id",
                    credit_name: "credit_name",
                    expires_at: "2024-01-15T09:30:00Z",
                    grant_reason: "grant_reason",
                    id: "id",
                    plan_id: "plan_id",
                    plan_name: "plan_name",
                    price: {
                        currency: "currency",
                        external_price_id: "external_price_id",
                        id: "id",
                        interval: "interval",
                        price: 1,
                        scheme: "scheme",
                    },
                    quantity: 1,
                    quantity_remaining: 1.1,
                    quantity_used: 1.1,
                    source_label: "source_label",
                    updated_at: "2024-01-15T09:30:00Z",
                    valid_from: "2024-01-15T09:30:00Z",
                    zeroed_out_date: "2024-01-15T09:30:00Z",
                    zeroed_out_reason: "zeroed_out_reason",
                },
            ],
            params: { credit_id: "credit_id", ids: ["ids"], limit: 1, offset: 1 },
        };
        server
            .mockEndpoint()
            .get("/billing/credits/grants/list")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.credits.listGrantsForCredit({
            credit_id: "credit_id",
            limit: 1,
            offset: 1,
        });
        expect(response).toEqual({
            data: [
                {
                    company_id: "company_id",
                    company_name: "company_name",
                    created_at: "2024-01-15T09:30:00Z",
                    credit_icon: "credit_icon",
                    credit_id: "credit_id",
                    credit_name: "credit_name",
                    expires_at: "2024-01-15T09:30:00Z",
                    grant_reason: "grant_reason",
                    id: "id",
                    plan_id: "plan_id",
                    plan_name: "plan_name",
                    price: {
                        currency: "currency",
                        external_price_id: "external_price_id",
                        id: "id",
                        interval: "interval",
                        price: 1,
                        scheme: "scheme",
                    },
                    quantity: 1,
                    quantity_remaining: 1.1,
                    quantity_used: 1.1,
                    source_label: "source_label",
                    updated_at: "2024-01-15T09:30:00Z",
                    valid_from: "2024-01-15T09:30:00Z",
                    zeroed_out_date: "2024-01-15T09:30:00Z",
                    zeroed_out_reason: "zeroed_out_reason",
                },
            ],
            params: {
                credit_id: "credit_id",
                ids: ["ids"],
                limit: 1,
                offset: 1,
            },
        });
    });

    test("listGrantsForCredit (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/grants/list")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.listGrantsForCredit();
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("listGrantsForCredit (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/grants/list")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.listGrantsForCredit();
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("listGrantsForCredit (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/grants/list")
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.listGrantsForCredit();
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("listGrantsForCredit (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/grants/list")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.listGrantsForCredit();
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("listGrantsForCredit (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/grants/list")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.listGrantsForCredit();
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("getEnrichedCreditLedger (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            data: [
                {
                    billing_credit_id: "billing_credit_id",
                    company: { id: "id", name: "name" },
                    company_id: "company_id",
                    credit: { id: "id", name: "name" },
                    expired_grant_count: 1,
                    feature: { id: "id", name: "name" },
                    feature_id: "feature_id",
                    first_transaction_at: "2024-01-15T09:30:00Z",
                    free_grant_count: 1,
                    grant_count: 1,
                    last_transaction_at: "2024-01-15T09:30:00Z",
                    manually_zeroed_count: 1,
                    net_change: 1.1,
                    plan_grant_count: 1,
                    purchased_grant_count: 1,
                    time_bucket: "2024-01-15T09:30:00Z",
                    total_consumed: 1.1,
                    total_granted: 1.1,
                    transaction_count: 1,
                    usage_count: 1,
                    zeroed_out_count: 1,
                },
            ],
            params: {
                billing_credit_id: "billing_credit_id",
                company_id: "company_id",
                end_time: "end_time",
                feature_id: "feature_id",
                limit: 1,
                offset: 1,
                period: "daily",
                start_time: "start_time",
            },
        };
        server
            .mockEndpoint()
            .get("/billing/credits/ledger")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.credits.getEnrichedCreditLedger({
            company_id: "company_id",
            billing_credit_id: "billing_credit_id",
            feature_id: "feature_id",
            period: "daily",
            start_time: "start_time",
            end_time: "end_time",
            limit: 1,
            offset: 1,
        });
        expect(response).toEqual({
            data: [
                {
                    billing_credit_id: "billing_credit_id",
                    company: {
                        id: "id",
                        name: "name",
                    },
                    company_id: "company_id",
                    credit: {
                        id: "id",
                        name: "name",
                    },
                    expired_grant_count: 1,
                    feature: {
                        id: "id",
                        name: "name",
                    },
                    feature_id: "feature_id",
                    first_transaction_at: "2024-01-15T09:30:00Z",
                    free_grant_count: 1,
                    grant_count: 1,
                    last_transaction_at: "2024-01-15T09:30:00Z",
                    manually_zeroed_count: 1,
                    net_change: 1.1,
                    plan_grant_count: 1,
                    purchased_grant_count: 1,
                    time_bucket: "2024-01-15T09:30:00Z",
                    total_consumed: 1.1,
                    total_granted: 1.1,
                    transaction_count: 1,
                    usage_count: 1,
                    zeroed_out_count: 1,
                },
            ],
            params: {
                billing_credit_id: "billing_credit_id",
                company_id: "company_id",
                end_time: "end_time",
                feature_id: "feature_id",
                limit: 1,
                offset: 1,
                period: "daily",
                start_time: "start_time",
            },
        });
    });

    test("getEnrichedCreditLedger (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/ledger")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.getEnrichedCreditLedger({
                company_id: "company_id",
                period: "daily",
            });
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("getEnrichedCreditLedger (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/ledger")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.getEnrichedCreditLedger({
                company_id: "company_id",
                period: "daily",
            });
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("getEnrichedCreditLedger (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/ledger")
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.getEnrichedCreditLedger({
                company_id: "company_id",
                period: "daily",
            });
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("getEnrichedCreditLedger (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/ledger")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.getEnrichedCreditLedger({
                company_id: "company_id",
                period: "daily",
            });
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("getEnrichedCreditLedger (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/ledger")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.getEnrichedCreditLedger({
                company_id: "company_id",
                period: "daily",
            });
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("countCreditLedger (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            data: { count: 1 },
            params: {
                billing_credit_id: "billing_credit_id",
                company_id: "company_id",
                end_time: "end_time",
                feature_id: "feature_id",
                limit: 1,
                offset: 1,
                period: "daily",
                start_time: "start_time",
            },
        };
        server
            .mockEndpoint()
            .get("/billing/credits/ledger/count")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.credits.countCreditLedger({
            company_id: "company_id",
            billing_credit_id: "billing_credit_id",
            feature_id: "feature_id",
            period: "daily",
            start_time: "start_time",
            end_time: "end_time",
            limit: 1,
            offset: 1,
        });
        expect(response).toEqual({
            data: {
                count: 1,
            },
            params: {
                billing_credit_id: "billing_credit_id",
                company_id: "company_id",
                end_time: "end_time",
                feature_id: "feature_id",
                limit: 1,
                offset: 1,
                period: "daily",
                start_time: "start_time",
            },
        });
    });

    test("countCreditLedger (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/ledger/count")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.countCreditLedger({
                company_id: "company_id",
                period: "daily",
            });
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("countCreditLedger (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/ledger/count")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.countCreditLedger({
                company_id: "company_id",
                period: "daily",
            });
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("countCreditLedger (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/ledger/count")
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.countCreditLedger({
                company_id: "company_id",
                period: "daily",
            });
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("countCreditLedger (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/ledger/count")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.countCreditLedger({
                company_id: "company_id",
                period: "daily",
            });
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("countCreditLedger (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/ledger/count")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.countCreditLedger({
                company_id: "company_id",
                period: "daily",
            });
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("listBillingPlanCreditGrants (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            data: [
                {
                    created_at: "2024-01-15T09:30:00Z",
                    credit_amount: 1,
                    credit_id: "credit_id",
                    credit_name: "credit_name",
                    credit_plural_name: "credit_plural_name",
                    credit_singular_name: "credit_singular_name",
                    expiry_type: "expiry_type",
                    expiry_unit: "expiry_unit",
                    expiry_unit_count: 1,
                    id: "id",
                    plan_id: "plan_id",
                    plan_name: "plan_name",
                    reset_cadence: "reset_cadence",
                    reset_start: "reset_start",
                    reset_type: "reset_type",
                    updated_at: "2024-01-15T09:30:00Z",
                },
            ],
            params: {
                credit_id: "credit_id",
                ids: ["ids"],
                limit: 1,
                offset: 1,
                plan_id: "plan_id",
                plan_ids: ["plan_ids"],
            },
        };
        server
            .mockEndpoint()
            .get("/billing/credits/plan-grants")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.credits.listBillingPlanCreditGrants({
            credit_id: "credit_id",
            plan_id: "plan_id",
            limit: 1,
            offset: 1,
        });
        expect(response).toEqual({
            data: [
                {
                    created_at: "2024-01-15T09:30:00Z",
                    credit_amount: 1,
                    credit_id: "credit_id",
                    credit_name: "credit_name",
                    credit_plural_name: "credit_plural_name",
                    credit_singular_name: "credit_singular_name",
                    expiry_type: "expiry_type",
                    expiry_unit: "expiry_unit",
                    expiry_unit_count: 1,
                    id: "id",
                    plan_id: "plan_id",
                    plan_name: "plan_name",
                    reset_cadence: "reset_cadence",
                    reset_start: "reset_start",
                    reset_type: "reset_type",
                    updated_at: "2024-01-15T09:30:00Z",
                },
            ],
            params: {
                credit_id: "credit_id",
                ids: ["ids"],
                limit: 1,
                offset: 1,
                plan_id: "plan_id",
                plan_ids: ["plan_ids"],
            },
        });
    });

    test("listBillingPlanCreditGrants (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/plan-grants")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.listBillingPlanCreditGrants();
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("listBillingPlanCreditGrants (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/plan-grants")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.listBillingPlanCreditGrants();
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("listBillingPlanCreditGrants (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/plan-grants")
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.listBillingPlanCreditGrants();
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("listBillingPlanCreditGrants (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/plan-grants")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.listBillingPlanCreditGrants();
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("listBillingPlanCreditGrants (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/plan-grants")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.listBillingPlanCreditGrants();
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("createBillingPlanCreditGrant (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            credit_amount: 1,
            credit_id: "credit_id",
            plan_id: "plan_id",
            reset_cadence: "monthly",
            reset_start: "billing_period",
        };
        const rawResponseBody = {
            data: {
                created_at: "2024-01-15T09:30:00Z",
                credit_amount: 1,
                credit_id: "credit_id",
                credit_name: "credit_name",
                credit_plural_name: "credit_plural_name",
                credit_singular_name: "credit_singular_name",
                expiry_type: "expiry_type",
                expiry_unit: "expiry_unit",
                expiry_unit_count: 1,
                id: "id",
                plan_id: "plan_id",
                plan_name: "plan_name",
                reset_cadence: "reset_cadence",
                reset_start: "reset_start",
                reset_type: "reset_type",
                updated_at: "2024-01-15T09:30:00Z",
            },
            params: { key: "value" },
        };
        server
            .mockEndpoint()
            .post("/billing/credits/plan-grants")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.credits.createBillingPlanCreditGrant({
            credit_amount: 1,
            credit_id: "credit_id",
            plan_id: "plan_id",
            reset_cadence: "monthly",
            reset_start: "billing_period",
        });
        expect(response).toEqual({
            data: {
                created_at: "2024-01-15T09:30:00Z",
                credit_amount: 1,
                credit_id: "credit_id",
                credit_name: "credit_name",
                credit_plural_name: "credit_plural_name",
                credit_singular_name: "credit_singular_name",
                expiry_type: "expiry_type",
                expiry_unit: "expiry_unit",
                expiry_unit_count: 1,
                id: "id",
                plan_id: "plan_id",
                plan_name: "plan_name",
                reset_cadence: "reset_cadence",
                reset_start: "reset_start",
                reset_type: "reset_type",
                updated_at: "2024-01-15T09:30:00Z",
            },
            params: {
                key: "value",
            },
        });
    });

    test("createBillingPlanCreditGrant (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            credit_amount: 1,
            credit_id: "credit_id",
            plan_id: "plan_id",
            reset_cadence: "monthly",
            reset_start: "billing_period",
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/credits/plan-grants")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.createBillingPlanCreditGrant({
                credit_amount: 1,
                credit_id: "credit_id",
                plan_id: "plan_id",
                reset_cadence: "monthly",
                reset_start: "billing_period",
            });
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("createBillingPlanCreditGrant (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            credit_amount: 1,
            credit_id: "credit_id",
            plan_id: "plan_id",
            reset_cadence: "monthly",
            reset_start: "billing_period",
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/credits/plan-grants")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.createBillingPlanCreditGrant({
                credit_amount: 1,
                credit_id: "credit_id",
                plan_id: "plan_id",
                reset_cadence: "monthly",
                reset_start: "billing_period",
            });
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("createBillingPlanCreditGrant (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            credit_amount: 1,
            credit_id: "credit_id",
            plan_id: "plan_id",
            reset_cadence: "monthly",
            reset_start: "billing_period",
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/credits/plan-grants")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.createBillingPlanCreditGrant({
                credit_amount: 1,
                credit_id: "credit_id",
                plan_id: "plan_id",
                reset_cadence: "monthly",
                reset_start: "billing_period",
            });
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("createBillingPlanCreditGrant (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            credit_amount: 1,
            credit_id: "credit_id",
            plan_id: "plan_id",
            reset_cadence: "monthly",
            reset_start: "billing_period",
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/credits/plan-grants")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.createBillingPlanCreditGrant({
                credit_amount: 1,
                credit_id: "credit_id",
                plan_id: "plan_id",
                reset_cadence: "monthly",
                reset_start: "billing_period",
            });
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("createBillingPlanCreditGrant (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            credit_amount: 1,
            credit_id: "credit_id",
            plan_id: "plan_id",
            reset_cadence: "monthly",
            reset_start: "billing_period",
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/credits/plan-grants")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.createBillingPlanCreditGrant({
                credit_amount: 1,
                credit_id: "credit_id",
                plan_id: "plan_id",
                reset_cadence: "monthly",
                reset_start: "billing_period",
            });
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("deleteBillingPlanCreditGrant (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { data: { deleted: true }, params: { key: "value" } };
        server
            .mockEndpoint()
            .delete("/billing/credits/plan-grants/billing_id")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.credits.deleteBillingPlanCreditGrant("billing_id");
        expect(response).toEqual({
            data: {
                deleted: true,
            },
            params: {
                key: "value",
            },
        });
    });

    test("deleteBillingPlanCreditGrant (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .delete("/billing/credits/plan-grants/billing_id")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.deleteBillingPlanCreditGrant("billing_id");
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("deleteBillingPlanCreditGrant (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .delete("/billing/credits/plan-grants/billing_id")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.deleteBillingPlanCreditGrant("billing_id");
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("deleteBillingPlanCreditGrant (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .delete("/billing/credits/plan-grants/billing_id")
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.deleteBillingPlanCreditGrant("billing_id");
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("deleteBillingPlanCreditGrant (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .delete("/billing/credits/plan-grants/billing_id")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.deleteBillingPlanCreditGrant("billing_id");
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("deleteBillingPlanCreditGrant (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .delete("/billing/credits/plan-grants/billing_id")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.deleteBillingPlanCreditGrant("billing_id");
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("countBillingPlanCreditGrants (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            data: { count: 1 },
            params: {
                credit_id: "credit_id",
                ids: ["ids"],
                limit: 1,
                offset: 1,
                plan_id: "plan_id",
                plan_ids: ["plan_ids"],
            },
        };
        server
            .mockEndpoint()
            .get("/billing/credits/plan-grants/count")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.credits.countBillingPlanCreditGrants({
            credit_id: "credit_id",
            plan_id: "plan_id",
            limit: 1,
            offset: 1,
        });
        expect(response).toEqual({
            data: {
                count: 1,
            },
            params: {
                credit_id: "credit_id",
                ids: ["ids"],
                limit: 1,
                offset: 1,
                plan_id: "plan_id",
                plan_ids: ["plan_ids"],
            },
        });
    });

    test("countBillingPlanCreditGrants (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/plan-grants/count")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.countBillingPlanCreditGrants();
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("countBillingPlanCreditGrants (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/plan-grants/count")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.countBillingPlanCreditGrants();
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("countBillingPlanCreditGrants (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/plan-grants/count")
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.countBillingPlanCreditGrants();
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("countBillingPlanCreditGrants (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/plan-grants/count")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.countBillingPlanCreditGrants();
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("countBillingPlanCreditGrants (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/plan-grants/count")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.countBillingPlanCreditGrants();
        }).rejects.toThrow(Schematic.InternalServerError);
    });
});
