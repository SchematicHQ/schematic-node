// This file was auto-generated by Fern from our API Definition.

import * as Schematic from "../../src/api/index";
import { SchematicClient } from "../../src/Client";
import { mockServerPool } from "../mock-server/MockServerPool";

describe("CreditsClient", () => {
    test("listBillingCredits (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            data: [
                {
                    burn_strategy: "expiration_priority",
                    created_at: "2024-01-15T09:30:00Z",
                    default_expiry_unit: "billing_periods",
                    default_expiry_unit_count: 1,
                    default_rollover_policy: "expire",
                    description: "description",
                    icon: "icon",
                    id: "id",
                    name: "name",
                    plural_name: "plural_name",
                    price: {
                        currency: "currency",
                        external_price_id: "external_price_id",
                        id: "id",
                        interval: "day",
                        price: 1,
                        provider_type: "schematic",
                        scheme: "per_unit",
                    },
                    product: {
                        account_id: "account_id",
                        created_at: "2024-01-15T09:30:00Z",
                        environment_id: "environment_id",
                        external_id: "external_id",
                        is_active: true,
                        name: "name",
                        price: 1.1,
                        product_id: "product_id",
                        provider_type: "schematic",
                        quantity: 1.1,
                        updated_at: "2024-01-15T09:30:00Z",
                    },
                    singular_name: "singular_name",
                    updated_at: "2024-01-15T09:30:00Z",
                },
            ],
            params: { ids: ["ids"], limit: 1, name: "name", offset: 1 },
        };
        server.mockEndpoint().get("/billing/credits").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.credits.listBillingCredits({
            name: "name",
            limit: 1,
            offset: 1,
        });
        expect(response).toEqual({
            data: [
                {
                    burnStrategy: "expiration_priority",
                    createdAt: new Date("2024-01-15T09:30:00.000Z"),
                    defaultExpiryUnit: "billing_periods",
                    defaultExpiryUnitCount: 1,
                    defaultRolloverPolicy: "expire",
                    description: "description",
                    icon: "icon",
                    id: "id",
                    name: "name",
                    pluralName: "plural_name",
                    price: {
                        currency: "currency",
                        externalPriceId: "external_price_id",
                        id: "id",
                        interval: "day",
                        price: 1,
                        providerType: "schematic",
                        scheme: "per_unit",
                    },
                    product: {
                        accountId: "account_id",
                        createdAt: new Date("2024-01-15T09:30:00.000Z"),
                        environmentId: "environment_id",
                        externalId: "external_id",
                        isActive: true,
                        name: "name",
                        price: 1.1,
                        productId: "product_id",
                        providerType: "schematic",
                        quantity: 1.1,
                        updatedAt: new Date("2024-01-15T09:30:00.000Z"),
                    },
                    singularName: "singular_name",
                    updatedAt: new Date("2024-01-15T09:30:00.000Z"),
                },
            ],
            params: {
                ids: ["ids"],
                limit: 1,
                name: "name",
                offset: 1,
            },
        });
    });

    test("listBillingCredits (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/credits").respondWith().statusCode(400).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.credits.listBillingCredits();
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("listBillingCredits (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/credits").respondWith().statusCode(401).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.credits.listBillingCredits();
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("listBillingCredits (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/credits").respondWith().statusCode(403).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.credits.listBillingCredits();
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("listBillingCredits (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/credits").respondWith().statusCode(404).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.credits.listBillingCredits();
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("listBillingCredits (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/billing/credits").respondWith().statusCode(500).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.credits.listBillingCredits();
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("createBillingCredit (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { currency: "currency", description: "description", name: "name" };
        const rawResponseBody = {
            data: {
                burn_strategy: "expiration_priority",
                created_at: "2024-01-15T09:30:00Z",
                default_expiry_unit: "billing_periods",
                default_expiry_unit_count: 1,
                default_rollover_policy: "expire",
                description: "description",
                icon: "icon",
                id: "id",
                name: "name",
                plural_name: "plural_name",
                price: {
                    currency: "currency",
                    external_price_id: "external_price_id",
                    id: "id",
                    interval: "day",
                    price: 1,
                    price_decimal: "price_decimal",
                    provider_type: "schematic",
                    scheme: "per_unit",
                },
                product: {
                    account_id: "account_id",
                    created_at: "2024-01-15T09:30:00Z",
                    environment_id: "environment_id",
                    external_id: "external_id",
                    is_active: true,
                    name: "name",
                    price: 1.1,
                    price_decimal: "price_decimal",
                    product_id: "product_id",
                    provider_type: "schematic",
                    quantity: 1.1,
                    updated_at: "2024-01-15T09:30:00Z",
                },
                singular_name: "singular_name",
                updated_at: "2024-01-15T09:30:00Z",
            },
            params: { key: "value" },
        };
        server
            .mockEndpoint()
            .post("/billing/credits")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.credits.createBillingCredit({
            currency: "currency",
            description: "description",
            name: "name",
        });
        expect(response).toEqual({
            data: {
                burnStrategy: "expiration_priority",
                createdAt: new Date("2024-01-15T09:30:00.000Z"),
                defaultExpiryUnit: "billing_periods",
                defaultExpiryUnitCount: 1,
                defaultRolloverPolicy: "expire",
                description: "description",
                icon: "icon",
                id: "id",
                name: "name",
                pluralName: "plural_name",
                price: {
                    currency: "currency",
                    externalPriceId: "external_price_id",
                    id: "id",
                    interval: "day",
                    price: 1,
                    priceDecimal: "price_decimal",
                    providerType: "schematic",
                    scheme: "per_unit",
                },
                product: {
                    accountId: "account_id",
                    createdAt: new Date("2024-01-15T09:30:00.000Z"),
                    environmentId: "environment_id",
                    externalId: "external_id",
                    isActive: true,
                    name: "name",
                    price: 1.1,
                    priceDecimal: "price_decimal",
                    productId: "product_id",
                    providerType: "schematic",
                    quantity: 1.1,
                    updatedAt: new Date("2024-01-15T09:30:00.000Z"),
                },
                singularName: "singular_name",
                updatedAt: new Date("2024-01-15T09:30:00.000Z"),
            },
            params: {
                key: "value",
            },
        });
    });

    test("createBillingCredit (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { currency: "currency", description: "description", name: "name" };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/credits")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.createBillingCredit({
                currency: "currency",
                description: "description",
                name: "name",
            });
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("createBillingCredit (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { currency: "currency", description: "description", name: "name" };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/credits")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.createBillingCredit({
                currency: "currency",
                description: "description",
                name: "name",
            });
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("createBillingCredit (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { currency: "currency", description: "description", name: "name" };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/credits")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.createBillingCredit({
                currency: "currency",
                description: "description",
                name: "name",
            });
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("createBillingCredit (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { currency: "currency", description: "description", name: "name" };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/credits")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.createBillingCredit({
                currency: "currency",
                description: "description",
                name: "name",
            });
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("createBillingCredit (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { currency: "currency", description: "description", name: "name" };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/credits")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.createBillingCredit({
                currency: "currency",
                description: "description",
                name: "name",
            });
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("getSingleBillingCredit (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            data: {
                burn_strategy: "expiration_priority",
                created_at: "2024-01-15T09:30:00Z",
                default_expiry_unit: "billing_periods",
                default_expiry_unit_count: 1,
                default_rollover_policy: "expire",
                description: "description",
                icon: "icon",
                id: "id",
                name: "name",
                plural_name: "plural_name",
                price: {
                    currency: "currency",
                    external_price_id: "external_price_id",
                    id: "id",
                    interval: "day",
                    price: 1,
                    price_decimal: "price_decimal",
                    provider_type: "schematic",
                    scheme: "per_unit",
                },
                product: {
                    account_id: "account_id",
                    created_at: "2024-01-15T09:30:00Z",
                    environment_id: "environment_id",
                    external_id: "external_id",
                    is_active: true,
                    name: "name",
                    price: 1.1,
                    price_decimal: "price_decimal",
                    product_id: "product_id",
                    provider_type: "schematic",
                    quantity: 1.1,
                    updated_at: "2024-01-15T09:30:00Z",
                },
                singular_name: "singular_name",
                updated_at: "2024-01-15T09:30:00Z",
            },
            params: { key: "value" },
        };
        server
            .mockEndpoint()
            .get("/billing/credits/credit_id")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.credits.getSingleBillingCredit("credit_id");
        expect(response).toEqual({
            data: {
                burnStrategy: "expiration_priority",
                createdAt: new Date("2024-01-15T09:30:00.000Z"),
                defaultExpiryUnit: "billing_periods",
                defaultExpiryUnitCount: 1,
                defaultRolloverPolicy: "expire",
                description: "description",
                icon: "icon",
                id: "id",
                name: "name",
                pluralName: "plural_name",
                price: {
                    currency: "currency",
                    externalPriceId: "external_price_id",
                    id: "id",
                    interval: "day",
                    price: 1,
                    priceDecimal: "price_decimal",
                    providerType: "schematic",
                    scheme: "per_unit",
                },
                product: {
                    accountId: "account_id",
                    createdAt: new Date("2024-01-15T09:30:00.000Z"),
                    environmentId: "environment_id",
                    externalId: "external_id",
                    isActive: true,
                    name: "name",
                    price: 1.1,
                    priceDecimal: "price_decimal",
                    productId: "product_id",
                    providerType: "schematic",
                    quantity: 1.1,
                    updatedAt: new Date("2024-01-15T09:30:00.000Z"),
                },
                singularName: "singular_name",
                updatedAt: new Date("2024-01-15T09:30:00.000Z"),
            },
            params: {
                key: "value",
            },
        });
    });

    test("getSingleBillingCredit (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/credit_id")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.getSingleBillingCredit("credit_id");
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("getSingleBillingCredit (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/credit_id")
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.getSingleBillingCredit("credit_id");
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("getSingleBillingCredit (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/credit_id")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.getSingleBillingCredit("credit_id");
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("getSingleBillingCredit (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/credit_id")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.getSingleBillingCredit("credit_id");
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("updateBillingCredit (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { description: "description", name: "name" };
        const rawResponseBody = {
            data: {
                burn_strategy: "expiration_priority",
                created_at: "2024-01-15T09:30:00Z",
                default_expiry_unit: "billing_periods",
                default_expiry_unit_count: 1,
                default_rollover_policy: "expire",
                description: "description",
                icon: "icon",
                id: "id",
                name: "name",
                plural_name: "plural_name",
                price: {
                    currency: "currency",
                    external_price_id: "external_price_id",
                    id: "id",
                    interval: "day",
                    price: 1,
                    price_decimal: "price_decimal",
                    provider_type: "schematic",
                    scheme: "per_unit",
                },
                product: {
                    account_id: "account_id",
                    created_at: "2024-01-15T09:30:00Z",
                    environment_id: "environment_id",
                    external_id: "external_id",
                    is_active: true,
                    name: "name",
                    price: 1.1,
                    price_decimal: "price_decimal",
                    product_id: "product_id",
                    provider_type: "schematic",
                    quantity: 1.1,
                    updated_at: "2024-01-15T09:30:00Z",
                },
                singular_name: "singular_name",
                updated_at: "2024-01-15T09:30:00Z",
            },
            params: { key: "value" },
        };
        server
            .mockEndpoint()
            .put("/billing/credits/credit_id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.credits.updateBillingCredit("credit_id", {
            description: "description",
            name: "name",
        });
        expect(response).toEqual({
            data: {
                burnStrategy: "expiration_priority",
                createdAt: new Date("2024-01-15T09:30:00.000Z"),
                defaultExpiryUnit: "billing_periods",
                defaultExpiryUnitCount: 1,
                defaultRolloverPolicy: "expire",
                description: "description",
                icon: "icon",
                id: "id",
                name: "name",
                pluralName: "plural_name",
                price: {
                    currency: "currency",
                    externalPriceId: "external_price_id",
                    id: "id",
                    interval: "day",
                    price: 1,
                    priceDecimal: "price_decimal",
                    providerType: "schematic",
                    scheme: "per_unit",
                },
                product: {
                    accountId: "account_id",
                    createdAt: new Date("2024-01-15T09:30:00.000Z"),
                    environmentId: "environment_id",
                    externalId: "external_id",
                    isActive: true,
                    name: "name",
                    price: 1.1,
                    priceDecimal: "price_decimal",
                    productId: "product_id",
                    providerType: "schematic",
                    quantity: 1.1,
                    updatedAt: new Date("2024-01-15T09:30:00.000Z"),
                },
                singularName: "singular_name",
                updatedAt: new Date("2024-01-15T09:30:00.000Z"),
            },
            params: {
                key: "value",
            },
        });
    });

    test("updateBillingCredit (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { description: "description", name: "name" };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .put("/billing/credits/credit_id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.updateBillingCredit("credit_id", {
                description: "description",
                name: "name",
            });
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("updateBillingCredit (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { description: "description", name: "name" };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .put("/billing/credits/credit_id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.updateBillingCredit("credit_id", {
                description: "description",
                name: "name",
            });
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("updateBillingCredit (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { description: "description", name: "name" };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .put("/billing/credits/credit_id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.updateBillingCredit("credit_id", {
                description: "description",
                name: "name",
            });
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("updateBillingCredit (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { description: "description", name: "name" };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .put("/billing/credits/credit_id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.updateBillingCredit("credit_id", {
                description: "description",
                name: "name",
            });
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("updateBillingCredit (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { description: "description", name: "name" };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .put("/billing/credits/credit_id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.updateBillingCredit("credit_id", {
                description: "description",
                name: "name",
            });
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("softDeleteBillingCredit (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { data: { deleted: true }, params: { key: "value" } };
        server
            .mockEndpoint()
            .delete("/billing/credits/credit_id")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.credits.softDeleteBillingCredit("credit_id");
        expect(response).toEqual({
            data: {
                deleted: true,
            },
            params: {
                key: "value",
            },
        });
    });

    test("softDeleteBillingCredit (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .delete("/billing/credits/credit_id")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.softDeleteBillingCredit("credit_id");
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("softDeleteBillingCredit (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .delete("/billing/credits/credit_id")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.softDeleteBillingCredit("credit_id");
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("softDeleteBillingCredit (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .delete("/billing/credits/credit_id")
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.softDeleteBillingCredit("credit_id");
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("softDeleteBillingCredit (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .delete("/billing/credits/credit_id")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.softDeleteBillingCredit("credit_id");
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("softDeleteBillingCredit (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .delete("/billing/credits/credit_id")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.softDeleteBillingCredit("credit_id");
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("listCreditBundles (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            data: [
                {
                    billing_invoice_id: "billing_invoice_id",
                    bundle_type: "fixed",
                    created_at: "2024-01-15T09:30:00Z",
                    credit_description: "credit_description",
                    credit_icon: "credit_icon",
                    credit_id: "credit_id",
                    credit_name: "credit_name",
                    expiry_type: "duration",
                    expiry_unit: "billing_periods",
                    expiry_unit_count: 1,
                    has_grants: true,
                    id: "id",
                    name: "name",
                    plural_name: "plural_name",
                    price: {
                        currency: "currency",
                        external_price_id: "external_price_id",
                        id: "id",
                        interval: "day",
                        price: 1,
                        provider_type: "schematic",
                        scheme: "per_unit",
                    },
                    quantity: 1,
                    singular_name: "singular_name",
                    status: "active",
                    unit_price: {
                        currency: "currency",
                        external_price_id: "external_price_id",
                        id: "id",
                        interval: "day",
                        price: 1,
                        provider_type: "schematic",
                        scheme: "per_unit",
                    },
                    updated_at: "2024-01-15T09:30:00Z",
                },
            ],
            params: {
                bundle_type: "fixed",
                credit_id: "credit_id",
                ids: ["ids"],
                limit: 1,
                offset: 1,
                status: "active",
            },
        };
        server
            .mockEndpoint()
            .get("/billing/credits/bundles")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.credits.listCreditBundles({
            creditId: "credit_id",
            status: "active",
            bundleType: "fixed",
            limit: 1,
            offset: 1,
        });
        expect(response).toEqual({
            data: [
                {
                    billingInvoiceId: "billing_invoice_id",
                    bundleType: "fixed",
                    createdAt: new Date("2024-01-15T09:30:00.000Z"),
                    creditDescription: "credit_description",
                    creditIcon: "credit_icon",
                    creditId: "credit_id",
                    creditName: "credit_name",
                    expiryType: "duration",
                    expiryUnit: "billing_periods",
                    expiryUnitCount: 1,
                    hasGrants: true,
                    id: "id",
                    name: "name",
                    pluralName: "plural_name",
                    price: {
                        currency: "currency",
                        externalPriceId: "external_price_id",
                        id: "id",
                        interval: "day",
                        price: 1,
                        providerType: "schematic",
                        scheme: "per_unit",
                    },
                    quantity: 1,
                    singularName: "singular_name",
                    status: "active",
                    unitPrice: {
                        currency: "currency",
                        externalPriceId: "external_price_id",
                        id: "id",
                        interval: "day",
                        price: 1,
                        providerType: "schematic",
                        scheme: "per_unit",
                    },
                    updatedAt: new Date("2024-01-15T09:30:00.000Z"),
                },
            ],
            params: {
                bundleType: "fixed",
                creditId: "credit_id",
                ids: ["ids"],
                limit: 1,
                offset: 1,
                status: "active",
            },
        });
    });

    test("listCreditBundles (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/bundles")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.listCreditBundles();
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("listCreditBundles (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/bundles")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.listCreditBundles();
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("listCreditBundles (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/bundles")
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.listCreditBundles();
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("listCreditBundles (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/bundles")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.listCreditBundles();
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("listCreditBundles (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/bundles")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.listCreditBundles();
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("createCreditBundle (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            bundle_name: "bundle_name",
            credit_id: "credit_id",
            currency: "currency",
            price_per_unit: 1,
        };
        const rawResponseBody = {
            data: {
                billing_invoice_id: "billing_invoice_id",
                bundle_type: "fixed",
                created_at: "2024-01-15T09:30:00Z",
                credit_description: "credit_description",
                credit_icon: "credit_icon",
                credit_id: "credit_id",
                credit_name: "credit_name",
                expiry_type: "duration",
                expiry_unit: "billing_periods",
                expiry_unit_count: 1,
                has_grants: true,
                id: "id",
                name: "name",
                plural_name: "plural_name",
                price: {
                    currency: "currency",
                    external_price_id: "external_price_id",
                    id: "id",
                    interval: "day",
                    price: 1,
                    price_decimal: "price_decimal",
                    provider_type: "schematic",
                    scheme: "per_unit",
                },
                quantity: 1,
                singular_name: "singular_name",
                status: "active",
                unit_price: {
                    currency: "currency",
                    external_price_id: "external_price_id",
                    id: "id",
                    interval: "day",
                    price: 1,
                    price_decimal: "price_decimal",
                    provider_type: "schematic",
                    scheme: "per_unit",
                },
                updated_at: "2024-01-15T09:30:00Z",
            },
            params: { key: "value" },
        };
        server
            .mockEndpoint()
            .post("/billing/credits/bundles")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.credits.createCreditBundle({
            bundleName: "bundle_name",
            creditId: "credit_id",
            currency: "currency",
            pricePerUnit: 1,
        });
        expect(response).toEqual({
            data: {
                billingInvoiceId: "billing_invoice_id",
                bundleType: "fixed",
                createdAt: new Date("2024-01-15T09:30:00.000Z"),
                creditDescription: "credit_description",
                creditIcon: "credit_icon",
                creditId: "credit_id",
                creditName: "credit_name",
                expiryType: "duration",
                expiryUnit: "billing_periods",
                expiryUnitCount: 1,
                hasGrants: true,
                id: "id",
                name: "name",
                pluralName: "plural_name",
                price: {
                    currency: "currency",
                    externalPriceId: "external_price_id",
                    id: "id",
                    interval: "day",
                    price: 1,
                    priceDecimal: "price_decimal",
                    providerType: "schematic",
                    scheme: "per_unit",
                },
                quantity: 1,
                singularName: "singular_name",
                status: "active",
                unitPrice: {
                    currency: "currency",
                    externalPriceId: "external_price_id",
                    id: "id",
                    interval: "day",
                    price: 1,
                    priceDecimal: "price_decimal",
                    providerType: "schematic",
                    scheme: "per_unit",
                },
                updatedAt: new Date("2024-01-15T09:30:00.000Z"),
            },
            params: {
                key: "value",
            },
        });
    });

    test("createCreditBundle (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            bundle_name: "bundle_name",
            credit_id: "credit_id",
            currency: "currency",
            price_per_unit: 1,
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/credits/bundles")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.createCreditBundle({
                bundleName: "bundle_name",
                creditId: "credit_id",
                currency: "currency",
                pricePerUnit: 1,
            });
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("createCreditBundle (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            bundle_name: "bundle_name",
            credit_id: "credit_id",
            currency: "currency",
            price_per_unit: 1,
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/credits/bundles")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.createCreditBundle({
                bundleName: "bundle_name",
                creditId: "credit_id",
                currency: "currency",
                pricePerUnit: 1,
            });
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("createCreditBundle (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            bundle_name: "bundle_name",
            credit_id: "credit_id",
            currency: "currency",
            price_per_unit: 1,
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/credits/bundles")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.createCreditBundle({
                bundleName: "bundle_name",
                creditId: "credit_id",
                currency: "currency",
                pricePerUnit: 1,
            });
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("createCreditBundle (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            bundle_name: "bundle_name",
            credit_id: "credit_id",
            currency: "currency",
            price_per_unit: 1,
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/credits/bundles")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.createCreditBundle({
                bundleName: "bundle_name",
                creditId: "credit_id",
                currency: "currency",
                pricePerUnit: 1,
            });
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("createCreditBundle (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            bundle_name: "bundle_name",
            credit_id: "credit_id",
            currency: "currency",
            price_per_unit: 1,
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/credits/bundles")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.createCreditBundle({
                bundleName: "bundle_name",
                creditId: "credit_id",
                currency: "currency",
                pricePerUnit: 1,
            });
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("getCreditBundle (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            data: {
                billing_invoice_id: "billing_invoice_id",
                bundle_type: "fixed",
                created_at: "2024-01-15T09:30:00Z",
                credit_description: "credit_description",
                credit_icon: "credit_icon",
                credit_id: "credit_id",
                credit_name: "credit_name",
                expiry_type: "duration",
                expiry_unit: "billing_periods",
                expiry_unit_count: 1,
                has_grants: true,
                id: "id",
                name: "name",
                plural_name: "plural_name",
                price: {
                    currency: "currency",
                    external_price_id: "external_price_id",
                    id: "id",
                    interval: "day",
                    price: 1,
                    price_decimal: "price_decimal",
                    provider_type: "schematic",
                    scheme: "per_unit",
                },
                quantity: 1,
                singular_name: "singular_name",
                status: "active",
                unit_price: {
                    currency: "currency",
                    external_price_id: "external_price_id",
                    id: "id",
                    interval: "day",
                    price: 1,
                    price_decimal: "price_decimal",
                    provider_type: "schematic",
                    scheme: "per_unit",
                },
                updated_at: "2024-01-15T09:30:00Z",
            },
            params: { key: "value" },
        };
        server
            .mockEndpoint()
            .get("/billing/credits/bundles/bundle_id")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.credits.getCreditBundle("bundle_id");
        expect(response).toEqual({
            data: {
                billingInvoiceId: "billing_invoice_id",
                bundleType: "fixed",
                createdAt: new Date("2024-01-15T09:30:00.000Z"),
                creditDescription: "credit_description",
                creditIcon: "credit_icon",
                creditId: "credit_id",
                creditName: "credit_name",
                expiryType: "duration",
                expiryUnit: "billing_periods",
                expiryUnitCount: 1,
                hasGrants: true,
                id: "id",
                name: "name",
                pluralName: "plural_name",
                price: {
                    currency: "currency",
                    externalPriceId: "external_price_id",
                    id: "id",
                    interval: "day",
                    price: 1,
                    priceDecimal: "price_decimal",
                    providerType: "schematic",
                    scheme: "per_unit",
                },
                quantity: 1,
                singularName: "singular_name",
                status: "active",
                unitPrice: {
                    currency: "currency",
                    externalPriceId: "external_price_id",
                    id: "id",
                    interval: "day",
                    price: 1,
                    priceDecimal: "price_decimal",
                    providerType: "schematic",
                    scheme: "per_unit",
                },
                updatedAt: new Date("2024-01-15T09:30:00.000Z"),
            },
            params: {
                key: "value",
            },
        });
    });

    test("getCreditBundle (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/bundles/bundle_id")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.getCreditBundle("bundle_id");
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("getCreditBundle (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/bundles/bundle_id")
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.getCreditBundle("bundle_id");
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("getCreditBundle (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/bundles/bundle_id")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.getCreditBundle("bundle_id");
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("getCreditBundle (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/bundles/bundle_id")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.getCreditBundle("bundle_id");
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("updateCreditBundleDetails (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { bundle_name: "bundle_name", price_per_unit: 1 };
        const rawResponseBody = {
            data: {
                billing_invoice_id: "billing_invoice_id",
                bundle_type: "fixed",
                created_at: "2024-01-15T09:30:00Z",
                credit_description: "credit_description",
                credit_icon: "credit_icon",
                credit_id: "credit_id",
                credit_name: "credit_name",
                expiry_type: "duration",
                expiry_unit: "billing_periods",
                expiry_unit_count: 1,
                has_grants: true,
                id: "id",
                name: "name",
                plural_name: "plural_name",
                price: {
                    currency: "currency",
                    external_price_id: "external_price_id",
                    id: "id",
                    interval: "day",
                    price: 1,
                    price_decimal: "price_decimal",
                    provider_type: "schematic",
                    scheme: "per_unit",
                },
                quantity: 1,
                singular_name: "singular_name",
                status: "active",
                unit_price: {
                    currency: "currency",
                    external_price_id: "external_price_id",
                    id: "id",
                    interval: "day",
                    price: 1,
                    price_decimal: "price_decimal",
                    provider_type: "schematic",
                    scheme: "per_unit",
                },
                updated_at: "2024-01-15T09:30:00Z",
            },
            params: { key: "value" },
        };
        server
            .mockEndpoint()
            .put("/billing/credits/bundles/bundle_id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.credits.updateCreditBundleDetails("bundle_id", {
            bundleName: "bundle_name",
            pricePerUnit: 1,
        });
        expect(response).toEqual({
            data: {
                billingInvoiceId: "billing_invoice_id",
                bundleType: "fixed",
                createdAt: new Date("2024-01-15T09:30:00.000Z"),
                creditDescription: "credit_description",
                creditIcon: "credit_icon",
                creditId: "credit_id",
                creditName: "credit_name",
                expiryType: "duration",
                expiryUnit: "billing_periods",
                expiryUnitCount: 1,
                hasGrants: true,
                id: "id",
                name: "name",
                pluralName: "plural_name",
                price: {
                    currency: "currency",
                    externalPriceId: "external_price_id",
                    id: "id",
                    interval: "day",
                    price: 1,
                    priceDecimal: "price_decimal",
                    providerType: "schematic",
                    scheme: "per_unit",
                },
                quantity: 1,
                singularName: "singular_name",
                status: "active",
                unitPrice: {
                    currency: "currency",
                    externalPriceId: "external_price_id",
                    id: "id",
                    interval: "day",
                    price: 1,
                    priceDecimal: "price_decimal",
                    providerType: "schematic",
                    scheme: "per_unit",
                },
                updatedAt: new Date("2024-01-15T09:30:00.000Z"),
            },
            params: {
                key: "value",
            },
        });
    });

    test("updateCreditBundleDetails (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { bundle_name: "bundle_name", price_per_unit: 1 };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .put("/billing/credits/bundles/bundle_id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.updateCreditBundleDetails("bundle_id", {
                bundleName: "bundle_name",
                pricePerUnit: 1,
            });
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("updateCreditBundleDetails (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { bundle_name: "bundle_name", price_per_unit: 1 };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .put("/billing/credits/bundles/bundle_id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.updateCreditBundleDetails("bundle_id", {
                bundleName: "bundle_name",
                pricePerUnit: 1,
            });
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("updateCreditBundleDetails (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { bundle_name: "bundle_name", price_per_unit: 1 };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .put("/billing/credits/bundles/bundle_id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.updateCreditBundleDetails("bundle_id", {
                bundleName: "bundle_name",
                pricePerUnit: 1,
            });
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("updateCreditBundleDetails (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { bundle_name: "bundle_name", price_per_unit: 1 };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .put("/billing/credits/bundles/bundle_id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.updateCreditBundleDetails("bundle_id", {
                bundleName: "bundle_name",
                pricePerUnit: 1,
            });
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("updateCreditBundleDetails (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { bundle_name: "bundle_name", price_per_unit: 1 };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .put("/billing/credits/bundles/bundle_id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.updateCreditBundleDetails("bundle_id", {
                bundleName: "bundle_name",
                pricePerUnit: 1,
            });
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("deleteCreditBundle (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { data: { deleted: true }, params: { key: "value" } };
        server
            .mockEndpoint()
            .delete("/billing/credits/bundles/bundle_id")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.credits.deleteCreditBundle("bundle_id");
        expect(response).toEqual({
            data: {
                deleted: true,
            },
            params: {
                key: "value",
            },
        });
    });

    test("deleteCreditBundle (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .delete("/billing/credits/bundles/bundle_id")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.deleteCreditBundle("bundle_id");
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("deleteCreditBundle (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .delete("/billing/credits/bundles/bundle_id")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.deleteCreditBundle("bundle_id");
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("deleteCreditBundle (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .delete("/billing/credits/bundles/bundle_id")
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.deleteCreditBundle("bundle_id");
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("deleteCreditBundle (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .delete("/billing/credits/bundles/bundle_id")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.deleteCreditBundle("bundle_id");
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("deleteCreditBundle (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .delete("/billing/credits/bundles/bundle_id")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.deleteCreditBundle("bundle_id");
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("countCreditBundles (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            data: { count: 1 },
            params: {
                bundle_type: "fixed",
                credit_id: "credit_id",
                ids: ["ids"],
                limit: 1,
                offset: 1,
                status: "active",
            },
        };
        server
            .mockEndpoint()
            .get("/billing/credits/bundles/count")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.credits.countCreditBundles({
            creditId: "credit_id",
            status: "active",
            bundleType: "fixed",
            limit: 1,
            offset: 1,
        });
        expect(response).toEqual({
            data: {
                count: 1,
            },
            params: {
                bundleType: "fixed",
                creditId: "credit_id",
                ids: ["ids"],
                limit: 1,
                offset: 1,
                status: "active",
            },
        });
    });

    test("countCreditBundles (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/bundles/count")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.countCreditBundles();
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("countCreditBundles (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/bundles/count")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.countCreditBundles();
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("countCreditBundles (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/bundles/count")
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.countCreditBundles();
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("countCreditBundles (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/bundles/count")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.countCreditBundles();
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("countCreditBundles (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/bundles/count")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.countCreditBundles();
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("countBillingCredits (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { data: { count: 1 }, params: { ids: ["ids"], limit: 1, name: "name", offset: 1 } };
        server
            .mockEndpoint()
            .get("/billing/credits/count")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.credits.countBillingCredits({
            name: "name",
            limit: 1,
            offset: 1,
        });
        expect(response).toEqual({
            data: {
                count: 1,
            },
            params: {
                ids: ["ids"],
                limit: 1,
                name: "name",
                offset: 1,
            },
        });
    });

    test("countBillingCredits (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/count")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.countBillingCredits();
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("countBillingCredits (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/count")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.countBillingCredits();
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("countBillingCredits (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/count")
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.countBillingCredits();
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("countBillingCredits (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/count")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.countBillingCredits();
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("countBillingCredits (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/count")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.countBillingCredits();
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("zeroOutGrant (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = {
            data: {
                company_id: "company_id",
                company_name: "company_name",
                created_at: "2024-01-15T09:30:00Z",
                credit_icon: "credit_icon",
                credit_id: "credit_id",
                credit_name: "credit_name",
                expires_at: "2024-01-15T09:30:00Z",
                grant_reason: "billing_credit_auto_topup",
                id: "id",
                plan_id: "plan_id",
                plan_name: "plan_name",
                price: {
                    currency: "currency",
                    external_price_id: "external_price_id",
                    id: "id",
                    interval: "day",
                    price: 1,
                    price_decimal: "price_decimal",
                    provider_type: "schematic",
                    scheme: "per_unit",
                },
                quantity: 1,
                quantity_remaining: 1.1,
                quantity_used: 1.1,
                renewal_enabled: true,
                renewal_period: "daily",
                source_label: "source_label",
                transfers: [
                    {
                        amount: 1.1,
                        created_at: "2024-01-15T09:30:00Z",
                        direction: "direction",
                        id: "id",
                        reason: "reason",
                        related_grant_id: "related_grant_id",
                    },
                ],
                updated_at: "2024-01-15T09:30:00Z",
                valid_from: "2024-01-15T09:30:00Z",
                zeroed_out_date: "2024-01-15T09:30:00Z",
                zeroed_out_reason: "expired",
            },
            params: { key: "value" },
        };
        server
            .mockEndpoint()
            .put("/billing/credits/grants/grant_id/zero-out")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.credits.zeroOutGrant("grant_id");
        expect(response).toEqual({
            data: {
                companyId: "company_id",
                companyName: "company_name",
                createdAt: new Date("2024-01-15T09:30:00.000Z"),
                creditIcon: "credit_icon",
                creditId: "credit_id",
                creditName: "credit_name",
                expiresAt: new Date("2024-01-15T09:30:00.000Z"),
                grantReason: "billing_credit_auto_topup",
                id: "id",
                planId: "plan_id",
                planName: "plan_name",
                price: {
                    currency: "currency",
                    externalPriceId: "external_price_id",
                    id: "id",
                    interval: "day",
                    price: 1,
                    priceDecimal: "price_decimal",
                    providerType: "schematic",
                    scheme: "per_unit",
                },
                quantity: 1,
                quantityRemaining: 1.1,
                quantityUsed: 1.1,
                renewalEnabled: true,
                renewalPeriod: "daily",
                sourceLabel: "source_label",
                transfers: [
                    {
                        amount: 1.1,
                        createdAt: new Date("2024-01-15T09:30:00.000Z"),
                        direction: "direction",
                        id: "id",
                        reason: "reason",
                        relatedGrantId: "related_grant_id",
                    },
                ],
                updatedAt: new Date("2024-01-15T09:30:00.000Z"),
                validFrom: new Date("2024-01-15T09:30:00.000Z"),
                zeroedOutDate: new Date("2024-01-15T09:30:00.000Z"),
                zeroedOutReason: "expired",
            },
            params: {
                key: "value",
            },
        });
    });

    test("zeroOutGrant (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .put("/billing/credits/grants/grant_id/zero-out")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.zeroOutGrant("grant_id");
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("zeroOutGrant (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .put("/billing/credits/grants/grant_id/zero-out")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.zeroOutGrant("grant_id");
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("zeroOutGrant (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .put("/billing/credits/grants/grant_id/zero-out")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.zeroOutGrant("grant_id");
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("zeroOutGrant (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .put("/billing/credits/grants/grant_id/zero-out")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.zeroOutGrant("grant_id");
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("zeroOutGrant (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .put("/billing/credits/grants/grant_id/zero-out")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.zeroOutGrant("grant_id");
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("grantBillingCreditsToCompany (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            company_id: "company_id",
            credit_id: "credit_id",
            quantity: 1,
            reason: "billing_credit_auto_topup",
        };
        const rawResponseBody = {
            data: {
                company_id: "company_id",
                company_name: "company_name",
                created_at: "2024-01-15T09:30:00Z",
                credit_icon: "credit_icon",
                credit_id: "credit_id",
                credit_name: "credit_name",
                expires_at: "2024-01-15T09:30:00Z",
                grant_reason: "billing_credit_auto_topup",
                id: "id",
                plan_id: "plan_id",
                plan_name: "plan_name",
                price: {
                    currency: "currency",
                    external_price_id: "external_price_id",
                    id: "id",
                    interval: "day",
                    price: 1,
                    price_decimal: "price_decimal",
                    provider_type: "schematic",
                    scheme: "per_unit",
                },
                quantity: 1,
                quantity_remaining: 1.1,
                quantity_used: 1.1,
                renewal_enabled: true,
                renewal_period: "daily",
                source_label: "source_label",
                transfers: [
                    {
                        amount: 1.1,
                        created_at: "2024-01-15T09:30:00Z",
                        direction: "direction",
                        id: "id",
                        reason: "reason",
                        related_grant_id: "related_grant_id",
                    },
                ],
                updated_at: "2024-01-15T09:30:00Z",
                valid_from: "2024-01-15T09:30:00Z",
                zeroed_out_date: "2024-01-15T09:30:00Z",
                zeroed_out_reason: "expired",
            },
            params: { key: "value" },
        };
        server
            .mockEndpoint()
            .post("/billing/credits/grants/company")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.credits.grantBillingCreditsToCompany({
            companyId: "company_id",
            creditId: "credit_id",
            quantity: 1,
            reason: "billing_credit_auto_topup",
        });
        expect(response).toEqual({
            data: {
                companyId: "company_id",
                companyName: "company_name",
                createdAt: new Date("2024-01-15T09:30:00.000Z"),
                creditIcon: "credit_icon",
                creditId: "credit_id",
                creditName: "credit_name",
                expiresAt: new Date("2024-01-15T09:30:00.000Z"),
                grantReason: "billing_credit_auto_topup",
                id: "id",
                planId: "plan_id",
                planName: "plan_name",
                price: {
                    currency: "currency",
                    externalPriceId: "external_price_id",
                    id: "id",
                    interval: "day",
                    price: 1,
                    priceDecimal: "price_decimal",
                    providerType: "schematic",
                    scheme: "per_unit",
                },
                quantity: 1,
                quantityRemaining: 1.1,
                quantityUsed: 1.1,
                renewalEnabled: true,
                renewalPeriod: "daily",
                sourceLabel: "source_label",
                transfers: [
                    {
                        amount: 1.1,
                        createdAt: new Date("2024-01-15T09:30:00.000Z"),
                        direction: "direction",
                        id: "id",
                        reason: "reason",
                        relatedGrantId: "related_grant_id",
                    },
                ],
                updatedAt: new Date("2024-01-15T09:30:00.000Z"),
                validFrom: new Date("2024-01-15T09:30:00.000Z"),
                zeroedOutDate: new Date("2024-01-15T09:30:00.000Z"),
                zeroedOutReason: "expired",
            },
            params: {
                key: "value",
            },
        });
    });

    test("grantBillingCreditsToCompany (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            company_id: "company_id",
            credit_id: "credit_id",
            quantity: 1,
            reason: "billing_credit_auto_topup",
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/credits/grants/company")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.grantBillingCreditsToCompany({
                companyId: "company_id",
                creditId: "credit_id",
                quantity: 1,
                reason: "billing_credit_auto_topup",
            });
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("grantBillingCreditsToCompany (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            company_id: "company_id",
            credit_id: "credit_id",
            quantity: 1,
            reason: "billing_credit_auto_topup",
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/credits/grants/company")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.grantBillingCreditsToCompany({
                companyId: "company_id",
                creditId: "credit_id",
                quantity: 1,
                reason: "billing_credit_auto_topup",
            });
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("grantBillingCreditsToCompany (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            company_id: "company_id",
            credit_id: "credit_id",
            quantity: 1,
            reason: "billing_credit_auto_topup",
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/credits/grants/company")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.grantBillingCreditsToCompany({
                companyId: "company_id",
                creditId: "credit_id",
                quantity: 1,
                reason: "billing_credit_auto_topup",
            });
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("grantBillingCreditsToCompany (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            company_id: "company_id",
            credit_id: "credit_id",
            quantity: 1,
            reason: "billing_credit_auto_topup",
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/credits/grants/company")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.grantBillingCreditsToCompany({
                companyId: "company_id",
                creditId: "credit_id",
                quantity: 1,
                reason: "billing_credit_auto_topup",
            });
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("grantBillingCreditsToCompany (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            company_id: "company_id",
            credit_id: "credit_id",
            quantity: 1,
            reason: "billing_credit_auto_topup",
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/credits/grants/company")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.grantBillingCreditsToCompany({
                companyId: "company_id",
                creditId: "credit_id",
                quantity: 1,
                reason: "billing_credit_auto_topup",
            });
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("countCompanyGrants (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            data: { count: 1 },
            params: { company_id: "company_id", dir: "asc", limit: 1, offset: 1, order: "created_at" },
        };
        server
            .mockEndpoint()
            .get("/billing/credits/grants/company/count")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.credits.countCompanyGrants({
            companyId: "company_id",
            order: "created_at",
            dir: "asc",
            limit: 1,
            offset: 1,
        });
        expect(response).toEqual({
            data: {
                count: 1,
            },
            params: {
                companyId: "company_id",
                dir: "asc",
                limit: 1,
                offset: 1,
                order: "created_at",
            },
        });
    });

    test("countCompanyGrants (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/grants/company/count")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.countCompanyGrants();
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("countCompanyGrants (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/grants/company/count")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.countCompanyGrants();
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("countCompanyGrants (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/grants/company/count")
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.countCompanyGrants();
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("countCompanyGrants (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/grants/company/count")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.countCompanyGrants();
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("countCompanyGrants (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/grants/company/count")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.countCompanyGrants();
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("listCompanyGrants (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            data: [
                {
                    company_id: "company_id",
                    company_name: "company_name",
                    created_at: "2024-01-15T09:30:00Z",
                    credit_icon: "credit_icon",
                    credit_id: "credit_id",
                    credit_name: "credit_name",
                    expires_at: "2024-01-15T09:30:00Z",
                    grant_reason: "billing_credit_auto_topup",
                    id: "id",
                    plan_id: "plan_id",
                    plan_name: "plan_name",
                    price: {
                        currency: "currency",
                        external_price_id: "external_price_id",
                        id: "id",
                        interval: "day",
                        price: 1,
                        provider_type: "schematic",
                        scheme: "per_unit",
                    },
                    quantity: 1,
                    quantity_remaining: 1.1,
                    quantity_used: 1.1,
                    renewal_enabled: true,
                    renewal_period: "daily",
                    source_label: "source_label",
                    transfers: [
                        {
                            amount: 1.1,
                            created_at: "2024-01-15T09:30:00Z",
                            direction: "direction",
                            id: "id",
                            reason: "reason",
                            related_grant_id: "related_grant_id",
                        },
                    ],
                    updated_at: "2024-01-15T09:30:00Z",
                    valid_from: "2024-01-15T09:30:00Z",
                    zeroed_out_date: "2024-01-15T09:30:00Z",
                    zeroed_out_reason: "expired",
                },
            ],
            params: { company_id: "company_id", dir: "asc", limit: 1, offset: 1, order: "created_at" },
        };
        server
            .mockEndpoint()
            .get("/billing/credits/grants/company/list")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.credits.listCompanyGrants({
            companyId: "company_id",
            order: "created_at",
            dir: "asc",
            limit: 1,
            offset: 1,
        });
        expect(response).toEqual({
            data: [
                {
                    companyId: "company_id",
                    companyName: "company_name",
                    createdAt: new Date("2024-01-15T09:30:00.000Z"),
                    creditIcon: "credit_icon",
                    creditId: "credit_id",
                    creditName: "credit_name",
                    expiresAt: new Date("2024-01-15T09:30:00.000Z"),
                    grantReason: "billing_credit_auto_topup",
                    id: "id",
                    planId: "plan_id",
                    planName: "plan_name",
                    price: {
                        currency: "currency",
                        externalPriceId: "external_price_id",
                        id: "id",
                        interval: "day",
                        price: 1,
                        providerType: "schematic",
                        scheme: "per_unit",
                    },
                    quantity: 1,
                    quantityRemaining: 1.1,
                    quantityUsed: 1.1,
                    renewalEnabled: true,
                    renewalPeriod: "daily",
                    sourceLabel: "source_label",
                    transfers: [
                        {
                            amount: 1.1,
                            createdAt: new Date("2024-01-15T09:30:00.000Z"),
                            direction: "direction",
                            id: "id",
                            reason: "reason",
                            relatedGrantId: "related_grant_id",
                        },
                    ],
                    updatedAt: new Date("2024-01-15T09:30:00.000Z"),
                    validFrom: new Date("2024-01-15T09:30:00.000Z"),
                    zeroedOutDate: new Date("2024-01-15T09:30:00.000Z"),
                    zeroedOutReason: "expired",
                },
            ],
            params: {
                companyId: "company_id",
                dir: "asc",
                limit: 1,
                offset: 1,
                order: "created_at",
            },
        });
    });

    test("listCompanyGrants (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/grants/company/list")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.listCompanyGrants();
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("listCompanyGrants (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/grants/company/list")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.listCompanyGrants();
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("listCompanyGrants (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/grants/company/list")
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.listCompanyGrants();
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("listCompanyGrants (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/grants/company/list")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.listCompanyGrants();
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("listCompanyGrants (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/grants/company/list")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.listCompanyGrants();
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("countBillingCreditsGrants (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            data: { count: 1 },
            params: { credit_id: "credit_id", ids: ["ids"], limit: 1, offset: 1 },
        };
        server
            .mockEndpoint()
            .get("/billing/credits/grants/count")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.credits.countBillingCreditsGrants({
            creditId: "credit_id",
            limit: 1,
            offset: 1,
        });
        expect(response).toEqual({
            data: {
                count: 1,
            },
            params: {
                creditId: "credit_id",
                ids: ["ids"],
                limit: 1,
                offset: 1,
            },
        });
    });

    test("countBillingCreditsGrants (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/grants/count")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.countBillingCreditsGrants();
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("countBillingCreditsGrants (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/grants/count")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.countBillingCreditsGrants();
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("countBillingCreditsGrants (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/grants/count")
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.countBillingCreditsGrants();
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("countBillingCreditsGrants (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/grants/count")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.countBillingCreditsGrants();
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("countBillingCreditsGrants (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/grants/count")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.countBillingCreditsGrants();
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("listGrantsForCredit (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            data: [
                {
                    company_id: "company_id",
                    company_name: "company_name",
                    created_at: "2024-01-15T09:30:00Z",
                    credit_icon: "credit_icon",
                    credit_id: "credit_id",
                    credit_name: "credit_name",
                    expires_at: "2024-01-15T09:30:00Z",
                    grant_reason: "billing_credit_auto_topup",
                    id: "id",
                    plan_id: "plan_id",
                    plan_name: "plan_name",
                    price: {
                        currency: "currency",
                        external_price_id: "external_price_id",
                        id: "id",
                        interval: "day",
                        price: 1,
                        provider_type: "schematic",
                        scheme: "per_unit",
                    },
                    quantity: 1,
                    quantity_remaining: 1.1,
                    quantity_used: 1.1,
                    renewal_enabled: true,
                    renewal_period: "daily",
                    source_label: "source_label",
                    transfers: [
                        {
                            amount: 1.1,
                            created_at: "2024-01-15T09:30:00Z",
                            direction: "direction",
                            id: "id",
                            reason: "reason",
                            related_grant_id: "related_grant_id",
                        },
                    ],
                    updated_at: "2024-01-15T09:30:00Z",
                    valid_from: "2024-01-15T09:30:00Z",
                    zeroed_out_date: "2024-01-15T09:30:00Z",
                    zeroed_out_reason: "expired",
                },
            ],
            params: { credit_id: "credit_id", ids: ["ids"], limit: 1, offset: 1 },
        };
        server
            .mockEndpoint()
            .get("/billing/credits/grants/list")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.credits.listGrantsForCredit({
            creditId: "credit_id",
            limit: 1,
            offset: 1,
        });
        expect(response).toEqual({
            data: [
                {
                    companyId: "company_id",
                    companyName: "company_name",
                    createdAt: new Date("2024-01-15T09:30:00.000Z"),
                    creditIcon: "credit_icon",
                    creditId: "credit_id",
                    creditName: "credit_name",
                    expiresAt: new Date("2024-01-15T09:30:00.000Z"),
                    grantReason: "billing_credit_auto_topup",
                    id: "id",
                    planId: "plan_id",
                    planName: "plan_name",
                    price: {
                        currency: "currency",
                        externalPriceId: "external_price_id",
                        id: "id",
                        interval: "day",
                        price: 1,
                        providerType: "schematic",
                        scheme: "per_unit",
                    },
                    quantity: 1,
                    quantityRemaining: 1.1,
                    quantityUsed: 1.1,
                    renewalEnabled: true,
                    renewalPeriod: "daily",
                    sourceLabel: "source_label",
                    transfers: [
                        {
                            amount: 1.1,
                            createdAt: new Date("2024-01-15T09:30:00.000Z"),
                            direction: "direction",
                            id: "id",
                            reason: "reason",
                            relatedGrantId: "related_grant_id",
                        },
                    ],
                    updatedAt: new Date("2024-01-15T09:30:00.000Z"),
                    validFrom: new Date("2024-01-15T09:30:00.000Z"),
                    zeroedOutDate: new Date("2024-01-15T09:30:00.000Z"),
                    zeroedOutReason: "expired",
                },
            ],
            params: {
                creditId: "credit_id",
                ids: ["ids"],
                limit: 1,
                offset: 1,
            },
        });
    });

    test("listGrantsForCredit (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/grants/list")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.listGrantsForCredit();
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("listGrantsForCredit (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/grants/list")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.listGrantsForCredit();
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("listGrantsForCredit (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/grants/list")
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.listGrantsForCredit();
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("listGrantsForCredit (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/grants/list")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.listGrantsForCredit();
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("listGrantsForCredit (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/grants/list")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.listGrantsForCredit();
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("getEnrichedCreditLedger (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            data: [
                {
                    billing_credit_auto_topup_grant_count: 1,
                    billing_credit_id: "billing_credit_id",
                    company: { id: "id", name: "name" },
                    company_id: "company_id",
                    credit: { id: "id", name: "name" },
                    expired_grant_count: 1,
                    feature: { id: "id", name: "name" },
                    feature_id: "feature_id",
                    first_transaction_at: "2024-01-15T09:30:00Z",
                    free_grant_count: 1,
                    grant_count: 1,
                    last_transaction_at: "2024-01-15T09:30:00Z",
                    manually_zeroed_count: 1,
                    net_change: 1.1,
                    plan_grant_count: 1,
                    purchased_grant_count: 1,
                    time_bucket: "2024-01-15T09:30:00Z",
                    total_consumed: 1.1,
                    total_granted: 1.1,
                    transaction_count: 1,
                    usage_count: 1,
                    zeroed_out_count: 1,
                },
            ],
            params: {
                billing_credit_id: "billing_credit_id",
                company_id: "company_id",
                end_time: "end_time",
                feature_id: "feature_id",
                limit: 1,
                offset: 1,
                period: "daily",
                start_time: "start_time",
            },
        };
        server
            .mockEndpoint()
            .get("/billing/credits/ledger")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.credits.getEnrichedCreditLedger({
            companyId: "company_id",
            billingCreditId: "billing_credit_id",
            featureId: "feature_id",
            period: "daily",
            startTime: "start_time",
            endTime: "end_time",
            limit: 1,
            offset: 1,
        });
        expect(response).toEqual({
            data: [
                {
                    billingCreditAutoTopupGrantCount: 1,
                    billingCreditId: "billing_credit_id",
                    company: {
                        id: "id",
                        name: "name",
                    },
                    companyId: "company_id",
                    credit: {
                        id: "id",
                        name: "name",
                    },
                    expiredGrantCount: 1,
                    feature: {
                        id: "id",
                        name: "name",
                    },
                    featureId: "feature_id",
                    firstTransactionAt: new Date("2024-01-15T09:30:00.000Z"),
                    freeGrantCount: 1,
                    grantCount: 1,
                    lastTransactionAt: new Date("2024-01-15T09:30:00.000Z"),
                    manuallyZeroedCount: 1,
                    netChange: 1.1,
                    planGrantCount: 1,
                    purchasedGrantCount: 1,
                    timeBucket: new Date("2024-01-15T09:30:00.000Z"),
                    totalConsumed: 1.1,
                    totalGranted: 1.1,
                    transactionCount: 1,
                    usageCount: 1,
                    zeroedOutCount: 1,
                },
            ],
            params: {
                billingCreditId: "billing_credit_id",
                companyId: "company_id",
                endTime: "end_time",
                featureId: "feature_id",
                limit: 1,
                offset: 1,
                period: "daily",
                startTime: "start_time",
            },
        });
    });

    test("getEnrichedCreditLedger (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/ledger")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.getEnrichedCreditLedger({
                companyId: "company_id",
                period: "daily",
            });
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("getEnrichedCreditLedger (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/ledger")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.getEnrichedCreditLedger({
                companyId: "company_id",
                period: "daily",
            });
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("getEnrichedCreditLedger (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/ledger")
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.getEnrichedCreditLedger({
                companyId: "company_id",
                period: "daily",
            });
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("getEnrichedCreditLedger (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/ledger")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.getEnrichedCreditLedger({
                companyId: "company_id",
                period: "daily",
            });
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("getEnrichedCreditLedger (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/ledger")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.getEnrichedCreditLedger({
                companyId: "company_id",
                period: "daily",
            });
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("countCreditLedger (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            data: { count: 1 },
            params: {
                billing_credit_id: "billing_credit_id",
                company_id: "company_id",
                end_time: "end_time",
                feature_id: "feature_id",
                limit: 1,
                offset: 1,
                period: "daily",
                start_time: "start_time",
            },
        };
        server
            .mockEndpoint()
            .get("/billing/credits/ledger/count")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.credits.countCreditLedger({
            companyId: "company_id",
            billingCreditId: "billing_credit_id",
            featureId: "feature_id",
            period: "daily",
            startTime: "start_time",
            endTime: "end_time",
            limit: 1,
            offset: 1,
        });
        expect(response).toEqual({
            data: {
                count: 1,
            },
            params: {
                billingCreditId: "billing_credit_id",
                companyId: "company_id",
                endTime: "end_time",
                featureId: "feature_id",
                limit: 1,
                offset: 1,
                period: "daily",
                startTime: "start_time",
            },
        });
    });

    test("countCreditLedger (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/ledger/count")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.countCreditLedger({
                companyId: "company_id",
                period: "daily",
            });
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("countCreditLedger (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/ledger/count")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.countCreditLedger({
                companyId: "company_id",
                period: "daily",
            });
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("countCreditLedger (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/ledger/count")
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.countCreditLedger({
                companyId: "company_id",
                period: "daily",
            });
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("countCreditLedger (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/ledger/count")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.countCreditLedger({
                companyId: "company_id",
                period: "daily",
            });
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("countCreditLedger (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/ledger/count")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.countCreditLedger({
                companyId: "company_id",
                period: "daily",
            });
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("listBillingPlanCreditGrants (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            data: [
                {
                    auto_topup_amount: 1,
                    auto_topup_amount_type: "auto_topup_amount_type",
                    auto_topup_enabled: true,
                    auto_topup_expiry_type: "duration",
                    auto_topup_expiry_unit: "billing_periods",
                    auto_topup_expiry_unit_count: 1,
                    auto_topup_threshold_percent: 1,
                    created_at: "2024-01-15T09:30:00Z",
                    credit_amount: 1,
                    credit_id: "credit_id",
                    credit_name: "credit_name",
                    credit_plural_name: "credit_plural_name",
                    credit_singular_name: "credit_singular_name",
                    expiry_type: "duration",
                    expiry_unit: "billing_periods",
                    expiry_unit_count: 1,
                    id: "id",
                    plan_id: "plan_id",
                    plan_name: "plan_name",
                    reset_cadence: "daily",
                    reset_start: "billing_period",
                    reset_type: "no_reset",
                    updated_at: "2024-01-15T09:30:00Z",
                },
            ],
            params: {
                credit_id: "credit_id",
                ids: ["ids"],
                limit: 1,
                offset: 1,
                plan_id: "plan_id",
                plan_ids: ["plan_ids"],
            },
        };
        server
            .mockEndpoint()
            .get("/billing/credits/plan-grants")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.credits.listBillingPlanCreditGrants({
            creditId: "credit_id",
            planId: "plan_id",
            limit: 1,
            offset: 1,
        });
        expect(response).toEqual({
            data: [
                {
                    autoTopupAmount: 1,
                    autoTopupAmountType: "auto_topup_amount_type",
                    autoTopupEnabled: true,
                    autoTopupExpiryType: "duration",
                    autoTopupExpiryUnit: "billing_periods",
                    autoTopupExpiryUnitCount: 1,
                    autoTopupThresholdPercent: 1,
                    createdAt: new Date("2024-01-15T09:30:00.000Z"),
                    creditAmount: 1,
                    creditId: "credit_id",
                    creditName: "credit_name",
                    creditPluralName: "credit_plural_name",
                    creditSingularName: "credit_singular_name",
                    expiryType: "duration",
                    expiryUnit: "billing_periods",
                    expiryUnitCount: 1,
                    id: "id",
                    planId: "plan_id",
                    planName: "plan_name",
                    resetCadence: "daily",
                    resetStart: "billing_period",
                    resetType: "no_reset",
                    updatedAt: new Date("2024-01-15T09:30:00.000Z"),
                },
            ],
            params: {
                creditId: "credit_id",
                ids: ["ids"],
                limit: 1,
                offset: 1,
                planId: "plan_id",
                planIds: ["plan_ids"],
            },
        });
    });

    test("listBillingPlanCreditGrants (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/plan-grants")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.listBillingPlanCreditGrants();
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("listBillingPlanCreditGrants (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/plan-grants")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.listBillingPlanCreditGrants();
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("listBillingPlanCreditGrants (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/plan-grants")
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.listBillingPlanCreditGrants();
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("listBillingPlanCreditGrants (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/plan-grants")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.listBillingPlanCreditGrants();
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("listBillingPlanCreditGrants (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/plan-grants")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.listBillingPlanCreditGrants();
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("createBillingPlanCreditGrant (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            credit_amount: 1,
            credit_id: "credit_id",
            plan_id: "plan_id",
            reset_cadence: "daily",
            reset_start: "billing_period",
        };
        const rawResponseBody = {
            data: {
                auto_topup_amount: 1,
                auto_topup_amount_type: "auto_topup_amount_type",
                auto_topup_enabled: true,
                auto_topup_expiry_type: "duration",
                auto_topup_expiry_unit: "billing_periods",
                auto_topup_expiry_unit_count: 1,
                auto_topup_threshold_percent: 1,
                created_at: "2024-01-15T09:30:00Z",
                credit_amount: 1,
                credit_id: "credit_id",
                credit_name: "credit_name",
                credit_plural_name: "credit_plural_name",
                credit_singular_name: "credit_singular_name",
                expiry_type: "duration",
                expiry_unit: "billing_periods",
                expiry_unit_count: 1,
                id: "id",
                plan_id: "plan_id",
                plan_name: "plan_name",
                reset_cadence: "daily",
                reset_start: "billing_period",
                reset_type: "no_reset",
                updated_at: "2024-01-15T09:30:00Z",
            },
            params: { key: "value" },
        };
        server
            .mockEndpoint()
            .post("/billing/credits/plan-grants")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.credits.createBillingPlanCreditGrant({
            creditAmount: 1,
            creditId: "credit_id",
            planId: "plan_id",
            resetCadence: "daily",
            resetStart: "billing_period",
        });
        expect(response).toEqual({
            data: {
                autoTopupAmount: 1,
                autoTopupAmountType: "auto_topup_amount_type",
                autoTopupEnabled: true,
                autoTopupExpiryType: "duration",
                autoTopupExpiryUnit: "billing_periods",
                autoTopupExpiryUnitCount: 1,
                autoTopupThresholdPercent: 1,
                createdAt: new Date("2024-01-15T09:30:00.000Z"),
                creditAmount: 1,
                creditId: "credit_id",
                creditName: "credit_name",
                creditPluralName: "credit_plural_name",
                creditSingularName: "credit_singular_name",
                expiryType: "duration",
                expiryUnit: "billing_periods",
                expiryUnitCount: 1,
                id: "id",
                planId: "plan_id",
                planName: "plan_name",
                resetCadence: "daily",
                resetStart: "billing_period",
                resetType: "no_reset",
                updatedAt: new Date("2024-01-15T09:30:00.000Z"),
            },
            params: {
                key: "value",
            },
        });
    });

    test("createBillingPlanCreditGrant (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            credit_amount: 1,
            credit_id: "credit_id",
            plan_id: "plan_id",
            reset_cadence: "daily",
            reset_start: "billing_period",
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/credits/plan-grants")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.createBillingPlanCreditGrant({
                creditAmount: 1,
                creditId: "credit_id",
                planId: "plan_id",
                resetCadence: "daily",
                resetStart: "billing_period",
            });
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("createBillingPlanCreditGrant (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            credit_amount: 1,
            credit_id: "credit_id",
            plan_id: "plan_id",
            reset_cadence: "daily",
            reset_start: "billing_period",
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/credits/plan-grants")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.createBillingPlanCreditGrant({
                creditAmount: 1,
                creditId: "credit_id",
                planId: "plan_id",
                resetCadence: "daily",
                resetStart: "billing_period",
            });
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("createBillingPlanCreditGrant (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            credit_amount: 1,
            credit_id: "credit_id",
            plan_id: "plan_id",
            reset_cadence: "daily",
            reset_start: "billing_period",
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/credits/plan-grants")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.createBillingPlanCreditGrant({
                creditAmount: 1,
                creditId: "credit_id",
                planId: "plan_id",
                resetCadence: "daily",
                resetStart: "billing_period",
            });
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("createBillingPlanCreditGrant (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            credit_amount: 1,
            credit_id: "credit_id",
            plan_id: "plan_id",
            reset_cadence: "daily",
            reset_start: "billing_period",
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/credits/plan-grants")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.createBillingPlanCreditGrant({
                creditAmount: 1,
                creditId: "credit_id",
                planId: "plan_id",
                resetCadence: "daily",
                resetStart: "billing_period",
            });
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("createBillingPlanCreditGrant (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            credit_amount: 1,
            credit_id: "credit_id",
            plan_id: "plan_id",
            reset_cadence: "daily",
            reset_start: "billing_period",
        };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/billing/credits/plan-grants")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.createBillingPlanCreditGrant({
                creditAmount: 1,
                creditId: "credit_id",
                planId: "plan_id",
                resetCadence: "daily",
                resetStart: "billing_period",
            });
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("updateBillingPlanCreditGrant (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { reset_cadence: "daily", reset_start: "billing_period" };
        const rawResponseBody = {
            data: {
                auto_topup_amount: 1,
                auto_topup_amount_type: "auto_topup_amount_type",
                auto_topup_enabled: true,
                auto_topup_expiry_type: "duration",
                auto_topup_expiry_unit: "billing_periods",
                auto_topup_expiry_unit_count: 1,
                auto_topup_threshold_percent: 1,
                created_at: "2024-01-15T09:30:00Z",
                credit_amount: 1,
                credit_id: "credit_id",
                credit_name: "credit_name",
                credit_plural_name: "credit_plural_name",
                credit_singular_name: "credit_singular_name",
                expiry_type: "duration",
                expiry_unit: "billing_periods",
                expiry_unit_count: 1,
                id: "id",
                plan_id: "plan_id",
                plan_name: "plan_name",
                reset_cadence: "daily",
                reset_start: "billing_period",
                reset_type: "no_reset",
                updated_at: "2024-01-15T09:30:00Z",
            },
            params: { key: "value" },
        };
        server
            .mockEndpoint()
            .put("/billing/credits/plan-grants/plan_grant_id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.credits.updateBillingPlanCreditGrant("plan_grant_id", {
            resetCadence: "daily",
            resetStart: "billing_period",
        });
        expect(response).toEqual({
            data: {
                autoTopupAmount: 1,
                autoTopupAmountType: "auto_topup_amount_type",
                autoTopupEnabled: true,
                autoTopupExpiryType: "duration",
                autoTopupExpiryUnit: "billing_periods",
                autoTopupExpiryUnitCount: 1,
                autoTopupThresholdPercent: 1,
                createdAt: new Date("2024-01-15T09:30:00.000Z"),
                creditAmount: 1,
                creditId: "credit_id",
                creditName: "credit_name",
                creditPluralName: "credit_plural_name",
                creditSingularName: "credit_singular_name",
                expiryType: "duration",
                expiryUnit: "billing_periods",
                expiryUnitCount: 1,
                id: "id",
                planId: "plan_id",
                planName: "plan_name",
                resetCadence: "daily",
                resetStart: "billing_period",
                resetType: "no_reset",
                updatedAt: new Date("2024-01-15T09:30:00.000Z"),
            },
            params: {
                key: "value",
            },
        });
    });

    test("updateBillingPlanCreditGrant (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { reset_cadence: "daily", reset_start: "billing_period" };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .put("/billing/credits/plan-grants/plan_grant_id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.updateBillingPlanCreditGrant("plan_grant_id", {
                resetCadence: "daily",
                resetStart: "billing_period",
            });
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("updateBillingPlanCreditGrant (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { reset_cadence: "daily", reset_start: "billing_period" };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .put("/billing/credits/plan-grants/plan_grant_id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.updateBillingPlanCreditGrant("plan_grant_id", {
                resetCadence: "daily",
                resetStart: "billing_period",
            });
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("updateBillingPlanCreditGrant (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { reset_cadence: "daily", reset_start: "billing_period" };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .put("/billing/credits/plan-grants/plan_grant_id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.updateBillingPlanCreditGrant("plan_grant_id", {
                resetCadence: "daily",
                resetStart: "billing_period",
            });
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("updateBillingPlanCreditGrant (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { reset_cadence: "daily", reset_start: "billing_period" };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .put("/billing/credits/plan-grants/plan_grant_id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.updateBillingPlanCreditGrant("plan_grant_id", {
                resetCadence: "daily",
                resetStart: "billing_period",
            });
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("updateBillingPlanCreditGrant (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { reset_cadence: "daily", reset_start: "billing_period" };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .put("/billing/credits/plan-grants/plan_grant_id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.updateBillingPlanCreditGrant("plan_grant_id", {
                resetCadence: "daily",
                resetStart: "billing_period",
            });
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("deleteBillingPlanCreditGrant (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { data: { deleted: true }, params: { apply_to_existing: true } };
        server
            .mockEndpoint()
            .delete("/billing/credits/plan-grants/plan_grant_id")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.credits.deleteBillingPlanCreditGrant("plan_grant_id", {
            applyToExisting: true,
        });
        expect(response).toEqual({
            data: {
                deleted: true,
            },
            params: {
                applyToExisting: true,
            },
        });
    });

    test("deleteBillingPlanCreditGrant (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .delete("/billing/credits/plan-grants/plan_grant_id")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.deleteBillingPlanCreditGrant("plan_grant_id");
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("deleteBillingPlanCreditGrant (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .delete("/billing/credits/plan-grants/plan_grant_id")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.deleteBillingPlanCreditGrant("plan_grant_id");
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("deleteBillingPlanCreditGrant (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .delete("/billing/credits/plan-grants/plan_grant_id")
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.deleteBillingPlanCreditGrant("plan_grant_id");
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("deleteBillingPlanCreditGrant (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .delete("/billing/credits/plan-grants/plan_grant_id")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.deleteBillingPlanCreditGrant("plan_grant_id");
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("deleteBillingPlanCreditGrant (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .delete("/billing/credits/plan-grants/plan_grant_id")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.deleteBillingPlanCreditGrant("plan_grant_id");
        }).rejects.toThrow(Schematic.InternalServerError);
    });

    test("countBillingPlanCreditGrants (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            data: { count: 1 },
            params: {
                credit_id: "credit_id",
                ids: ["ids"],
                limit: 1,
                offset: 1,
                plan_id: "plan_id",
                plan_ids: ["plan_ids"],
            },
        };
        server
            .mockEndpoint()
            .get("/billing/credits/plan-grants/count")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.credits.countBillingPlanCreditGrants({
            creditId: "credit_id",
            planId: "plan_id",
            limit: 1,
            offset: 1,
        });
        expect(response).toEqual({
            data: {
                count: 1,
            },
            params: {
                creditId: "credit_id",
                ids: ["ids"],
                limit: 1,
                offset: 1,
                planId: "plan_id",
                planIds: ["plan_ids"],
            },
        });
    });

    test("countBillingPlanCreditGrants (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/plan-grants/count")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.countBillingPlanCreditGrants();
        }).rejects.toThrow(Schematic.BadRequestError);
    });

    test("countBillingPlanCreditGrants (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/plan-grants/count")
            .respondWith()
            .statusCode(401)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.countBillingPlanCreditGrants();
        }).rejects.toThrow(Schematic.UnauthorizedError);
    });

    test("countBillingPlanCreditGrants (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/plan-grants/count")
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.countBillingPlanCreditGrants();
        }).rejects.toThrow(Schematic.ForbiddenError);
    });

    test("countBillingPlanCreditGrants (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/plan-grants/count")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.countBillingPlanCreditGrants();
        }).rejects.toThrow(Schematic.NotFoundError);
    });

    test("countBillingPlanCreditGrants (6)", async () => {
        const server = mockServerPool.createServer();
        const client = new SchematicClient({ maxRetries: 0, apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/billing/credits/plan-grants/count")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.credits.countBillingPlanCreditGrants();
        }).rejects.toThrow(Schematic.InternalServerError);
    });
});
